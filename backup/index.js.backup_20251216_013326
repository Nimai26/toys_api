// index.js
import express from "express";
import fetch from "node-fetch";
import crypto from "crypto";
import compression from "compression";

// Import du module Amazon
import {
  searchAmazon,
  getAmazonProduct,
  searchByBarcode as searchAmazonByBarcode,
  searchMultiCountry as searchAmazonMultiCountry,
  comparePrices as compareAmazonPrices,
  getSupportedMarketplaces,
  getSupportedCategories,
  AMAZON_MARKETPLACES,
  AMAZON_CATEGORIES,
  checkVpnStatus,
  rotateVpnIp
} from './lib/amazon.js';

// Import du module LEGO (avec alias)
import {
  callLegoGraphql as callLegoGraphqlLib,
  getProductDetails as getLegoProductDetailsLib,
  getBuildingInstructions as getBuildingInstructionsLib
} from './lib/lego.js';

// Import du module Rebrickable (avec alias)
import {
  smartRebrickableSearch as smartRebrickableSearchLib,
  getRebrickableSetFull as getRebrickableSetFullLib,
  getRebrickableSetParts as getRebrickableSetPartsLib,
  getRebrickableSetMinifigs as getRebrickableSetMinifigsLib,
  searchRebrickable as searchRebrickableLib,
  getRebrickableThemes as getRebrickableThemesLib,
  getRebrickableColors as getRebrickableColorsLib
} from './lib/rebrickable.js';

// Import du module livres (Google Books + OpenLibrary) (avec alias)
import {
  searchGoogleBooks as searchGoogleBooksLib,
  getGoogleBookById as getGoogleBookByIdLib,
  searchOpenLibrary as searchOpenLibraryLib,
  searchOpenLibraryByIsbn as searchOpenLibraryByIsbnLib,
  searchOpenLibraryByText as searchOpenLibraryByTextLib,
  getOpenLibraryById as getOpenLibraryByIdLib,
  isIsbn as isIsbnLib
} from './lib/books.js';

// Import du module jeux vid√©o (RAWG + IGDB + JVC) (avec alias)
import {
  searchRawg as searchRawgLib,
  getRawgGameDetails as getRawgGameDetailsLib,
  getIgdbToken as getIgdbTokenLib,
  searchIgdb as searchIgdbLib,
  getIgdbGameDetails as getIgdbGameDetailsLib,
  searchJVC as searchJVCLib,
  getJVCGameById as getJVCGameByIdLib
} from './lib/videogames.js';

// Import du module m√©dias (TVDB + TMDB + IMDB) (avec alias)
import {
  getTvdbToken as getTvdbTokenLib,
  searchTvdb as searchTvdbLib,
  getTvdbSeriesById as getTvdbSeriesByIdLib,
  getTvdbMovieById as getTvdbMovieByIdLib,
  searchTmdb as searchTmdbLib,
  getTmdbMovieById as getTmdbMovieByIdLib,
  getTmdbTvById as getTmdbTvByIdLib,
  searchImdb as searchImdbLib,
  getImdbTitleById as getImdbTitleByIdLib,
  browseImdbTitles as browseImdbTitlesLib
} from './lib/media.js';

// Import du module anime (Jikan) (avec alias)
import {
  searchJikanAnime as searchJikanAnimeLib,
  searchJikanManga as searchJikanMangaLib,
  getJikanAnimeById as getJikanAnimeByIdLib,
  getJikanMangaById as getJikanMangaByIdLib
} from './lib/anime.js';

// Import du module comics (ComicVine + MangaDex + Bedetheque) (avec alias)
import {
  searchComicVine as searchComicVineLib,
  getComicVineVolume as getComicVineVolumeLib,
  getComicVineIssue as getComicVineIssueLib,
  searchMangaDex as searchMangaDexLib,
  getMangaDexById as getMangaDexByIdLib,
  searchBedetheque as searchBedethequeLib,
  searchBedethequeAlbums as searchBedethequeAlbumsLib,
  getBedethequeSerieById as getBedethequeSerieByIdLib,
  getBedethequeAlbumById as getBedethequeAlbumByIdLib
} from './lib/comics.js';

// Import du module collectibles (Coleka, LuluBerlu, Paninimania, etc.) (avec alias)
import {
  searchMega as searchMegaLib,
  getMegaProductById as getMegaProductByIdLib,
  searchColeka as searchColekaLib,
  searchLuluBerlu as searchLuluBerluLib,
  searchTransformerland as searchTransformerlandLib,
  searchConsoleVariations as searchConsoleVariationsLib,
  searchPaninimania as searchPaninimanaLib
} from './lib/collectibles.js';

const app = express();
const API_VERSION = "1.26.0";
const PORT = process.env.PORT ? parseInt(process.env.PORT) : 3000;
const FSR_BASE = process.env.FSR_URL || "http://10.110.1.1:8191/v1";
const DEFAULT_LOCALE = process.env.DEFAULT_LOCALE || "fr-FR";
const MAX_RETRIES = process.env.MAX_RETRIES ? parseInt(process.env.MAX_RETRIES) : 3;
const GRAPHQL_URL = "https://www.lego.com/api/graphql/SearchProductsQuery";
const USER_AGENT = process.env.USER_AGENT || "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36";

// Activer la compression gzip pour toutes les r√©ponses
app.use(compression({
  level: 6, // Niveau de compression (1-9, 6 est un bon compromis vitesse/taille)
  threshold: 1024, // Ne compresser que si > 1KB
  filter: (req, res) => {
    // Compresser sauf si le header indique de ne pas le faire
    if (req.headers['x-no-compression']) return false;
    return compression.filter(req, res);
  }
}));

// Middleware JSON avec limite de taille (protection contre les gros payloads)
app.use(express.json({ limit: '1mb' }));

// Middleware CORS - permet l'acc√®s depuis n'importe quel domaine
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});

// Middleware pour les headers de s√©curit√©
app.use((req, res, next) => {
  res.header('X-Content-Type-Options', 'nosniff');
  res.header('X-Frame-Options', 'DENY');
  res.header('X-XSS-Protection', '1; mode=block');
  next();
});

// Middleware pour ajouter un Request ID unique (utile pour le debugging)
app.use((req, res, next) => {
  req.id = crypto.randomUUID().substring(0, 8);
  res.header('X-Request-ID', req.id);
  next();
});

// Configuration du cache
const CACHE_TTL = process.env.CACHE_TTL ? parseInt(process.env.CACHE_TTL) : 300000; // 5 minutes par d√©faut
const CACHE_MAX_SIZE = process.env.CACHE_MAX_SIZE ? parseInt(process.env.CACHE_MAX_SIZE) : 100; // Max 100 entr√©es
const cache = new Map();

// Mode de log: 'debug' = tous les logs, 'info' = logs importants, 'error' = erreurs seulement
const LOG_LEVEL = process.env.LOG_LEVEL || 'info';
const log = {
  debug: (...args) => LOG_LEVEL === 'debug' && console.log(...args),
  info: (...args) => ['debug', 'info'].includes(LOG_LEVEL) && console.log(...args),
  warn: (...args) => ['debug', 'info', 'warn'].includes(LOG_LEVEL) && console.warn(...args),
  error: (...args) => console.error(...args)
};

// M√©triques pour le cache et les performances
const metrics = {
  startTime: Date.now(),
  requests: { total: 0, cached: 0, errors: 0 },
  responseTimeSum: 0,
  responseTimeCount: 0,
  sources: {
    lego: { requests: 0, errors: 0 },
    coleka: { requests: 0, errors: 0 },
    luluberlu: { requests: 0, errors: 0 },
    transformerland: { requests: 0, errors: 0 },
    paninimania: { requests: 0, errors: 0 },
    rebrickable: { requests: 0, errors: 0 },
    googlebooks: { requests: 0, errors: 0 },
    openlibrary: { requests: 0, errors: 0 },
    rawg: { requests: 0, errors: 0 },
    igdb: { requests: 0, errors: 0 },
    tvdb: { requests: 0, errors: 0 },
    tmdb: { requests: 0, errors: 0 },
    imdb: { requests: 0, errors: 0 },
    jikan: { requests: 0, errors: 0 },
    comicvine: { requests: 0, errors: 0 },
    mangadex: { requests: 0, errors: 0 },
    bedetheque: { requests: 0, errors: 0 },
    jvc: { requests: 0, errors: 0 },
    mega: { requests: 0, errors: 0 },
    consolevariations: { requests: 0, errors: 0 },
    amazon: { requests: 0, errors: 0 },
    barcode: { requests: 0, errors: 0 },
    musicbrainz: { requests: 0, errors: 0 },
    discogs: { requests: 0, errors: 0 },
    deezer: { requests: 0, errors: 0 }
  }
};

// Middleware pour tracker les m√©triques
app.use((req, res, next) => {
  const startTime = Date.now();
  metrics.requests.total++;
  
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    metrics.responseTimeSum += duration;
    metrics.responseTimeCount++;
  });
  
  next();
});

// Fonction de cache avec TTL
function getCached(key) {
  const entry = cache.get(key);
  if (!entry) return null;
  if (Date.now() > entry.expiry) {
    cache.delete(key);
    return null;
  }
  // Mise √† jour du lastAccess pour LRU
  entry.lastAccess = Date.now();
  console.log(`[Cache] HIT: ${key.substring(0, 50)}...`);
  metrics.requests.cached++;
  return entry.data;
}

function setCache(key, data, customTtl = null) {
  // Nettoyer le cache si trop grand (LRU: supprimer le moins r√©cemment utilis√©)
  if (cache.size >= CACHE_MAX_SIZE) {
    let oldestKey = null;
    let oldestAccess = Infinity;
    for (const [k, v] of cache) {
      if (v.lastAccess < oldestAccess) {
        oldestAccess = v.lastAccess;
        oldestKey = k;
      }
    }
    if (oldestKey) cache.delete(oldestKey);
  }
  const ttl = customTtl || CACHE_TTL;
  const now = Date.now();
  cache.set(key, { data, expiry: now + ttl, lastAccess: now });
  console.log(`[Cache] SET: ${key.substring(0, 50)}... (TTL: ${ttl/1000}s)`);
}

// Middleware pour ajouter les headers Cache-Control
function addCacheHeaders(res, maxAge = 300) {
  res.set('Cache-Control', `public, max-age=${maxAge}`);
  res.set('X-Cache-TTL', `${maxAge}s`);
}

// Configuration Coleka
const COLEKA_BASE_URL = "https://www.coleka.com";
const COLEKA_DEFAULT_NBPP = 24; // Nombre de r√©sultats par page par d√©faut

// Configuration Lulu-Berlu
const LULUBERLU_BASE_URL = "https://www.lulu-berlu.com";
const LULUBERLU_SEARCH_URL = "https://www.lulu-berlu.com/dhtml/resultat_recherche.php";
const LULUBERLU_RESULTS_PER_PAGE = 12; // Lulu-Berlu retourne 12 r√©sultats par page
const LULUBERLU_DEFAULT_MAX = 24; // Nombre max de r√©sultats par d√©faut

// Configuration Transformerland
const TRANSFORMERLAND_BASE_URL = "https://www.transformerland.com";
const TRANSFORMERLAND_SEARCH_URL = "https://www.transformerland.com/store/search.php";
const TRANSFORMERLAND_DEFAULT_MAX = 50; // Nombre max de r√©sultats par d√©faut

// Configuration Paninimania
const PANINIMANIA_BASE_URL = "https://www.paninimania.com";
const PANINIMANIA_RESULTS_PER_PAGE = 10; // R√©sultats par page sur le site
const PANINIMANIA_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut

// Configuration Rebrickable (API officielle - n√©cessite une cl√© API)
const REBRICKABLE_BASE_URL = "https://rebrickable.com/api/v3";
const REBRICKABLE_DEFAULT_MAX = 100; // Nombre max de r√©sultats par d√©faut

// Configuration Google Books (API officielle - n√©cessite une cl√© API)
const GOOGLE_BOOKS_BASE_URL = "https://www.googleapis.com/books/v1";
const GOOGLE_BOOKS_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut (max API: 40)
const GOOGLE_BOOKS_MAX_LIMIT = 40; // Limite max impos√©e par l'API Google

// Configuration OpenLibrary (API gratuite - pas de cl√© requise)
const OPENLIBRARY_BASE_URL = "https://openlibrary.org";
const OPENLIBRARY_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut
const OPENLIBRARY_MAX_LIMIT = 100; // Limite raisonnable

// Configuration RAWG (API jeux vid√©o - n√©cessite une cl√© API)
const RAWG_BASE_URL = "https://api.rawg.io/api";
const RAWG_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut
const RAWG_MAX_LIMIT = 40; // Limite max par page

// Configuration IGDB (API jeux vid√©o Twitch - n√©cessite client_id + client_secret)
const IGDB_BASE_URL = "https://api.igdb.com/v4";
const IGDB_AUTH_URL = "https://id.twitch.tv/oauth2/token";
const IGDB_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut
const IGDB_MAX_LIMIT = 500; // Limite max par requ√™te IGDB

// Cache pour les tokens IGDB (dur√©e de vie ~60 jours)
let igdbTokenCache = {
  token: null,
  expiresAt: 0
};

// Configuration TVDB (API TV/Films - n√©cessite une cl√© API)
const TVDB_BASE_URL = "https://api4.thetvdb.com/v4";
const TVDB_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut
const TVDB_MAX_LIMIT = 100; // Limite raisonnable

// Cache pour les tokens TVDB (dur√©e de vie ~1 mois)
let tvdbTokenCache = {
  token: null,
  expiresAt: 0
};

// Configuration TMDB (API TV/Films - n√©cessite une cl√© API)
const TMDB_BASE_URL = "https://api.themoviedb.org/3";
const TMDB_IMAGE_BASE_URL = "https://image.tmdb.org/t/p";
const TMDB_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut (correspond √† une page)
const TMDB_MAX_LIMIT = 20; // TMDB retourne 20 r√©sultats par page max

// Configuration IMDB (via imdbapi.dev - PAS DE CL√â API REQUISE)
const IMDB_BASE_URL = "https://api.imdbapi.dev";
const IMDB_DEFAULT_MAX = 20; // Nombre max de r√©sultats par d√©faut
const IMDB_MAX_LIMIT = 50; // Limite max par requ√™te

// Configuration Jikan (MyAnimeList unofficial API - PAS DE CL√â API REQUISE)
const JIKAN_BASE_URL = "https://api.jikan.moe/v4";
const JIKAN_DEFAULT_MAX = 25; // Nombre max de r√©sultats par d√©faut (correspond √† une page)
const JIKAN_MAX_LIMIT = 25; // Limite max par page sur Jikan

// Configuration Comic Vine API (Comics US)
const COMICVINE_API_KEY = process.env.COMICVINE_API_KEY || "bfa4da15189d9bc49c5b3f25d9a11fb12f6a6a7e";
const COMICVINE_BASE_URL = "https://comicvine.gamespot.com/api";
const COMICVINE_DEFAULT_MAX = 20;
const COMICVINE_MAX_LIMIT = 100;

// Configuration MangaDex API (Manga - PAS DE CL√â API REQUISE)
const MANGADEX_BASE_URL = "https://api.mangadex.org";
const MANGADEX_COVERS_URL = "https://uploads.mangadex.org/covers";
const MANGADEX_DEFAULT_MAX = 20;
const MANGADEX_MAX_LIMIT = 100;

// Configuration Bedetheque (BD franco-belge - Scraping)
const BEDETHEQUE_BASE_URL = "https://www.bedetheque.com";
const BEDETHEQUE_DEFAULT_MAX = 20;

// Configuration JeuxVideo.com (Jeux vid√©o FR - Scraping)
const JVC_BASE_URL = "https://www.jeuxvideo.com";
const JVC_DEFAULT_MAX = 20;

// Configuration Mega Construx (Mattel - API Searchspring directe)
// Site US (en-US, es-MX, fr-CA, pt-BR, en-CA)
const MEGA_API_URL_US = "https://ck4bj7.a.searchspring.io/api/search/search.json";
const MEGA_SITE_ID_US = "ck4bj7";
const MEGA_BASE_URL_US = "https://shop.mattel.com";
// Site EU (fr-FR, de-DE, es-ES, it-IT, nl-NL, en-GB, pl-PL, tr-TR, el-GR, ru-RU)
const MEGA_API_URL_EU = "https://0w0shw.a.searchspring.io/api/search/search.json";
const MEGA_SITE_ID_EU = "0w0shw";
const MEGA_BASE_URL_EU = "https://shopping.mattel.com";
const MEGA_DEFAULT_MAX = 20;
const MEGA_MAX_LIMIT = 100;
const MEGA_DEFAULT_LANG = "fr-FR"; // Fran√ßais par d√©faut

// Mapping des langues vers la r√©gion (US ou EU)
const MEGA_LANG_REGION = {
  'en-US': 'US', 'es-MX': 'US', 'fr-CA': 'US', 'pt-BR': 'US', 'en-CA': 'US',
  'fr-FR': 'EU', 'de-DE': 'EU', 'es-ES': 'EU', 'it-IT': 'EU', 'nl-NL': 'EU',
  'en-GB': 'EU', 'pl-PL': 'EU', 'tr-TR': 'EU', 'el-GR': 'EU', 'ru-RU': 'EU'
};

// Configuration APIs Code-Barres
// UPC Item DB (gratuit, 100 req/jour sans cl√©)
const UPCITEMDB_BASE_URL = "https://api.upcitemdb.com/prod/trial/lookup";
// Open Food Facts (gratuit, illimit√©)
const OPENFOODFACTS_BASE_URL = "https://world.openfoodfacts.org/api/v2/product";
// Barcode Lookup (payant mais trial disponible)
const BARCODELOOKUP_BASE_URL = "https://api.barcodelookup.com/v3/products";

// Configuration APIs Musique
// MusicBrainz (gratuit, illimit√©, 1 req/sec recommand√©)
const MUSICBRAINZ_BASE_URL = "https://musicbrainz.org/ws/2";
const MUSICBRAINZ_COVER_URL = "https://coverartarchive.org";
// Discogs (gratuit, 60 req/min avec cl√©, 25 sans)
const DISCOGS_BASE_URL = "https://api.discogs.com";
// Deezer (gratuit, illimit√©)
const DEEZER_BASE_URL = "https://api.deezer.com";
// iTunes Search (gratuit, illimit√©)
const ITUNES_BASE_URL = "https://itunes.apple.com";

const MUSIC_DEFAULT_MAX = 20;

// Configuration ConsoleVariations (Consoles & Accessoires - Scraping)
const CONSOLEVARIATIONS_BASE_URL = "https://consolevariations.com";
const CONSOLEVARIATIONS_CDN_URL = "https://cdn.consolevariations.com";
const CONSOLEVARIATIONS_DEFAULT_MAX = 20;

// Session ID pour FlareSolverr (persistante)
let fsrSessionId = null;
// Timestamp de la derni√®re visite de la page d'accueil LEGO (pour √©viter de revisiter trop souvent)
let lastLegoHomeVisit = 0;
// Dur√©e de validit√© des cookies LEGO (10 minutes)
const LEGO_SESSION_TTL = 10 * 60 * 1000;

// M√©triques pour barcode
metrics.sources.barcode = { requests: 0, errors: 0 };
// M√©triques pour musique
metrics.sources.musicbrainz = { requests: 0, errors: 0 };
metrics.sources.discogs = { requests: 0, errors: 0 };
metrics.sources.deezer = { requests: 0, errors: 0 };

console.log("=========================================");
console.log(`üß∏ Toys API v${API_VERSION}`);
console.log("=========================================");
console.log("FSR:", FSR_BASE);
console.log("Coleka:", COLEKA_BASE_URL);
console.log("Lulu-Berlu:", LULUBERLU_BASE_URL);
console.log("Transformerland:", TRANSFORMERLAND_BASE_URL);
console.log("Google Books:", GOOGLE_BOOKS_BASE_URL);
console.log("OpenLibrary:", OPENLIBRARY_BASE_URL);
console.log("RAWG:", RAWG_BASE_URL);
console.log("IGDB:", IGDB_BASE_URL);
console.log("TVDB:", TVDB_BASE_URL);
console.log("TMDB:", TMDB_BASE_URL);
console.log("Paninimania:", PANINIMANIA_BASE_URL);
console.log("Rebrickable:", REBRICKABLE_BASE_URL);
console.log("JVC:", JVC_BASE_URL);
console.log("Mega Construx US:", MEGA_API_URL_US);
console.log("Mega Construx EU:", MEGA_API_URL_EU);
console.log("Mega Default Lang:", MEGA_DEFAULT_LANG);
console.log("MusicBrainz:", MUSICBRAINZ_BASE_URL);
console.log("Discogs:", DISCOGS_BASE_URL);
console.log("Deezer:", DEEZER_BASE_URL);
console.log("ConsoleVariations:", CONSOLEVARIATIONS_BASE_URL);
console.log("Cache TTL:", CACHE_TTL/1000, "seconds");

// D√©coder les entit√©s HTML
function decodeHtmlEntities(text) {
  if (!text) return text;
  return text
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    .replace(/&nbsp;/g, ' ')
    .replace(/&#160;/g, ' ')
    .replace(/&#(\d+);/g, (_, dec) => String.fromCharCode(dec))
    .replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
}

// -----------------------------
// Syst√®me de chiffrement des cl√©s API (AES-256-GCM)
// -----------------------------
const API_ENCRYPTION_KEY = process.env.API_ENCRYPTION_KEY || null;
const ENCRYPTION_ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 12; // Recommand√© pour GCM
const AUTH_TAG_LENGTH = 16;

/**
 * D√©chiffre une cl√© API chiffr√©e en AES-256-GCM
 * Format attendu: base64(iv + authTag + ciphertext)
 * @param {string} encryptedData - Donn√©es chiffr√©es en base64
 * @returns {string|null} - Cl√© d√©chiffr√©e ou null si erreur
 */
function decryptApiKey(encryptedData) {
  if (!API_ENCRYPTION_KEY) {
    console.error("[Crypto] API_ENCRYPTION_KEY non configur√©e");
    return null;
  }
  
  try {
    // D√©code le base64
    const buffer = Buffer.from(encryptedData, 'base64');
    
    // Extrait IV (12 bytes), authTag (16 bytes), et ciphertext
    const iv = buffer.subarray(0, IV_LENGTH);
    const authTag = buffer.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    const ciphertext = buffer.subarray(IV_LENGTH + AUTH_TAG_LENGTH);
    
    // Pr√©pare la cl√© (32 bytes pour AES-256)
    const key = crypto.createHash('sha256').update(API_ENCRYPTION_KEY).digest();
    
    // D√©chiffre
    const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(ciphertext, null, 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  } catch (err) {
    console.error("[Crypto] Erreur d√©chiffrement:", err.message);
    return null;
  }
}

/**
 * Chiffre une cl√© API en AES-256-GCM
 * Retourne: base64(iv + authTag + ciphertext)
 * Cette fonction est fournie pour r√©f√©rence client
 * @param {string} plainKey - Cl√© en clair
 * @returns {string|null} - Donn√©es chiffr√©es en base64 ou null si erreur
 */
function encryptApiKey(plainKey) {
  if (!API_ENCRYPTION_KEY) {
    console.error("[Crypto] API_ENCRYPTION_KEY non configur√©e");
    return null;
  }
  
  try {
    // G√©n√®re un IV al√©atoire
    const iv = crypto.randomBytes(IV_LENGTH);
    
    // Pr√©pare la cl√© (32 bytes pour AES-256)
    const key = crypto.createHash('sha256').update(API_ENCRYPTION_KEY).digest();
    
    // Chiffre
    const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, key, iv);
    
    let ciphertext = cipher.update(plainKey, 'utf8');
    ciphertext = Buffer.concat([ciphertext, cipher.final()]);
    
    const authTag = cipher.getAuthTag();
    
    // Combine: iv + authTag + ciphertext
    const result = Buffer.concat([iv, authTag, ciphertext]);
    
    return result.toString('base64');
  } catch (err) {
    console.error("[Crypto] Erreur chiffrement:", err.message);
    return null;
  }
}

/**
 * Extrait et d√©chiffre la cl√© API depuis les headers
 * Supporte: X-Encrypted-Key (chiffr√©e) ou X-Api-Key (clair, si pas de cl√© de chiffrement configur√©e)
 * @param {object} req - Request Express
 * @returns {string|null} - Cl√© API d√©chiffr√©e ou null
 */
function extractApiKey(req) {
  // Priorit√© 1: Cl√© chiffr√©e dans X-Encrypted-Key
  const encryptedKey = req.headers['x-encrypted-key'];
  if (encryptedKey) {
    const decrypted = decryptApiKey(encryptedKey);
    if (decrypted) {
      return decrypted;
    }
    console.warn("[Crypto] √âchec d√©chiffrement de X-Encrypted-Key");
    return null;
  }
  
  // Priorit√© 2: Cl√© en clair dans X-Api-Key (seulement si API_ENCRYPTION_KEY non configur√©e)
  const plainKey = req.headers['x-api-key'];
  if (plainKey) {
    if (API_ENCRYPTION_KEY) {
      console.warn("[Crypto] X-Api-Key ignor√©e car le chiffrement est activ√©. Utilisez X-Encrypted-Key.");
      return null;
    }
    return plainKey;
  }
  
  // Priorit√© 3: Param√®tre query 'api_key' (seulement si API_ENCRYPTION_KEY non configur√©e)
  const queryKey = req.query.api_key;
  if (queryKey) {
    if (API_ENCRYPTION_KEY) {
      console.warn("[Crypto] api_key query ignor√©e car le chiffrement est activ√©. Utilisez X-Encrypted-Key.");
      return null;
    }
    return queryKey;
  }
  
  return null;
}

// Log configuration chiffrement au d√©marrage
if (API_ENCRYPTION_KEY) {
  console.log("[Crypto] Chiffrement des cl√©s API activ√© (AES-256-GCM)");
} else {
  console.log("[Crypto] Chiffrement des cl√©s API d√©sactiv√© (API_ENCRYPTION_KEY non d√©finie)");
}

// G√©n√®re un UUID v4
function generateUUID() {
  return crypto.randomUUID();
}

// G√©n√®re un ID de session al√©atoire (21 chars)
function generateSessionId() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < 21; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Nettoie un ID en retirant les pr√©fixes courants ajout√©s par les clients
 * Pr√©fixes support√©s: {source}_, {source}-, ex: bedetheque_12345, olib_OL123W
 * @param {string} id - L'ID √† nettoyer
 * @param {string} source - La source attendue (openlibrary, bedetheque, googlebooks, etc.)
 * @returns {string} - L'ID nettoy√©
 */
function cleanSourceId(id, source) {
  if (!id) return id;
  
  // Pr√©fixes courants par source
  const prefixes = {
    openlibrary: ['olib_', 'openlibrary_', 'ol_'],
    bedetheque: ['bedetheque_', 'bede_', 'bdtheque_'],
    googlebooks: ['googlebooks_', 'gbooks_', 'gb_'],
    comicvine: ['comicvine_', 'cv_'],
    jikan: ['jikan_', 'mal_', 'myanimelist_'],
    mangadex: ['mangadex_', 'mdex_', 'md_']
  };
  
  // Construire le pattern de nettoyage
  const sourcePrefixes = prefixes[source] || [];
  for (const prefix of sourcePrefixes) {
    if (id.toLowerCase().startsWith(prefix.toLowerCase())) {
      return id.substring(prefix.length);
    }
  }
  
  return id;
}

// -----------------------------
// Cr√©er une session FlareSolverr persistante
// -----------------------------
async function createFsrSession() {
  const body = {
    cmd: "sessions.create"
  };

  try {
    const res = await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const json = await res.json();
    if (json.status === "ok" && json.session) {
      console.log("Session FlareSolverr cr√©√©e:", json.session);
      return json.session;
    }
  } catch (err) {
    console.error("Erreur cr√©ation session FSR:", err.message);
  }
  return null;
}

// -----------------------------
// D√©truire une session FlareSolverr
// -----------------------------
async function destroyFsrSession(sessionId) {
  if (!sessionId) return;
  
  const body = {
    cmd: "sessions.destroy",
    session: sessionId
  };

  try {
    await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    console.log("Session FlareSolverr d√©truite:", sessionId);
    // R√©initialiser le timestamp LEGO pour forcer un rafra√Æchissement des cookies
    lastLegoHomeVisit = 0;
  } catch (err) {
    console.error("Erreur destruction session FSR:", err.message);
  }
}

// -----------------------------
// R√©soudre le challenge anti-bot Coleka
// Le site demande de cliquer sur un bouton qui fait un POST √† /verify/ajax.php
// -----------------------------
async function solveColekaChallenge(session, lang = "fr") {
  console.log("[Coleka] R√©solution du challenge anti-bot...");
  
  // Le bouton fait un POST √† /verify/ajax.php avec lang et token
  const verifyUrl = `${COLEKA_BASE_URL}/verify/ajax.php`;
  const postData = `lang=${lang}&token=${Date.now()}`;
  
  try {
    const solution = await fsrRequest("request.post", verifyUrl, session, {
      postData: postData,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "X-Requested-With": "XMLHttpRequest",
        "Referer": `${COLEKA_BASE_URL}/verify/?lang=${lang}`
      }
    }, 60000);
    
    const responseText = solution.response || "";
    console.log("[Coleka] R√©ponse verify:", responseText.substring(0, 200));
    
    // V√©rifier si la r√©ponse contient success: true
    if (responseText.includes('"success"') && responseText.includes('true')) {
      console.log("[Coleka] ‚úÖ Challenge r√©solu avec succ√®s!");
      return true;
    }
    
    // Essayer de parser la r√©ponse JSON
    try {
      const json = JSON.parse(responseText);
      if (json.success) {
        console.log("[Coleka] ‚úÖ Challenge r√©solu avec succ√®s!");
        return true;
      } else {
        console.log("[Coleka] ‚ùå Challenge √©chou√©:", json.error || "unknown");
        return false;
      }
    } catch (e) {
      console.log("[Coleka] R√©ponse non-JSON, v√©rification par contenu...");
      // Si ce n'est pas du JSON, v√©rifier si on n'a pas d'erreur
      return !responseText.includes("error") && responseText.length > 0;
    }
  } catch (err) {
    console.error("[Coleka] Erreur r√©solution challenge:", err.message);
    return false;
  }
}

// -----------------------------
// Appel FlareSolverr avec session
// -----------------------------
async function fsrRequest(cmd, url, session = null, extraOptions = {}, maxTimeout = 60000) {
  const body = {
    cmd,
    url,
    maxTimeout,
    ...extraOptions
  };

  if (session) {
    body.session = session;
  }

  const res = await fetch(FSR_BASE, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const errorText = await res.text();
    console.error("FlareSolverr HTTP error:", res.status, errorText);
    throw new Error(`FlareSolverr error ${res.status}`);
  }
  
  const json = await res.json();
  
  if (json.status !== "ok") {
    console.error("FlareSolverr status error:", json);
    throw new Error(`FlareSolverr status: ${json.status} - ${json.message || 'unknown error'}`);
  }
  
  if (!json.solution) throw new Error("FlareSolverr: pas de solution");
  
  return json.solution;
}

// -----------------------------
// R√©cup√©rer cookies et token via FSR en visitant la page de recherche
// -----------------------------
async function obtainSessionData(searchTerm, lang = DEFAULT_LOCALE) {
  // Visiter la page de recherche pour obtenir les cookies Cloudflare
  const searchUrl = `https://www.lego.com/${lang.toLowerCase()}/search?q=${encodeURIComponent(searchTerm)}`;
  const sol = await fsrRequest("request.get", searchUrl, fsrSessionId);
  
  const cookies = Array.isArray(sol.cookies) ? sol.cookies : [];
  const html = sol.response || "";
  
  // Chercher le token d'autorisation dans le HTML (souvent dans un script __NEXT_DATA__ ou similaire)
  let authorization = null;
  
  // Chercher dans les cookies
  const authCookie = cookies.find(c => c.name && (c.name.toLowerCase() === "gqauth" || c.name === "authorization"));
  if (authCookie) {
    authorization = authCookie.value;
  }
  
  // Si pas trouv√© dans cookies, chercher dans le HTML
  if (!authorization) {
    // Pattern pour trouver le token JWT dans le HTML
    const jwtPattern = /eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g;
    const matches = html.match(jwtPattern);
    if (matches && matches.length > 0) {
      // Prendre le premier token trouv√©
      authorization = matches[0];
    }
  }
  
  return { cookies, authorization, html };
}

// -----------------------------
// Construire string Cookie pour header a partir du tableau cookie FSR
// -----------------------------
function cookiesToHeader(cookieArray = []) {
  if (!Array.isArray(cookieArray) || cookieArray.length === 0) return "";
  return cookieArray.map(c => `${c.name}=${c.value}`).join("; ");
}

// -----------------------------
// Query GraphQL compl√®te (celle fournie par l'utilisateur)
// -----------------------------
const GRAPHQL_QUERY = `query SearchProductsQuery($searchSessionId: Int, $q: String!, $page: Int!, $perPage: Int!, $sort: SortInput, $filters: [Filter!], $visibility: ProductVisibility, $offset: Int) {
  searchProducts(
    searchSession: $searchSessionId
    query: $q
    page: $page
    perPage: $perPage
    filters: $filters
    sort: $sort
    visibility: $visibility
  ) {
    ... on RedirectAction {
      __typename
      url
    }
    ... on SearchProducts {
      __typename
      productResult {
        count
        total
        results {
          __typename
          id
          productCode
          name
          slug
          primaryImage(size: THUMBNAIL)
          baseImgUrl: primaryImage
          ... on SingleVariantProduct {
            variant {
              id
              sku
              salePercentage
              attributes {
                rating
                availabilityStatus
                availabilityText
                canAddToBag
                onSale
                isNew
                ageRange
                pieceCount
              }
              price {
                formattedAmount
                centAmount
                currencyCode
              }
              listPrice {
                formattedAmount
                centAmount
              }
            }
          }
        }
      }
      resultFor
    }
    __typename
  }
}`;

// -----------------------------
// Valider un ID produit LEGO
// Un ID valide est un nombre √† 4-6 chiffres (ex: 75192, 40778, 10497)
// Rejette les IDs avec param√®tres de tracking (?icmp=...), slugs invalides, etc.
// -----------------------------
function isValidLegoProductId(id) {
  if (!id) return false;
  
  // Convertir en string
  const idStr = String(id);
  
  // Rejeter si contient des caract√®res invalides (?, &, =, etc.)
  if (/[?&=]/.test(idStr)) return false;
  
  // Rejeter les slugs de type "tbdholiday-ii-40778" sans productCode num√©rique extrait
  if (idStr.includes('tbd') || idStr.includes('icmp')) return false;
  
  // Extraire le code num√©rique s'il y en a un
  const numericMatch = idStr.match(/^(\d{4,6})$/);
  if (numericMatch) return true;
  
  // Accepter aussi les slugs propres qui se terminent par un ID num√©rique
  // Ex: "millennium-falcon-75192" -> valide si on peut extraire 75192
  const slugMatch = idStr.match(/-(\d{4,6})$/);
  if (slugMatch) return true;
  
  return false;
}

// Nettoyer et extraire l'ID num√©rique d'un produit LEGO
function extractLegoProductId(id) {
  if (!id) return null;
  
  const idStr = String(id);
  
  // Si c'est d√©j√† un ID num√©rique pur
  const numericMatch = idStr.match(/^(\d{4,6})$/);
  if (numericMatch) return numericMatch[1];
  
  // Extraire l'ID num√©rique d'un slug
  const slugMatch = idStr.match(/(\d{4,6})(?:\?|$)/);
  if (slugMatch) return slugMatch[1];
  
  return null;
}

// -----------------------------
// Appel GraphQL via scraping de la page de recherche
// Les r√©sultats sont dans __NEXT_DATA__ de la page
// -----------------------------
async function callLegoGraphql(searchTerm, lang = DEFAULT_LOCALE, retries = MAX_RETRIES, perPage = 24) {
  // V√©rifier le cache
  const cacheKey = `lego:search:${searchTerm}:${lang}:${perPage}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`Tentative ${attempt}/${retries} pour recherche: "${searchTerm}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      // Visiter la page d'accueil LEGO uniquement si les cookies sont p√©rim√©s (toutes les 10 min)
      const now = Date.now();
      if (now - lastLegoHomeVisit > LEGO_SESSION_TTL) {
        console.log("Visite de la page d'accueil LEGO pour rafra√Æchir les cookies...");
        const homeSolution = await fsrRequest("request.get", `https://www.lego.com/${lang.toLowerCase()}/`, fsrSessionId, {}, 30000);
        const cookies = homeSolution.cookies || [];
        console.log(`Obtenu ${cookies.length} cookies`);
        lastLegoHomeVisit = now;
      } else {
        console.log("Cookies LEGO encore valides, skip visite page d'accueil");
      }
      
      // Essayer de faire l'appel GraphQL via FlareSolverr POST
      // L'URL avec les param√®tres query encod√©s
      const variables = {
        q: searchTerm,
        page: 1,
        perPage: Math.min(perPage, 100), // LEGO limite probablement √† 100 max
        sort: { key: "RELEVANCE", direction: "DESC" }
      };
      
      const graphqlPayload = {
        operationName: "SearchProductsQuery",
        variables: variables,
        query: GRAPHQL_QUERY
      };
      
      // Utiliser request.post de FlareSolverr
      console.log("Appel GraphQL via FlareSolverr POST...");
      
      try {
        const graphqlSolution = await fsrRequest("request.post", GRAPHQL_URL, fsrSessionId, {
          postData: JSON.stringify(graphqlPayload)
        }, 60000);
        
        // V√©rifier si on a une r√©ponse valide
        const responseText = graphqlSolution.response || "";
        
        if (responseText.includes('"data"') && responseText.includes('"searchProducts"')) {
          const graphqlResponse = JSON.parse(responseText);
          
          if (graphqlResponse.data?.searchProducts?.productResult) {
            const productResult = graphqlResponse.data.searchProducts.productResult;
            const results = productResult.results || [];
            
            // Mapper et filtrer les produits invalides
            const products = results
              .map(p => ({
                id: extractLegoProductId(p.productCode || p.id) || p.id,
                productCode: extractLegoProductId(p.productCode) || p.productCode,
                name: p.name,
                slug: p.slug,
                thumb: p.primaryImage || null,
                baseImgUrl: p.baseImgUrl || null,
                variant: p.variant || null
              }))
              .filter(p => {
                // Filtrer les produits avec IDs invalides (tracking params, tbd, etc.)
                const isValid = isValidLegoProductId(p.id) || isValidLegoProductId(p.productCode);
                if (!isValid) {
                  console.log(`[LEGO] Filtr√© produit invalide: ${p.id} (${p.name})`);
                }
                return isValid;
              });
            
            console.log(`‚úÖ GraphQL: Trouv√© ${results.length} produits, ${products.length} valides apr√®s filtrage`);
            
            const result = {
              products,
              total: products.length,
              count: products.length,
              resultFor: graphqlResponse.data.searchProducts.resultFor || searchTerm
            };
            
            // Mettre en cache le r√©sultat
            setCache(cacheKey, result);
            return result;
          }
        }
        
        console.log("R√©ponse GraphQL non valide, fallback sur scraping...");
      } catch (graphqlErr) {
        console.log("Erreur GraphQL:", graphqlErr.message, "- fallback sur scraping...");
      }
      
      // Fallback: Scraper la page de recherche
      const searchUrl = `https://www.lego.com/${lang.toLowerCase()}/search?q=${encodeURIComponent(searchTerm)}`;
      console.log("Visite de la page:", searchUrl);
      
      // waitInSeconds permet d'attendre que le JS charge les produits apr√®s le challenge
      const pageSolution = await fsrRequest("request.get", searchUrl, fsrSessionId, {
        waitInSeconds: 2  // Attendre 2 secondes pour le rendu JS des produits
      }, 60000);
      
      const html = pageSolution.response || "";
      console.log("Page re√ßue, taille:", html.length);
      
      let products = [];
      let total = 0;
      let resultFor = searchTerm;
      
      // Chercher les scripts qui contiennent des donn√©es de produits
      // Pattern: productCode, ou des liens vers /product/ ou /fr-fr/product/
      
      // Chercher les donn√©es dans __NEXT_DATA__
      const nextDataMatch = html.match(/<script\s+id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i);
      
      if (nextDataMatch) {
        try {
          const nextData = JSON.parse(nextDataMatch[1]);
          console.log("__NEXT_DATA__ pars√© avec succ√®s");
          
          // V√©rifier si les donn√©es sont dans pageProps
          const pageProps = nextData?.props?.pageProps;
          const apolloState = pageProps?.__APOLLO_STATE__ || pageProps?.initialApolloState || {};
          
          // Chercher les cl√©s qui contiennent des produits
          const allKeys = Object.keys(apolloState);
          const productKeys = allKeys.filter(k => 
            k.startsWith("SingleVariantProduct:") || 
            k.startsWith("Product:") ||
            k.startsWith("MultiVariantProduct:")
          );
          
          console.log(`Trouv√© ${productKeys.length} cl√©s de produits dans Apollo State`);
          
          if (productKeys.length > 0) {
            for (const key of productKeys) {
              const product = apolloState[key];
              if (product && product.name) {
                let variantData = product.variant;
                if (variantData?.__ref) {
                  variantData = apolloState[variantData.__ref];
                }
                
                let priceData = variantData?.price;
                if (priceData?.__ref) {
                  priceData = apolloState[priceData.__ref];
                }
                
                products.push({
                  id: product.id,
                  productCode: product.productCode,
                  name: product.name,
                  slug: product.slug,
                  image: product.primaryImage || product.baseImgUrl || null,  // Alias standard
                  thumb: product.primaryImage || product.baseImgUrl || null,
                  baseImgUrl: product.baseImgUrl || null,
                  variant: variantData ? {
                    id: variantData.id,
                    sku: variantData.sku,
                    price: priceData,
                    attributes: variantData.attributes
                  } : null
                });
              }
            }
          }
        } catch (parseErr) {
          console.error("Erreur parsing __NEXT_DATA__:", parseErr.message);
        }
      }
      
      // M√©thode 2: Si pas de produits dans __NEXT_DATA__, parser le HTML directement
      if (products.length === 0) {
        console.log("Recherche de produits dans le HTML...");
        
        // Chercher les liens produits avec pattern: /product/nom-xxxxx ou les data-test
        // Pattern typique LEGO: href="/fr-fr/product/millennium-falcon-75192"
        const productLinkPattern = /href="\/[a-z]{2}-[a-z]{2}\/product\/([^"]+)"/gi;
        const productMatches = [...html.matchAll(productLinkPattern)];
        
        // Chercher les images des produits - plusieurs formats possibles
        const imgPatterns = [
          /src="(https:\/\/[^"]*(?:lego|brickset)[^"]*\/(?:products|images|set\/assets)[^"]*\.(jpg|png|webp)[^"]*)"/gi,
          /srcset="([^"]*lego[^"]*)/gi,
          /data-src="(https:\/\/[^"]*lego[^"]*\.(jpg|png|webp)[^"]*)"/gi
        ];
        
        // Trouver tous les src d'images
        const allImages = [];
        for (const pattern of imgPatterns) {
          const matches = [...html.matchAll(pattern)];
          for (const m of matches) {
            // D√©coder les entit√©s HTML (&amp; -> &)
            const cleanUrl = m[1].replace(/&amp;/g, '&');
            allImages.push(cleanUrl);
          }
        }
        
        // Cr√©er une map des images par code produit
        const productImages = new Map();
        for (const imgUrl of allImages) {
          // Nettoyer l'URL : garder seulement jusqu'√† l'extension
          const cleanedUrl = imgUrl.replace(/\?(.*?)$/, '');
          
          const codePatterns = [
            /\/(\d{5,6})(?:\/|_|\.|$)/,
            /_(\d{5,6})(?:_|\.|$)/,
            /-(\d{5,6})(?:-|\.|$)/
          ];
          
          for (const cp of codePatterns) {
            const match = cleanedUrl.match(cp);
            if (match && !productImages.has(match[1])) {
              productImages.set(match[1], cleanedUrl);
              break;
            }
          }
        }
        
        // Chercher les noms de produits localis√©s dans le HTML
        // Le nom est dans l'attribut aria-label du lien produit
        const productNames = new Map();
        
        // Pattern: aria-label="Nom du produit" href="/fr-fr/product/slug-xxxxx"
        const ariaLabelPattern = /aria-label="([^"]+)"[^>]*href="\/[a-z]{2}-[a-z]{2}\/product\/([^"]+)"/gi;
        for (const match of html.matchAll(ariaLabelPattern)) {
          const name = match[1].trim();
          const slug = match[2];
          if (slug && name && !productNames.has(slug)) {
            productNames.set(slug, name);
          }
        }
        
        // Pattern alternatif: href avant aria-label
        const ariaLabelPattern2 = /href="\/[a-z]{2}-[a-z]{2}\/product\/([^"]+)"[^>]*aria-label="([^"]+)"/gi;
        for (const match of html.matchAll(ariaLabelPattern2)) {
          const slug = match[1];
          const name = match[2].trim();
          if (slug && name && !productNames.has(slug)) {
            productNames.set(slug, name);
          }
        }
        
        // Pattern pour data-test="product-leaf-title-link" avec aria-label
        const titleLinkPattern = /data-test="product-leaf-title-link"[^>]*aria-label="([^"]+)"[^>]*href="[^"]*\/product\/([^"]+)"/gi;
        for (const match of html.matchAll(titleLinkPattern)) {
          const name = match[1].trim();
          const slug = match[2];
          if (slug && name && !productNames.has(slug)) {
            productNames.set(slug, name);
          }
        }
        
        console.log(`Noms de produits trouv√©s: ${productNames.size}`);
        
        const seenSlugs = new Set();
        for (const match of productMatches) {
          const slug = match[1];
          
          // Ignorer les produits fictifs/publicitaires
          if (slug.includes('mosaic-maker') || slug.includes('mosaic_maker')) {
            continue;
          }
          
          // Ignorer les URLs avec param√®tres de tracking
          if (slug.includes('?') || slug.includes('icmp') || slug.includes('tbd')) {
            console.log(`[LEGO] Filtr√© slug invalide: ${slug}`);
            continue;
          }
          
          if (!seenSlugs.has(slug)) {
            seenSlugs.add(slug);
            // Extraire le code produit du slug (g√©n√©ralement les derniers chiffres)
            const codeMatch = slug.match(/(\d{4,6})(?:\?|$)/);
            const productCode = codeMatch ? codeMatch[1] : null;
            
            // Ne pas ajouter si on ne peut pas extraire un ID valide
            if (!productCode || !isValidLegoProductId(productCode)) {
              console.log(`[LEGO] Filtr√© produit sans ID valide: ${slug}`);
              continue;
            }
            
            // Chercher l'image correspondante
            const thumb = productCode ? productImages.get(productCode) : null;
            
            // Chercher le nom localis√©, sinon utiliser le slug
            const localizedName = productNames.get(slug);
            const name = localizedName || slug.replace(/-/g, ' ').replace(/\d+$/, '').trim();
            
            products.push({
              id: productCode,
              productCode: productCode,
              name: name,
              slug: slug,
              image: thumb,       // Alias standard
              thumb: thumb,
              baseImgUrl: thumb,
              variant: null
            });
          }
        }
        
        console.log(`Trouv√© ${products.length} liens produits dans le HTML (${productImages.size} images)`);
      }
      
      // M√©thode 3: Chercher les balises article ou div avec data-test="product-leaf"
      if (products.length === 0) {
        console.log("Recherche via data-test attributes...");
        
        // Pattern pour les cartes produits LEGO
        const productCardPattern = /data-test="product-leaf"[^>]*>[\s\S]*?<\/article>/gi;
        const cardMatches = html.match(productCardPattern) || [];
        
        for (const card of cardMatches) {
          // Extraire le nom du produit
          const nameMatch = card.match(/data-test="product-leaf-title"[^>]*>([^<]+)/i);
          // Extraire le prix
          const priceMatch = card.match(/data-test="product-price"[^>]*>([^<]+)/i);
          // Extraire l'image
          const imgMatch = card.match(/src="([^"]+lego\.com[^"]+)"/i);
          // Extraire le lien
          const linkMatch = card.match(/href="\/[^"]*\/product\/([^"]+)"/i);
          
          if (nameMatch || linkMatch) {
            const slug = linkMatch ? linkMatch[1] : null;
            const codeMatch = slug ? slug.match(/(\d{4,6})(?:\?|$)/) : null;
            const productId = codeMatch ? codeMatch[1] : null;
            
            // Ne pas ajouter si l'ID n'est pas valide
            if (!productId || !isValidLegoProductId(productId)) {
              console.log(`[LEGO] Filtr√© carte produit invalide: ${slug}`);
              continue;
            }
            
            products.push({
              id: productId,
              productCode: productId,
              name: nameMatch ? nameMatch[1].trim() : slug?.replace(/-/g, ' ') || 'Unknown',
              slug: slug,
              image: imgMatch ? imgMatch[1] : null,  // Alias standard
              thumb: imgMatch ? imgMatch[1] : null,
              price: priceMatch ? priceMatch[1].trim() : null,
              variant: null
            });
          }
        }
        
        console.log(`Trouv√© ${products.length} cartes produits valides`);
      }
      
      // Filtrage final pour s'assurer que tous les produits ont des IDs valides
      const validProducts = products.filter(p => {
        const isValid = isValidLegoProductId(p.id) || isValidLegoProductId(p.productCode);
        if (!isValid) {
          console.log(`[LEGO] Filtr√© produit final invalide: ${p.id} (${p.name})`);
        }
        return isValid;
      });
      
      total = validProducts.length;
      console.log(`‚úÖ Trouv√© ${validProducts.length} produits valides (${products.length - validProducts.length} filtr√©s)`);
      
      const result = { 
        products: validProducts, 
        total,
        count: validProducts.length,
        resultFor,
        htmlSize: html.length
      };
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, result);
      return result;

    } catch (err) {
      lastError = err;
      console.warn(`Erreur tentative ${attempt}: ${err.message}`);
      
      // D√©truire la session en cas d'erreur pour repartir proprement
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      // backoff exponentiel
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// R√©cup√©rer les d√©tails complets d'un produit par son ID
// -----------------------------
async function getProductDetails(productId, lang = DEFAULT_LOCALE, retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `lego:product:${productId}:${lang}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`Tentative ${attempt}/${retries} pour produit: "${productId}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      // Rafra√Æchir les cookies LEGO si p√©rim√©s
      const now = Date.now();
      if (now - lastLegoHomeVisit > LEGO_SESSION_TTL) {
        console.log("Rafra√Æchissement cookies LEGO...");
        await fsrRequest("request.get", `https://www.lego.com/${lang.toLowerCase()}/`, fsrSessionId, {}, 30000);
        lastLegoHomeVisit = now;
      }
      
      // Construire l'URL du produit
      // LEGO utilise le format: /fr-fr/product/slug-XXXXX ou juste /fr-fr/product/XXXXX
      const productUrl = `https://www.lego.com/${lang.toLowerCase()}/product/${productId}`;
      console.log("Visite de la page produit:", productUrl);
      
      // Attendre le rendu JavaScript
      const pageSolution = await fsrRequest("request.get", productUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      const html = pageSolution.response || "";
      console.log("Page produit re√ßue, taille:", html.length);
      
      // V√©rifier si le produit existe - chercher des √©l√©ments sp√©cifiques de la page produit
      // plut√¥t que de chercher "404" qui peut appara√Ætre ailleurs
      const isProductPage = html.includes('product-overview') || 
                            html.includes('ProductOverview') ||
                            html.includes('data-test="product-') ||
                            html.includes('/product/' + productId);
      
      if (!isProductPage && (html.includes("Cette page n'existe pas") || html.length < 100000)) {
        throw new Error("Produit non trouv√©");
      }
      
      // Extraire les informations du produit
      const product = {
        id: productId,
        productCode: productId,
        name: null,
        description: null,
        images: [],
        videos: [],
        ageRange: null,
        pieceCount: null,
        minifiguresCount: null,
        price: null,
        listPrice: null,
        availability: null,
        availabilityText: null,
        rating: null,
        reviewCount: null,
        themes: [],
        url: productUrl
      };
      
      // --- Extraction du nom ---
      // Pattern 1: balise h1 avec data-test="product-overview-name"
      const namePatterns = [
        /<h1[^>]*data-test="product-overview-name"[^>]*>([^<]+)<\/h1>/i,
        /<h1[^>]*class="[^"]*ProductOverviewstyles[^"]*"[^>]*>([^<]+)<\/h1>/i,
        /<span[^>]*data-test="product-overview-name"[^>]*>([^<]+)<\/span>/i,
        /<h1[^>]*>([^<]+)<\/h1>/i
      ];
      
      for (const pattern of namePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.name = match[1].trim();
          break;
        }
      }
      
      // --- Extraction de la description ---
      const descPatterns = [
        /<p[^>]*data-test="product-overview-description"[^>]*>([\s\S]*?)<\/p>/i,
        /<div[^>]*class="[^"]*ProductDescription[^"]*"[^>]*>([\s\S]*?)<\/div>/i
      ];
      
      for (const pattern of descPatterns) {
        const match = html.match(pattern);
        if (match) {
          // Nettoyer le HTML de la description
          product.description = match[1].replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
          break;
        }
      }
      
      // --- Extraction des images (haute r√©solution, uniques) ---
      // Chercher toutes les images du produit
      const imagePatterns = [
        /src="(https:\/\/[^"]*(?:lego\.com|cloudfront)[^"]*\/(?:products|set\/assets)[^"]*\.(jpg|png|webp)[^"]*)"/gi,
        /srcset="([^"]+)"/gi,
        /data-src="(https:\/\/[^"]*lego[^"]*\.(jpg|png|webp)[^"]*)"/gi
      ];
      
      // On utilise un Set bas√© sur le nom de base de l'image (sans param√®tres)
      const seenImageBases = new Set();
      
      for (const pattern of imagePatterns) {
        const matches = [...html.matchAll(pattern)];
        for (const m of matches) {
          let imgUrl = m[1].replace(/&amp;/g, '&');
          
          // Pour srcset, prendre chaque URL
          const urlsToProcess = [];
          if (imgUrl.includes(',')) {
            const srcsetParts = imgUrl.split(',').map(s => s.trim());
            for (const part of srcsetParts) {
              urlsToProcess.push(part.split(' ')[0]);
            }
          } else {
            urlsToProcess.push(imgUrl);
          }
          
          for (const url of urlsToProcess) {
            // Nettoyer l'URL : garder seulement jusqu'√† l'extension
            const cleanUrl = url.replace(/\?(.*?)$/, '');
            
            // Extraire le nom du fichier
            const fileNameMatch = cleanUrl.match(/\/([^\/]+\.(jpg|png|webp))$/i);
            if (!fileNameMatch) continue;
            
            const fileName = fileNameMatch[1];
            const baseName = fileName.toLowerCase();
            
            // Filtrer : garder seulement les images qui contiennent l'ID du produit dans le nom
            // Ex: 75192_Prod.png, 75192_alt1.jpg, 75192_minifig_lineup.png
            // Exclure : thumbnail, logo, promo, autres produits
            const isProductImage = fileName.includes(productId) && 
                                   !baseName.includes('thumbnail') &&
                                   !baseName.includes('logo');
            
            if (isProductImage && !seenImageBases.has(baseName)) {
              seenImageBases.add(baseName);
              product.images.push(cleanUrl);
            }
          }
        }
      }
      
      // --- Extraction des vid√©os ---
      const videoPatterns = [
        /src="(https:\/\/[^"]*(?:youtube|vimeo|lego)[^"]*(?:embed|video)[^"]*)"/gi,
        /data-video-id="([^"]+)"/gi,
        /"videoId"\s*:\s*"([^"]+)"/gi,
        /youtube\.com\/embed\/([^"?\s]+)/gi
      ];
      
      const seenVideos = new Set();
      
      for (const pattern of videoPatterns) {
        const matches = [...html.matchAll(pattern)];
        for (const m of matches) {
          let videoUrl = m[1];
          
          // Si c'est un ID YouTube, construire l'URL
          if (videoUrl.match(/^[a-zA-Z0-9_-]{11}$/)) {
            videoUrl = `https://www.youtube.com/watch?v=${videoUrl}`;
          }
          
          if (!seenVideos.has(videoUrl)) {
            seenVideos.add(videoUrl);
            product.videos.push(videoUrl);
          }
        }
      }
      
      // --- Extraction de l'√¢ge recommand√© ---
      const agePatterns = [
        /data-test="product-details-ages"[^>]*>([^<]+)</i,
        /"ageRange"\s*:\s*"([^"]+)"/i,
        /√Çge[s]?\s*:?\s*(\d+\+?)/i,
        /Age[s]?\s*:?\s*(\d+\+?)/i,
        /<span[^>]*>(\d+\+)<\/span>/i
      ];
      
      for (const pattern of agePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.ageRange = match[1].trim();
          break;
        }
      }
      
      // --- Extraction du nombre de pi√®ces ---
      const piecePatterns = [
        /data-test="product-details-pieces"[^>]*>([^<]+)</i,
        /"pieceCount"\s*:\s*(\d+)/i,
        /(\d+)\s*(?:pi√®ces?|pieces?|√©l√©ments?)/i,
        /Pi√®ces?\s*:?\s*(\d[\d\s]*)/i,
        /Pieces?\s*:?\s*(\d[\d\s]*)/i
      ];
      
      for (const pattern of piecePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.pieceCount = parseInt(match[1].replace(/\s/g, ''), 10);
          break;
        }
      }
      
      // --- Extraction du nombre de figurines ---
      const minifigPatterns = [
        /data-test="product-details-minifigures"[^>]*>([^<]+)</i,
        /"minifiguresCount"\s*:\s*(\d+)/i,
        /(\d+)\s*(?:figurines?|minifig(?:ure)?s?)/i,
        /Minifigurines?\s*:?\s*(\d+)/i
      ];
      
      for (const pattern of minifigPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.minifiguresCount = parseInt(match[1], 10);
          break;
        }
      }
      
      // --- Extraction du prix ---
      const pricePatterns = [
        /data-test="product-price"[^>]*>([^<]+)</i,
        /data-test="product-price-sale"[^>]*>([^<]+)</i,
        /"formattedAmount"\s*:\s*"([^"]+)"/i,
        /"centAmount"\s*:\s*(\d+)/i,
        /Prix\s*:?\s*([\d,.\s]+\s*‚Ç¨)/i,
        /([\d,.\s]+\s*‚Ç¨)/i
      ];
      
      for (const pattern of pricePatterns) {
        const match = html.match(pattern);
        if (match) {
          // Nettoyer les entit√©s HTML
          product.price = match[1].trim().replace(/&nbsp;/g, ' ').replace(/&#160;/g, ' ');
          break;
        }
      }
      
      // Prix original (si en promo)
      const listPricePatterns = [
        /data-test="product-price-list"[^>]*>([^<]+)</i,
        /<s[^>]*>([^<]*‚Ç¨[^<]*)<\/s>/i
      ];
      
      for (const pattern of listPricePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.listPrice = match[1].trim();
          break;
        }
      }
      
      // --- Extraction de la disponibilit√© ---
      const availabilityPatterns = [
        /data-test="product-overview-availability"[^>]*>([^<]+)</i,
        /"availabilityStatus"\s*:\s*"([^"]+)"/i,
        /"availabilityText"\s*:\s*"([^"]+)"/i,
        /Disponibilit√©\s*:?\s*([^<]+)</i,
        /Availability\s*:?\s*([^<]+)</i
      ];
      
      for (const pattern of availabilityPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.availabilityText = match[1].trim();
          // D√©duire le statut
          const text = product.availabilityText.toLowerCase();
          if (text.includes('disponible') || text.includes('available') || text.includes('en stock')) {
            product.availability = 'AVAILABLE';
          } else if (text.includes('√©puis√©') || text.includes('out of stock') || text.includes('indisponible')) {
            product.availability = 'OUT_OF_STOCK';
          } else if (text.includes('bient√¥t') || text.includes('coming soon') || text.includes('prochainement')) {
            product.availability = 'COMING_SOON';
          } else if (text.includes('retir√©') || text.includes('retired') || text.includes('fin de s√©rie')) {
            product.availability = 'RETIRED';
          } else {
            product.availability = 'UNKNOWN';
          }
          break;
        }
      }
      
      // --- Extraction de la note et nombre d'avis ---
      const ratingPatterns = [
        /data-test="product-rating"[^>]*>([^<]+)</i,
        /"rating"\s*:\s*([\d.]+)/i,
        /(\d+(?:[.,]\d+)?)\s*(?:\/\s*5|sur\s*5|√©toiles?|stars?)/i
      ];
      
      for (const pattern of ratingPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.rating = parseFloat(match[1].replace(',', '.'));
          break;
        }
      }
      
      const reviewPatterns = [
        /data-test="product-review-count"[^>]*>([^<]+)</i,
        /"reviewCount"\s*:\s*(\d+)/i,
        /(\d+)\s*(?:avis|reviews?|√©valuations?)/i
      ];
      
      for (const pattern of reviewPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.reviewCount = parseInt(match[1], 10);
          break;
        }
      }
      
      // --- Essayer d'extraire depuis __NEXT_DATA__ pour des donn√©es plus structur√©es ---
      const nextDataMatch = html.match(/<script\s+id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i);
      
      if (nextDataMatch) {
        try {
          const nextData = JSON.parse(nextDataMatch[1]);
          const pageProps = nextData?.props?.pageProps;
          const apolloState = pageProps?.__APOLLO_STATE__ || pageProps?.initialApolloState || {};
          
          // Chercher les donn√©es du produit dans Apollo State
          for (const key of Object.keys(apolloState)) {
            if (key.startsWith("SingleVariantProduct:") || key.startsWith("Product:") || key.startsWith("MultiVariantProduct:")) {
              const prodData = apolloState[key];
              
              if (prodData && (prodData.productCode === productId || key.includes(productId))) {
                // Nom
                if (prodData.name && !product.name) {
                  product.name = prodData.name;
                }
                
                // R√©soudre les r√©f√©rences
                if (prodData.variant?.__ref) {
                  const variantData = apolloState[prodData.variant.__ref];
                  if (variantData) {
                    // Attributs
                    if (variantData.attributes) {
                      const attrs = variantData.attributes;
                      if (attrs.rating && !product.rating) product.rating = attrs.rating;
                      if (attrs.availabilityStatus && !product.availability) product.availability = attrs.availabilityStatus;
                      if (attrs.availabilityText && !product.availabilityText) product.availabilityText = attrs.availabilityText;
                      if (attrs.ageRange && !product.ageRange) product.ageRange = attrs.ageRange;
                      if (attrs.pieceCount && !product.pieceCount) product.pieceCount = attrs.pieceCount;
                    }
                    
                    // Prix
                    if (variantData.price?.__ref) {
                      const priceData = apolloState[variantData.price.__ref];
                      if (priceData?.formattedAmount && !product.price) {
                        product.price = priceData.formattedAmount;
                      }
                    } else if (variantData.price?.formattedAmount && !product.price) {
                      product.price = variantData.price.formattedAmount;
                    }
                  }
                }
                
                break;
              }
            }
          }
        } catch (parseErr) {
          console.warn("Erreur parsing __NEXT_DATA__ pour produit:", parseErr.message);
        }
      }
      
      console.log(`‚úÖ Produit r√©cup√©r√©: ${product.name || productId}`);
      console.log(`   Images: ${product.images.length}, Vid√©os: ${product.videos.length}`);
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, product);
      return product;

    } catch (err) {
      lastError = err;
      console.warn(`Erreur tentative ${attempt}: ${err.message}`);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// R√©cup√©rer les manuels d'instructions d'un produit par son ID
// -----------------------------
async function getBuildingInstructions(productId, lang = DEFAULT_LOCALE, retries = MAX_RETRIES) {
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`Tentative ${attempt}/${retries} pour instructions: "${productId}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      // Rafra√Æchir les cookies LEGO si p√©rim√©s
      const now = Date.now();
      if (now - lastLegoHomeVisit > LEGO_SESSION_TTL) {
        console.log("Rafra√Æchissement cookies LEGO...");
        await fsrRequest("request.get", `https://www.lego.com/${lang.toLowerCase()}/`, fsrSessionId, {}, 30000);
        lastLegoHomeVisit = now;
      }
      
      // Construire l'URL des instructions
      const instructionsUrl = `https://www.lego.com/${lang.toLowerCase()}/service/building-instructions/${productId}`;
      console.log("Visite de la page instructions:", instructionsUrl);
      
      // Attendre le rendu JavaScript
      const pageSolution = await fsrRequest("request.get", instructionsUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      const html = pageSolution.response || "";
      console.log("Page instructions re√ßue, taille:", html.length);
      
      // V√©rifier si la page existe
      const isInstructionsPage = html.includes('building-instructions') || 
                                  html.includes('BuildingInstructions') ||
                                  html.includes('.pdf');
      
      if (!isInstructionsPage && (html.includes("Cette page n'existe pas") || html.length < 50000)) {
        throw new Error("Instructions non trouv√©es pour ce produit");
      }
      
      // Structure de retour
      const instructions = {
        id: productId,
        productCode: productId,
        name: null,
        ageRange: null,
        pieceCount: null,
        year: null,
        manuals: [],
        url: instructionsUrl
      };
      
      // --- Chercher dans __NEXT_DATA__ ---
      const nextDataMatch = html.match(/<script\s+id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i);
      
      if (nextDataMatch) {
        try {
          const nextData = JSON.parse(nextDataMatch[1]);
          const pageProps = nextData?.props?.pageProps;
          
          // Chercher les donn√©es du produit
          const productData = pageProps?.product || pageProps?.data?.product;
          
          if (productData) {
            // Nom du produit
            if (productData.name) {
              instructions.name = productData.name;
            }
            
            // √Çge
            if (productData.ageRange) {
              instructions.ageRange = productData.ageRange;
            }
            
            // Nombre de pi√®ces
            if (productData.pieceCount) {
              instructions.pieceCount = parseInt(productData.pieceCount, 10);
            }
          }
          
          // Chercher les instructions de montage
          const buildingInstructions = pageProps?.buildingInstructions || 
                                       pageProps?.data?.buildingInstructions ||
                                       pageProps?.instructions ||
                                       pageProps?.data?.instructions;
          
          if (Array.isArray(buildingInstructions)) {
            for (const instr of buildingInstructions) {
              if (instr.pdfUrl || instr.pdfLocation || instr.url) {
                instructions.manuals.push({
                  id: instr.id || null,
                  description: instr.description || instr.name || null,
                  pdfUrl: instr.pdfUrl || instr.pdfLocation || instr.url,
                  sequence: instr.sequence || instr.sequenceNumber || null
                });
              }
            }
          }
          
          // Chercher aussi dans Apollo State
          const apolloState = pageProps?.__APOLLO_STATE__ || pageProps?.initialApolloState || {};
          
          for (const key of Object.keys(apolloState)) {
            const data = apolloState[key];
            
            // Chercher les donn√©es produit
            if (key.startsWith("Product:") || key.startsWith("SingleVariantProduct:") || key.includes(productId)) {
              if (data.name && !instructions.name) {
                instructions.name = data.name;
              }
              if (data.ageRange && !instructions.ageRange) {
                instructions.ageRange = data.ageRange;
              }
              if (data.pieceCount && !instructions.pieceCount) {
                instructions.pieceCount = parseInt(data.pieceCount, 10);
              }
              
              // Chercher dans les attributs du variant
              if (data.variant?.__ref) {
                const variantData = apolloState[data.variant.__ref];
                if (variantData?.attributes) {
                  const attrs = variantData.attributes;
                  if (attrs.ageRange && !instructions.ageRange) {
                    instructions.ageRange = attrs.ageRange;
                  }
                  if (attrs.pieceCount && !instructions.pieceCount) {
                    instructions.pieceCount = parseInt(attrs.pieceCount, 10);
                  }
                }
              }
            }
            
            // Chercher dans ProductAttributes directement
            if (key.includes("ProductAttributes") || key.includes("VariantAttributes")) {
              if (data.ageRange && !instructions.ageRange) {
                instructions.ageRange = data.ageRange;
              }
              if (data.pieceCount && !instructions.pieceCount) {
                instructions.pieceCount = parseInt(data.pieceCount, 10);
              }
            }
            
            // Chercher les instructions
            if (key.includes("BuildingInstruction") || (data && data.pdfLocation)) {
              if (data.pdfLocation && !instructions.manuals.find(m => m.pdfUrl === data.pdfLocation)) {
                instructions.manuals.push({
                  id: data.id || key,
                  description: data.description || data.name || null,
                  pdfUrl: data.pdfLocation,
                  sequence: data.sequence || data.sequenceNumber || null
                });
              }
            }
          }
          
        } catch (parseErr) {
          console.error("Erreur parsing __NEXT_DATA__:", parseErr.message);
        }
      }
      
      // --- Extraction depuis le HTML si pas trouv√© dans __NEXT_DATA__ ---
      
      // Nom du produit
      if (!instructions.name) {
        const namePatterns = [
          /<h1[^>]*>([^<]+)<\/h1>/i,
          /data-test="[^"]*product[^"]*name[^"]*"[^>]*>([^<]+)</i,
          /"name"\s*:\s*"([^"]+)"/i
        ];
        
        for (const pattern of namePatterns) {
          const match = html.match(pattern);
          if (match && !match[1].includes('LEGO')) {
            instructions.name = match[1].trim();
            break;
          }
        }
      }
      
      // √Çge - chercher d'abord dans les donn√©es structur√©es
      if (!instructions.ageRange) {
        const agePatterns = [
          /"ageRange"\s*:\s*"([^"]+)"/i,
          // Pattern pour: <p class="...productDetails...">18+<!-- --> <span...
          /<p[^>]*productDetails[^>]*>(\d{1,2}\+)/i,
          // Pattern pour: class="_setId__productDetails...">18+
          /class="[^"]*productDetails[^"]*">(\d{1,2}\+)/i,
          /data-test="[^"]*age[^"]*"[^>]*>(\d{1,2}\+)/i,
          /√Çge[s]?\s*:?\s*(\d{1,2}\+)/i,
          /Ages?\s*:?\s*(\d{1,2}\+)/i
        ];
        
        for (const pattern of agePatterns) {
          const match = html.match(pattern);
          if (match) {
            instructions.ageRange = match[1];
            break;
          }
        }
      }
      
      // Nombre de pi√®ces
      if (!instructions.pieceCount) {
        const piecePatterns = [
          /"pieceCount"\s*:\s*(\d+)/i,
          /(\d+)\s*(?:pi√®ces?|pieces?|√©l√©ments?)/i
        ];
        
        for (const pattern of piecePatterns) {
          const match = html.match(pattern);
          if (match) {
            instructions.pieceCount = parseInt(match[1], 10);
            break;
          }
        }
      }
      
      // Ann√©e de sortie
      if (!instructions.year) {
        const yearPatterns = [
          /"launchDate"\s*:\s*"(\d{4})/i,
          /"year"\s*:\s*(\d{4})/i,
          // Pattern pour: <p class="...productDetails...">Ann√©e : 2024</p>
          /<p[^>]*productDetails[^>]*>Ann√©e\s*:\s*(\d{4})/i,
          /class="[^"]*productDetails[^"]*">Ann√©e\s*:\s*(\d{4})/i,
          /Year\s*:\s*(\d{4})/i
        ];
        
        for (const pattern of yearPatterns) {
          const match = html.match(pattern);
          if (match) {
            instructions.year = parseInt(match[1], 10);
            break;
          }
        }
      }
      
      // Chercher les liens PDF directement dans le HTML
      if (instructions.manuals.length === 0) {
        // Pattern pour les URLs de PDF
        const pdfPatterns = [
          /href="(https?:\/\/[^"]+\.pdf)"/gi,
          /src="(https?:\/\/[^"]+\.pdf)"/gi,
          /"pdfUrl"\s*:\s*"([^"]+\.pdf)"/gi,
          /"pdfLocation"\s*:\s*"([^"]+\.pdf)"/gi,
          /"url"\s*:\s*"(https?:\/\/[^"]+\.pdf)"/gi,
          /(https?:\/\/[^"\s]+\.pdf)/gi
        ];
        
        const seenPdfs = new Set();
        
        for (const pattern of pdfPatterns) {
          const matches = [...html.matchAll(pattern)];
          for (const m of matches) {
            let pdfUrl = m[1].replace(/\\u002F/g, '/').replace(/\\/g, '');
            
            // Nettoyer l'URL
            if (pdfUrl.startsWith('//')) {
              pdfUrl = 'https:' + pdfUrl;
            }
            
            if (!seenPdfs.has(pdfUrl)) {
              seenPdfs.add(pdfUrl);
              
              // Extraire une description du nom du fichier
              const fileNameMatch = pdfUrl.match(/\/([^\/]+)\.pdf$/i);
              const fileName = fileNameMatch ? fileNameMatch[1] : null;
              
              // Filtrer les PDFs qui ne sont pas des manuels d'instructions
              // Exclure : documents l√©gaux, rapports, policies, etc.
              const excludePatterns = [
                /slavery/i, /transparency/i, /statement/i, /policy/i,
                /report/i, /annual/i, /legal/i, /terms/i, /privacy/i,
                /cookie/i, /compliance/i, /corporate/i
              ];
              
              const isExcluded = excludePatterns.some(pattern => pattern.test(fileName || pdfUrl));
              
              // V√©rifier que c'est bien un manuel (contient product.bi ou l'ID produit ou est num√©rique)
              const isManual = pdfUrl.includes('product.bi') || 
                               pdfUrl.includes(productId) || 
                               /^\d+$/.test(fileName);
              
              if (!isExcluded && isManual) {
                // Extraire le num√©ro de s√©quence du nom de fichier si possible
                // Ex: 6481239.pdf, 10333_1.pdf, 10333_BK1.pdf, 10333_BK2.pdf
                let sequence = null;
                const seqMatch = fileName?.match(/_(?:BK)?(\d+)(?:_|$)/i);
                if (seqMatch) {
                  sequence = parseInt(seqMatch[1], 10);
                }
                
                instructions.manuals.push({
                  id: fileName || seenPdfs.size.toString(),
                  description: fileName ? `Manuel ${fileName}` : null,
                  pdfUrl: pdfUrl,
                  sequence: sequence
                });
              }
            }
          }
        }
      }
      
      // Trier les manuels par s√©quence
      instructions.manuals.sort((a, b) => {
        if (a.sequence === null && b.sequence === null) return 0;
        if (a.sequence === null) return 1;
        if (b.sequence === null) return -1;
        return a.sequence - b.sequence;
      });
      
      console.log(`‚úÖ Trouv√© ${instructions.manuals.length} manuels pour ${productId}`);
      
      return instructions;

    } catch (err) {
      lastError = err;
      console.warn(`Erreur tentative ${attempt}: ${err.message}`);
      
      // D√©truire la session en cas d'erreur pour repartir proprement
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      // backoff exponentiel
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// Recherche sur Coleka via scraping
// -----------------------------
async function searchColeka(searchTerm, nbpp = COLEKA_DEFAULT_NBPP, lang = "fr", retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `coleka:search:${searchTerm}:${nbpp}:${lang}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[Coleka] Tentative ${attempt}/${retries} pour recherche: "${searchTerm}"`);
      
      // Cr√©er une nouvelle session FSR pour chaque tentative (plus fiable pour Coleka)
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      fsrSessionId = await createFsrSession();
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      // √âtape 1: Visiter la page d'accueil pour d√©clencher le challenge
      console.log("[Coleka] √âtape 1: Visite de la page d'accueil...");
      const homeUrl = `${COLEKA_BASE_URL}/${lang}`;
      
      const homeSolution = await fsrRequest("request.get", homeUrl, fsrSessionId, {
        waitInSeconds: 1  // R√©duit de 2s √† 1s
      }, 90000);  // Timeout r√©duit
      
      const homeHtml = homeSolution.response || "";
      console.log("[Coleka] Page d'accueil re√ßue, taille:", homeHtml.length);
      
      // V√©rifier si on a le challenge
      if (homeHtml.includes("Simple v√©rification") || homeHtml.includes("Visiter COLEKA") || homeHtml.includes("verifyBtn")) {
        console.log("[Coleka] √âtape 2: Challenge d√©tect√©, r√©solution via POST /verify/ajax.php...");
        
        // R√©soudre le challenge en simulant le clic sur le bouton
        const challengeSolved = await solveColekaChallenge(fsrSessionId, lang);
        
        if (!challengeSolved) {
          console.log("[Coleka] ‚ùå √âchec de la r√©solution du challenge");
          throw new Error("Protection anti-bot non contourn√©e");
        }
        
        // Attendre un peu apr√®s la r√©solution
        await new Promise(r => setTimeout(r, 500));  // R√©duit de 1s √† 500ms
      }
      
      // √âtape 3: Maintenant visiter la page de recherche
      const searchUrl = `${COLEKA_BASE_URL}/${lang}/search?q=${encodeURIComponent(searchTerm)}&nbpp=${nbpp}`;
      console.log("[Coleka] √âtape 3: Visite de la page de recherche:", searchUrl);
      
      const pageSolution = await fsrRequest("request.get", searchUrl, fsrSessionId, {
        waitInSeconds: 3
      }, 120000);
      
      const html = pageSolution.response || "";
      console.log("[Coleka] Page de recherche re√ßue, taille:", html.length);
      
      // V√©rifier si on a pass√© la protection
      if (html.includes("Simple v√©rification") || html.includes("Visiter COLEKA")) {
        console.log("[Coleka] Protection anti-bot d√©tect√©e sur page de recherche");
        throw new Error("Protection anti-bot non contourn√©e");
      }
      
      // Structure de retour
      const result = {
        query: searchTerm,
        products: [],
        total: 0,
        source: "coleka"
      };
      
      // Parser les r√©sultats de recherche
      // Coleka utilise des cartes produits avec diff√©rentes structures possibles
      
      // Pattern 1: Chercher les liens produits avec leurs donn√©es
      // Format typique: <a href="/fr/collection/theme/item-name" class="...">
      const productPatterns = [
        // Pattern pour les cartes produits avec liens
        /<a[^>]*href="(\/[a-z]{2}\/[^"]+)"[^>]*class="[^"]*(?:card|product|item)[^"]*"[^>]*>([\s\S]*?)<\/a>/gi,
        // Pattern pour les articles produits
        /<article[^>]*class="[^"]*(?:card|product|item)[^"]*"[^>]*>([\s\S]*?)<\/article>/gi,
        // Pattern pour les divs produits
        /<div[^>]*class="[^"]*(?:card-body|product-card|item-card)[^"]*"[^>]*>([\s\S]*?)<\/div>/gi
      ];
      
      // Chercher tous les liens vers des pages de collection/produits
      const linkPattern = /<a[^>]*href="(\/[a-z]{2}\/[^"]*\/[^"]+)"[^>]*>([\s\S]*?)<\/a>/gi;
      const allLinks = [...html.matchAll(linkPattern)];
      
      // Map pour √©viter les doublons
      const seenUrls = new Set();
      const productData = [];
      
      for (const match of allLinks) {
        const url = match[1];
        const content = match[2];
        
        // Filtrer: garder seulement les liens vers des items de collection
        // Exclure: /search, /user, /market, les cat√©gories g√©n√©rales
        if (url.includes('/search') || 
            url.includes('/user') || 
            url.includes('/market') ||
            url.includes('/verify') ||
            url.includes('#') ||
            url.match(/^\/[a-z]{2}\/?$/) ||
            url.match(/^\/[a-z]{2}\/[^\/]+\/?$/)) {
          continue;
        }
        
        // V√©rifier que c'est un lien vers un item (au moins 3 segments: /lang/category/item)
        const segments = url.split('/').filter(s => s.length > 0);
        if (segments.length < 3) continue;
        
        const fullUrl = COLEKA_BASE_URL + url;
        
        if (!seenUrls.has(fullUrl)) {
          seenUrls.add(fullUrl);
          productData.push({
            url: fullUrl,
            path: url,
            content: content
          });
        }
      }
      
      // Chercher les images associ√©es aux produits
      const imageMap = new Map();
      const imagePattern = /<img[^>]*src="([^"]+)"[^>]*(?:alt="([^"]*)")?[^>]*>/gi;
      const allImages = [...html.matchAll(imagePattern)];
      
      for (const imgMatch of allImages) {
        let imgUrl = imgMatch[1];
        const altText = imgMatch[2] || "";
        
        // Ignorer les ic√¥nes, logos, etc.
        if (imgUrl.includes('icon') || 
            imgUrl.includes('logo') || 
            imgUrl.includes('avatar') ||
            imgUrl.includes('flag') ||
            imgUrl.includes('spinner') ||
            imgUrl.includes('loading') ||
            imgUrl.length < 20) {
          continue;
        }
        
        // Compl√©ter l'URL si relative
        if (imgUrl.startsWith('/')) {
          imgUrl = COLEKA_BASE_URL + imgUrl;
        } else if (!imgUrl.startsWith('http')) {
          imgUrl = COLEKA_BASE_URL + '/' + imgUrl;
        }
        
        // Associer l'image au texte alt ou au contexte
        if (altText) {
          imageMap.set(altText.toLowerCase().trim(), imgUrl);
        }
      }
      
      // Extraire les informations de chaque produit
      for (const item of productData) {
        const product = {
          id: null,
          name: null,
          url: item.url,
          path: item.path,
          image: null,
          category: null,
          collection: null
        };
        
        // Extraire le nom depuis le contenu du lien
        // Nettoyer le HTML et extraire le texte
        let textContent = item.content
          .replace(/<[^>]+>/g, ' ')  // Supprimer les balises HTML
          .replace(/&nbsp;/g, ' ')
          .replace(/&amp;/g, '&')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&#(\d+);/g, (m, c) => String.fromCharCode(c))
          .replace(/\s+/g, ' ')
          .trim();
        
        if (textContent.length > 0 && textContent.length < 200) {
          product.name = textContent;
        }
        
        // Extraire l'ID et la cat√©gorie depuis l'URL
        const pathParts = item.path.split('/').filter(s => s.length > 0);
        if (pathParts.length >= 3) {
          product.category = pathParts[1]; // Ex: "lego", "funko-pop", etc.
          product.collection = pathParts.slice(2, -1).join('/'); // Sous-cat√©gorie
          product.id = pathParts[pathParts.length - 1]; // Dernier segment = ID/slug
        }
        
        // Chercher l'image correspondante
        if (product.name) {
          const nameLower = product.name.toLowerCase().trim();
          if (imageMap.has(nameLower)) {
            product.image = imageMap.get(nameLower);
          }
        }
        
        // Chercher l'image dans le contexte HTML autour du lien
        if (!product.image) {
          // Pattern: chercher une image juste avant ou apr√®s le lien dans le HTML original
          const escapedUrl = item.path.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const contextPattern = new RegExp(
            `<img[^>]*src="([^"]+)"[^>]*>[\\s\\S]{0,500}?href="${escapedUrl}"` +
            `|href="${escapedUrl}"[\\s\\S]{0,500}?<img[^>]*src="([^"]+)"`,
            'i'
          );
          const contextMatch = html.match(contextPattern);
          if (contextMatch) {
            let imgUrl = contextMatch[1] || contextMatch[2];
            if (imgUrl) {
              if (imgUrl.startsWith('/')) {
                imgUrl = COLEKA_BASE_URL + imgUrl;
              } else if (!imgUrl.startsWith('http')) {
                imgUrl = COLEKA_BASE_URL + '/' + imgUrl;
              }
              product.image = imgUrl;
            }
          }
        }
        
        // Ajouter seulement si on a un nom ou un ID valide
        if (product.name || product.id) {
          result.products.push(product);
        }
      }
      
      // M√©thode alternative: parser la structure de grille/liste Coleka
      if (result.products.length === 0) {
        console.log("[Coleka] Recherche alternative dans la structure HTML...");
        
        // Chercher les √©l√©ments de grille de r√©sultats
        // Pattern pour les cards Coleka: g√©n√©ralement des divs avec classes sp√©cifiques
        const cardPattern = /<div[^>]*class="[^"]*col[^"]*"[^>]*>([\s\S]*?)<\/div>\s*(?=<div[^>]*class="[^"]*col|$)/gi;
        const cards = [...html.matchAll(cardPattern)];
        
        for (const cardMatch of cards) {
          const cardHtml = cardMatch[1];
          
          // Chercher le lien principal dans la carte
          const linkMatch = cardHtml.match(/<a[^>]*href="(\/[a-z]{2}\/[^"]+)"[^>]*>/i);
          if (!linkMatch) continue;
          
          const url = linkMatch[1];
          
          // Filtrer les liens non-produits
          if (url.includes('/search') || 
              url.includes('/user') || 
              url.includes('/market') ||
              url.match(/^\/[a-z]{2}\/?$/)) {
            continue;
          }
          
          const fullUrl = COLEKA_BASE_URL + url;
          if (seenUrls.has(fullUrl)) continue;
          seenUrls.add(fullUrl);
          
          const product = {
            id: null,
            name: null,
            url: fullUrl,
            path: url,
            image: null,
            category: null,
            collection: null
          };
          
          // Extraire l'image
          const imgMatch = cardHtml.match(/<img[^>]*src="([^"]+)"[^>]*>/i);
          if (imgMatch) {
            let imgUrl = imgMatch[1];
            if (imgUrl.startsWith('/')) {
              imgUrl = COLEKA_BASE_URL + imgUrl;
            }
            product.image = imgUrl;
          }
          
          // Extraire le titre/nom
          const titlePatterns = [
            /<h[1-6][^>]*>([^<]+)<\/h[1-6]>/i,
            /<span[^>]*class="[^"]*title[^"]*"[^>]*>([^<]+)<\/span>/i,
            /<p[^>]*class="[^"]*name[^"]*"[^>]*>([^<]+)<\/p>/i,
            /title="([^"]+)"/i,
            /alt="([^"]+)"/i
          ];
          
          for (const pattern of titlePatterns) {
            const match = cardHtml.match(pattern);
            if (match && match[1].trim().length > 0) {
              product.name = match[1].trim();
              break;
            }
          }
          
          // Extraire cat√©gorie et ID depuis l'URL
          const pathParts = url.split('/').filter(s => s.length > 0);
          if (pathParts.length >= 3) {
            product.category = pathParts[1];
            product.collection = pathParts.slice(2, -1).join('/');
            product.id = pathParts[pathParts.length - 1];
          }
          
          if (product.name || product.id) {
            result.products.push(product);
          }
        }
      }
      
      result.total = result.products.length;
      console.log(`[Coleka] ‚úÖ Trouv√© ${result.total} produits`);
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, result);
      
      return result;

    } catch (err) {
      lastError = err;
      console.warn(`[Coleka] Erreur tentative ${attempt}: ${err.message}`);
      
      // D√©truire la session en cas d'erreur pour repartir proprement
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      // backoff exponentiel
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// R√©cup√©rer les d√©tails d'un item Coleka
// -----------------------------
async function getColekaItemDetails(itemPath, lang = "fr", retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `coleka:item:${itemPath}:${lang}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[Coleka] Tentative ${attempt}/${retries} pour item: "${itemPath}"`);
      
      // Cr√©er une nouvelle session FSR pour chaque tentative
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      fsrSessionId = await createFsrSession();
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      // Construire l'URL de l'item
      let itemUrl = itemPath;
      if (!itemPath.startsWith('http')) {
        if (!itemPath.startsWith('/')) {
          itemPath = '/' + itemPath;
        }
        itemUrl = COLEKA_BASE_URL + itemPath;
      }
      
      // √âtape 1: Visiter la page d'accueil pour d√©clencher le challenge
      console.log("[Coleka] √âtape 1: Visite de la page d'accueil...");
      const homeUrl = `${COLEKA_BASE_URL}/${lang}`;
      
      const homeSolution = await fsrRequest("request.get", homeUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 90000);
      
      const homeHtml = homeSolution.response || "";
      console.log("[Coleka] Page d'accueil re√ßue, taille:", homeHtml.length);
      
      // V√©rifier si on a le challenge sur la page d'accueil
      const hasHomeChallenge = homeHtml.includes("Simple v√©rification") || homeHtml.includes("Visiter COLEKA") || homeHtml.includes("verifyBtn");
      
      if (hasHomeChallenge) {
        console.log("[Coleka] √âtape 2: Challenge d√©tect√© sur page d'accueil, r√©solution...");
        const challengeSolved = await solveColekaChallenge(fsrSessionId, lang);
        if (!challengeSolved) {
          console.log("[Coleka] ‚ùå √âchec de la r√©solution du challenge");
          throw new Error("Protection anti-bot non contourn√©e");
        }
        await new Promise(r => setTimeout(r, 500));
      } else {
        // M√™me si pas de challenge visible, on tente de r√©soudre pr√©ventivement
        // car Coleka peut d√©clencher le challenge sur les pages profondes
        console.log("[Coleka] √âtape 2: R√©solution pr√©ventive du challenge Coleka...");
        await solveColekaChallenge(fsrSessionId, lang);
        await new Promise(r => setTimeout(r, 300));
      }
      
      // √âtape 3: Visiter la page de l'item
      console.log("[Coleka] √âtape 3: Visite de la page item:", itemUrl);
      
      let pageSolution = await fsrRequest("request.get", itemUrl, fsrSessionId, {
        waitInSeconds: 3
      }, 120000);
      
      let html = pageSolution.response || "";
      console.log("[Coleka] Page item re√ßue, taille:", html.length);
      
      // V√©rifier si on a le challenge sur la page item
      if (html.includes("Simple v√©rification") || html.includes("Visiter COLEKA")) {
        console.log("[Coleka] Challenge d√©tect√© sur page item, tentative de r√©solution...");
        
        // R√©soudre le challenge
        const solved = await solveColekaChallenge(fsrSessionId, lang);
        if (solved) {
          console.log("[Coleka] Challenge r√©solu, nouvelle tentative d'acc√®s √† l'item...");
          await new Promise(r => setTimeout(r, 500));
          
          // Re-tenter l'acc√®s √† la page item
          pageSolution = await fsrRequest("request.get", itemUrl, fsrSessionId, {
            waitInSeconds: 3
          }, 120000);
          
          html = pageSolution.response || "";
          console.log("[Coleka] Page item apr√®s r√©solution, taille:", html.length);
          
          // V√©rifier √† nouveau
          if (html.includes("Simple v√©rification") || html.includes("Visiter COLEKA")) {
            console.log("[Coleka] Protection anti-bot toujours pr√©sente apr√®s r√©solution");
            throw new Error("Protection anti-bot non contourn√©e");
          }
        } else {
          throw new Error("Protection anti-bot non contourn√©e");
        }
      }
      
      // V√©rifier si la page existe
      if (html.includes("Page non trouv√©e") || html.includes("404") && html.length < 10000) {
        throw new Error("Item non trouv√©");
      }
      
      // Structure de retour
      const item = {
        id: null,
        name: null,
        url: itemUrl,
        images: [],
        description: null,
        category: null,
        collection: null,
        series: null,
        reference: null,
        releaseDate: null,
        year: null,
        brand: null,
        price: null,
        highPrice: null,
        lowPrice: null,
        attributes: {},
        source: "coleka"
      };
      
      // Extraire l'ID depuis l'URL
      const pathParts = itemUrl.replace(COLEKA_BASE_URL, '').split('/').filter(s => s.length > 0);
      if (pathParts.length >= 3) {
        item.category = pathParts[1];
        item.collection = pathParts.slice(2, -1).join('/');
        item.id = pathParts[pathParts.length - 1];
      }
      
      // --- Extraction du nom ---
      const namePatterns = [
        /<h1[^>]*>([^<]+)<\/h1>/i,
        /<h1[^>]*>([\s\S]*?)<\/h1>/i,
        /class="[^"]*title[^"]*"[^>]*>([^<]+)</i,
        /class="[^"]*product-name[^"]*"[^>]*>([^<]+)</i
      ];
      
      for (const pattern of namePatterns) {
        const match = html.match(pattern);
        if (match) {
          item.name = match[1].replace(/<[^>]+>/g, '').trim();
          if (item.name.length > 0) break;
        }
      }
      
      // --- Extraction des images depuis class="imglist" uniquement ---
      const imglistMatch = html.match(/<[^>]*class="[^"]*imglist[^"]*"[^>]*>([\s\S]*?)<\/(?:div|ul|section)>/i);
      
      if (imglistMatch) {
        const imglistHtml = imglistMatch[1];
        const imgPattern = /(?:src|data-src)="([^"]+)"/gi;
        const matches = [...imglistHtml.matchAll(imgPattern)];
        
        for (const m of matches) {
          let imgUrl = m[1];
          
          if (imgUrl.includes('data:image') || imgUrl.length < 20) {
            continue;
          }
          
          if (imgUrl.startsWith('/')) {
            imgUrl = COLEKA_BASE_URL + imgUrl;
          } else if (!imgUrl.startsWith('http')) {
            imgUrl = COLEKA_BASE_URL + '/' + imgUrl;
          }
          
          // Retirer les dimensions de l'URL (ex: _50x50.webp => .webp)
          imgUrl = imgUrl.replace(/_\d+x\d+\.(\w+)$/, '.$1');
          
          if (!item.images.includes(imgUrl)) {
            item.images.push(imgUrl);
          }
        }
      }
      
      // Fallback si pas d'images dans imglist
      if (item.images.length === 0) {
        const fallbackImgPattern = /<img[^>]*(?:src|data-src)="([^"]+thumbs\.coleka\.com[^"]+)"/gi;
        const matches = [...html.matchAll(fallbackImgPattern)];
        
        for (const m of matches) {
          let imgUrl = m[1];
          if (imgUrl.includes('icon') || imgUrl.includes('logo') || imgUrl.includes('avatar')) continue;
          imgUrl = imgUrl.replace(/_\d+x\d+\.(\w+)$/, '.$1');
          if (!item.images.includes(imgUrl)) {
            item.images.push(imgUrl);
          }
        }
      }
      
      // --- Extraction de la Collection/S√©rie depuis itemprop="category" ---
      const categoryMatch = html.match(/<dd[^>]*itemprop="category"[^>]*>[\s\S]*?<a[^>]*>([^<]+)<\/a>/i);
      if (categoryMatch) {
        item.series = categoryMatch[1].trim();
      }
      
      // --- Extraction de la Date de sortie ---
      const releaseDateMatch = html.match(/<dt[^>]*>Date de sortie<\/dt>\s*<dd[^>]*>(\d{4})/i);
      if (releaseDateMatch) {
        item.releaseDate = releaseDateMatch[1];
        item.year = releaseDateMatch[1];
      }
      
      if (!item.releaseDate) {
        const releaseDateItemprop = html.match(/itemprop="releaseDate"[^>]*>(\d{4})/i);
        if (releaseDateItemprop) {
          item.releaseDate = releaseDateItemprop[1];
          item.year = releaseDateItemprop[1];
        }
      }
      
      // --- Extraction des prix (highPrice, lowPrice) ---
      const highPriceMatch = html.match(/<meta[^>]*itemprop="highPrice"[^>]*content="([^"]+)"/i);
      if (highPriceMatch) {
        item.highPrice = parseFloat(highPriceMatch[1]);
      }
      
      const lowPriceMatch = html.match(/<meta[^>]*itemprop="lowPrice"[^>]*content="([^"]+)"/i);
      if (lowPriceMatch) {
        item.lowPrice = parseFloat(lowPriceMatch[1]);
      }
      
      if (item.highPrice) {
        item.price = item.highPrice;
      } else if (item.lowPrice) {
        item.price = item.lowPrice;
      }
      
      // --- Extraction de la description ---
      const descPatterns = [
        /<div[^>]*class="[^"]*description[^"]*"[^>]*>([\s\S]*?)<\/div>/i,
        /<p[^>]*class="[^"]*description[^"]*"[^>]*>([\s\S]*?)<\/p>/i,
        /class="[^"]*content[^"]*"[^>]*>([\s\S]*?)<\/div>/i
      ];
      
      for (const pattern of descPatterns) {
        const match = html.match(pattern);
        if (match) {
          item.description = match[1]
            .replace(/<[^>]+>/g, ' ')
            .replace(/&nbsp;/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
          if (item.description.length > 0) break;
        }
      }
      
      // --- Extraction des attributs (r√©f√©rence, ann√©e, marque, etc.) ---
      // Pattern pour dt/dd pairs
      const dtDdPattern = /<dt[^>]*>([^<]+)<\/dt>\s*<dd[^>]*>([\s\S]*?)<\/dd>/gi;
      const dtDdMatches = [...html.matchAll(dtDdPattern)];
      
      for (const m of dtDdMatches) {
        const key = m[1].toLowerCase().trim().replace(/[:\s]+$/, '');
        let value = m[2].replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
        
        if (key && value && value.length < 500) {
          item.attributes[key] = value;
          
          // Mapper les attributs connus
          if (key.includes('r√©f√©rence') || key.includes('reference') || key.includes('ref') || key.includes('sku')) {
            item.reference = value;
          } else if (key.includes('marque') || key.includes('brand') || key.includes('fabricant')) {
            item.brand = value;
          }
        }
      }
      
      console.log(`[Coleka] ‚úÖ Item r√©cup√©r√©: ${item.name || item.id}`);
      console.log(`[Coleka]    Images: ${item.images.length}, S√©rie: ${item.series || 'N/A'}, Date: ${item.releaseDate || 'N/A'}, Prix: ${item.price || 'N/A'}`);
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, item);
      
      return item;

    } catch (err) {
      lastError = err;
      console.warn(`[Coleka] Erreur tentative ${attempt}: ${err.message}`);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// Recherche sur Lulu-Berlu via scraping
// -----------------------------
async function searchLuluBerlu(searchTerm, maxResults = LULUBERLU_DEFAULT_MAX, retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `luluberlu:search:${searchTerm}:${maxResults}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[LuluBerlu] Tentative ${attempt}/${retries} pour recherche: "${searchTerm}" (max: ${maxResults})`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      // Structure de retour
      const result = {
        query: searchTerm,
        products: [],
        total: 0,
        source: "lulu-berlu"
      };
      
      // Calculer le nombre de pages n√©cessaires
      const pagesNeeded = Math.ceil(maxResults / LULUBERLU_RESULTS_PER_PAGE);
      let allProducts = [];
      let totalFromSite = 0;
      
      for (let page = 1; page <= pagesNeeded; page++) {
        // Construire l'URL de recherche
        const searchUrl = `${LULUBERLU_SEARCH_URL}?keywords=${encodeURIComponent(searchTerm)}&ok=%A1&numPage=${page}`;
        console.log(`[LuluBerlu] Page ${page}/${pagesNeeded}: ${searchUrl}`);
        
        const pageSolution = await fsrRequest("request.get", searchUrl, fsrSessionId, {
          waitInSeconds: 1  // R√©duit de 2s √† 1s - Lulu-Berlu n'a pas de protection forte
        }, 45000);  // Timeout r√©duit
        
        const html = pageSolution.response || "";
        console.log(`[LuluBerlu] Page ${page} re√ßue, taille: ${html.length}`);
        
        // Extraire le nombre total d'articles (ex: "12 articles sur 82")
        if (page === 1) {
          const totalMatch = html.match(/(\d+)\s*articles?\s+sur\s+(\d+)/i);
          if (totalMatch) {
            totalFromSite = parseInt(totalMatch[2], 10);
            console.log(`[LuluBerlu] Total trouv√©: ${totalFromSite} articles`);
          }
        }
        
        // Parser les produits de la page
        // Pattern pour les bo√Ætes produits avec idProduit (insensible √† la casse)
        const productPattern = /<div[^>]*class="[^"]*bp[^"]*bp_content[^"]*"[^>]*idproduit="(\d+)"[^>]*>([\s\S]*?)<\/div>\s*<\/div>\s*<\/div>\s*<\/div>/gi;
        
        // Alternative: chercher les divs product_box
        const productBoxPattern = /<div class="product_box[^"]*"[^>]*>([\s\S]*?)<div class="(?:product_box|jq-pagination)/gi;
        
        let matches = [...html.matchAll(productPattern)];
        
        // Si pas de matches avec le premier pattern, essayer un pattern plus simple
        if (matches.length === 0) {
          console.log("[LuluBerlu] Pattern principal sans r√©sultat, essai alternatif...");
          
          // Pattern pour extraire les produits individuellement (insensible √† la casse)
          const simplePattern = /idproduit="(\d+)"[\s\S]*?href="([^"]+\.html)"[\s\S]*?(?:alt|title)="([^"]+)"[\s\S]*?(?:data-lazy|src)="([^"]+)"[\s\S]*?class="bp_marque"[^>]*>[\s\S]*?<a[^>]*>([^<]+)<\/a>[\s\S]*?<span class="articleDispo">[\s\S]*?>(En stock|Non disponible|√âpuis√©|Pr√©commande)[^<]*<[\s\S]*?(?:(\d+,\d+)\s*[‚Ç¨&]|<\/div>\s*<\/div>)/gi;
          
          const simpleMatches = [...html.matchAll(simplePattern)];
          
          for (const match of simpleMatches) {
            const id = match[1];
            const url = match[2];
            const name = match[3].trim();
            const image = match[4];
            const brand = match[5].trim();
            const availability = match[6];
            const priceStr = match[7];
            
            // √âviter les doublons
            if (!allProducts.find(p => p.id === id)) {
              allProducts.push({
                id,
                name,
                url: url.startsWith('http') ? url : `${LULUBERLU_BASE_URL}${url.startsWith('/') ? '' : '/'}${url}`,
                image: image.startsWith('http') ? image : `${LULUBERLU_BASE_URL}${image.startsWith('/') ? '' : '/'}${image}`,
                brand,
                availability: availability ? availability.toLowerCase().includes('stock') ? 'in_stock' : 'out_of_stock' : null,
                price: priceStr ? parseFloat(priceStr.replace(',', '.')) : null
              });
            }
          }
        }
        
        // Parser les produits avec une approche plus robuste
        if (allProducts.length === 0 || matches.length > 0) {
          // Chercher tous les blocs produit avec idproduit (insensible √† la casse)
          const idPattern = /idproduit="(\d+)"/gi;
          const idMatches = [...html.matchAll(idPattern)];
          const seenIds = new Set(allProducts.map(p => p.id));
          
          for (const idMatch of idMatches) {
            const productId = idMatch[1];
            if (seenIds.has(productId)) continue;
            seenIds.add(productId);
            
            // Chercher le contexte autour de cet ID (insensible √† la casse)
            const idIndex = html.toLowerCase().indexOf(`idproduit="${productId}"`);
            if (idIndex === -1) continue;
            
            const contextStart = Math.max(0, idIndex - 200);
            const contextEnd = Math.min(html.length, idIndex + 3000);
            const context = html.substring(contextStart, contextEnd);
            
            // Extraire les infos du produit
            const product = {
              id: productId,
              name: null,
              url: null,
              image: null,
              brand: null,
              availability: null,
              price: null
            };
            
            // URL du produit - chercher n'importe quel lien contenant aXXXXX.html
            const urlPattern = new RegExp(`href="([^"]+a${productId}\\.html)"`, 'i');
            const urlMatch = context.match(urlPattern);
            if (urlMatch) {
              product.url = urlMatch[1].startsWith('http') ? urlMatch[1] : LULUBERLU_BASE_URL + (urlMatch[1].startsWith('/') ? '' : '/') + urlMatch[1];
            }
            
            // Nom du produit (depuis alt ou title, exclure les textes g√©n√©riques)
            const nameMatch = context.match(/(?:alt|title)="([^"]{10,})"/i);
            if (nameMatch && !nameMatch[1].toLowerCase().includes('ajouter') && !nameMatch[1].toLowerCase().includes('favoris')) {
              product.name = nameMatch[1].trim();
            }
            
            // Image
            const imgMatch = context.match(/(?:data-lazy|data-url-img)="([^"]+)"/i);
            if (imgMatch) {
              let imgUrl = imgMatch[1];
              if (!imgUrl.startsWith('http')) {
                imgUrl = LULUBERLU_BASE_URL + (imgUrl.startsWith('/') ? '' : '/') + imgUrl;
              }
              product.image = imgUrl;
            }
            
            // Marque
            const brandMatch = context.match(/class="bp_marque"[^>]*>[\s\S]*?<a[^>]*>([^<]+)<\/a>/i);
            if (brandMatch) {
              product.brand = brandMatch[1].trim();
            }
            
            // Disponibilit√©
            const stockMatch = context.match(/<span class="articleDispo">[\s\S]*?>(En stock|Non disponible|√âpuis√©|Pr√©commande)/i);
            if (stockMatch) {
              const status = stockMatch[1].toLowerCase();
              if (status.includes('stock')) {
                product.availability = 'in_stock';
              } else if (status.includes('pr√©commande')) {
                product.availability = 'preorder';
              } else {
                product.availability = 'out_of_stock';
              }
            }
            
            // Prix
            const priceMatch = context.match(/(\d+,\d+)\s*(?:‚Ç¨|&euro;)/i);
            if (priceMatch) {
              product.price = parseFloat(priceMatch[1].replace(',', '.'));
            }
            
            if (product.name || product.url) {
              allProducts.push(product);
            }
          }
        }
        
        console.log(`[LuluBerlu] Page ${page}: ${allProducts.length} produits cumul√©s`);
        
        // V√©rifier si on a atteint le nombre max ou s'il n'y a plus de pages
        if (allProducts.length >= maxResults) {
          break;
        }
        
        // V√©rifier si on a atteint la fin des r√©sultats
        if (totalFromSite > 0 && allProducts.length >= totalFromSite) {
          break;
        }
        
        // V√©rifier s'il n'y a pas de pagination ou si on est √† la derni√®re page
        if (!html.includes('numPage=' + (page + 1))) {
          break;
        }
      }
      
      // Limiter au nombre max demand√©
      result.products = allProducts.slice(0, maxResults);
      result.total = totalFromSite || allProducts.length;
      
      console.log(`[LuluBerlu] ‚úÖ Trouv√© ${result.products.length}/${result.total} produits`);
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, result);
      return result;

    } catch (err) {
      lastError = err;
      console.warn(`[LuluBerlu] Erreur tentative ${attempt}: ${err.message}`);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// R√©cup√©rer les d√©tails d'un item Lulu-Berlu
// -----------------------------
async function getLuluBerluItemDetails(itemId, retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `luluberlu:item:${itemId}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[LuluBerlu] Tentative ${attempt}/${retries} pour item: "${itemId}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      // Construire l'URL de l'item
      // itemId peut √™tre:
      // - une URL compl√®te (https://www.lulu-berlu.com/...)
      // - un chemin relatif (final-fantasy-viii-bandai-figurine-15cm-squall-leonhart-loose-a78643.html)
      // - juste l'ID num√©rique (78643)
      let itemUrl;
      if (itemId.startsWith('http')) {
        itemUrl = itemId;
      } else if (itemId.includes('.html')) {
        itemUrl = itemId.startsWith('/') ? `${LULUBERLU_BASE_URL}${itemId}` : `${LULUBERLU_BASE_URL}/${itemId}`;
      } else if (/^\d+$/.test(itemId)) {
        // Juste l'ID num√©rique - on ne peut pas acc√©der directement car Lulu-Berlu
        // n√©cessite le slug complet dans l'URL. On essaie une recherche mais c'est peu fiable.
        console.log(`[LuluBerlu] ID num√©rique d√©tect√©, tentative de recherche...`);
        
        // Essayer de chercher avec le nom de l'article (pas l'ID)
        // Les r√©sultats de recherche contiennent l'ID dans les attributs
        // Utiliser la recherche /luluberlu/search pour trouver l'article d'abord
        throw new Error("ID seul non support√©. Utilisez l'URL compl√®te du produit ou son chemin (ex: /final-fantasy-viii-bandai-figurine-15cm-squall-leonhart-loose-a78643.html)");
      } else {
        // Essayer comme chemin relatif
        itemUrl = `${LULUBERLU_BASE_URL}/${itemId}`;
      }
      
      console.log(`[LuluBerlu] Visite de: ${itemUrl}`);
      
      const pageSolution = await fsrRequest("request.get", itemUrl, fsrSessionId, {
        waitInSeconds: 1  // R√©duit de 2s √† 1s
      }, 45000);  // Timeout r√©duit
      
      const html = pageSolution.response || "";
      console.log(`[LuluBerlu] Page item re√ßue, taille: ${html.length}`);
      
      // V√©rifier si la page existe
      if (html.includes("Page non trouv√©e") || html.includes("Error 404") || html.length < 5000) {
        throw new Error("Item non trouv√©");
      }
      
      // Structure de retour
      const item = {
        id: itemId,
        name: null,
        url: itemUrl,
        images: [],
        description: null,
        brand: null,
        reference: null,
        price: null,
        availability: null,
        attributes: {},
        source: "lulu-berlu"
      };
      
      // Extraire l'ID depuis le HTML si on ne l'a pas
      const idMatch = html.match(/id_article"\s*value="(\d+)"/i);
      if (idMatch) {
        item.id = idMatch[1];
      }
      
      // --- Extraction du nom ---
      const namePatterns = [
        /<title>([^<]+)<\/title>/i,
        /<h1[^>]*>([^<]+)<\/h1>/i,
        /<meta[^>]*property="og:title"[^>]*content="([^"]+)"/i
      ];
      
      for (const pattern of namePatterns) {
        const match = html.match(pattern);
        if (match) {
          item.name = match[1].trim().replace(/ - Lulu Berlu$/, '').replace(/\s+/g, ' ');
          if (item.name.length > 0) break;
        }
      }
      
      // --- Extraction des images ---
      // Extraire la section principale du produit (fa_bloc-image)
      // jusqu'√† fa_bloc-details pour √©viter les images des produits recommand√©s
      const mainImageSection = html.match(/<div[^>]*class="[^"]*fa_bloc-image[^"]*"[^>]*>([\s\S]*?)<div[^>]*class="[^"]*fa_bloc-details[^"]*"/i);
      const imageHtml = mainImageSection ? mainImageSection[1] : '';
      
      const seenImages = new Set();
      
      // Extraire l'image principale depuis og:image (la plus fiable)
      const ogImageMatch = html.match(/<meta[^>]*property="og:image"[^>]*content="([^"]+)"/i);
      if (ogImageMatch) {
        let imgUrl = ogImageMatch[1];
        // Convertir en grande taille
        imgUrl = imgUrl.replace('-moyenne.', '-grande.');
        if (!seenImages.has(imgUrl)) {
          seenImages.add(imgUrl);
          item.images.push(imgUrl);
        }
      }
      
      // Chercher les images suppl√©mentaires dans la section principale
      if (imageHtml) {
        // Pattern pour les liens href vers les images grandes (dans le carrousel)
        // Format: href="https://...p-image-552834-grande.jpg"
        const hrefPattern = /href="([^"]*p-image-\d+-grande\.[^"]+)"/gi;
        const hrefMatches = [...imageHtml.matchAll(hrefPattern)];
        
        for (const m of hrefMatches) {
          let imgUrl = m[1];
          if (!imgUrl.startsWith('http')) {
            imgUrl = LULUBERLU_BASE_URL + (imgUrl.startsWith('/') ? '' : '/') + imgUrl;
          }
          if (!seenImages.has(imgUrl)) {
            seenImages.add(imgUrl);
            item.images.push(imgUrl);
          }
        }
        
        // Pattern pour data-url-img (images du conteneur principal)
        const dataUrlPattern = /data-url-img="([^"]+)"/gi;
        const dataMatches = [...imageHtml.matchAll(dataUrlPattern)];
        
        for (const m of dataMatches) {
          let imgUrl = m[1];
          if (imgUrl.includes('favicon') || imgUrl.includes('icon') || imgUrl.includes('logo')) continue;
          
          if (!imgUrl.startsWith('http')) {
            imgUrl = LULUBERLU_BASE_URL + (imgUrl.startsWith('/') ? '' : '/') + imgUrl;
          }
          
          // Convertir les URLs moyennes en grandes
          imgUrl = imgUrl.replace('-moyenne.', '-grande.');
          
          if (!seenImages.has(imgUrl)) {
            seenImages.add(imgUrl);
            item.images.push(imgUrl);
          }
        }
      }
      
      // --- Extraction du prix ---
      const pricePatterns = [
        /itemprop="price"[^>]*content="([^"]+)"/i,
        /(\d+[.,]\d+)\s*(?:‚Ç¨|&euro;|EUR)/i
      ];
      
      for (const pattern of pricePatterns) {
        const match = html.match(pattern);
        if (match) {
          item.price = parseFloat(match[1].replace(',', '.'));
          break;
        }
      }
      
      // --- Extraction de la r√©f√©rence (SKU) ---
      const skuMatch = html.match(/itemprop="sku"[^>]*content="([^"]+)"/i);
      if (skuMatch) {
        item.reference = skuMatch[1];
      } else {
        const refMatch = html.match(/R√©f\.\s*:?\s*([A-Z0-9]+)/i);
        if (refMatch) {
          item.reference = refMatch[1];
        }
      }
      
      // --- Extraction de la marque ---
      const brandPatterns = [
        /itemprop="brand"[^>]*content="([^"]+)"/i,
        /<span[^>]*itemprop="brand"[^>]*>([^<]+)<\/span>/i,
        /class="bp_marque"[^>]*>[\s\S]*?<a[^>]*>([^<]+)<\/a>/i
      ];
      
      for (const pattern of brandPatterns) {
        const match = html.match(pattern);
        if (match) {
          item.brand = match[1].trim();
          break;
        }
      }
      
      // --- Extraction de la disponibilit√© ---
      const availabilityPatterns = [
        /itemprop="availability"[^>]*content="([^"]+)"/i,
        /<span class="articleDispo">[\s\S]*?>(En stock|Non disponible|√âpuis√©|Pr√©commande)/i
      ];
      
      for (const pattern of availabilityPatterns) {
        const match = html.match(pattern);
        if (match) {
          const status = match[1].toLowerCase();
          if (status.includes('instock') || status.includes('en stock')) {
            item.availability = 'in_stock';
          } else if (status.includes('preorder') || status.includes('pr√©commande')) {
            item.availability = 'preorder';
          } else {
            item.availability = 'out_of_stock';
          }
          break;
        }
      }
      
      // --- Extraction de la description ---
      const descPatterns = [
        /<meta[^>]*name="description"[^>]*content="([^"]+)"/i,
        /<meta[^>]*property="og:description"[^>]*content="([^"]+)"/i
      ];
      
      for (const pattern of descPatterns) {
        const match = html.match(pattern);
        if (match) {
          // D√©coder les entit√©s HTML
          item.description = match[1]
            .replace(/&nbsp;/g, ' ')
            .replace(/&amp;/g, '&')
            .replace(/&eacute;/g, '√©')
            .replace(/&egrave;/g, '√®')
            .replace(/&agrave;/g, '√†')
            .replace(/&#(\d+);/g, (m, c) => String.fromCharCode(c))
            .trim();
          break;
        }
      }
      
      // --- Extraction des attributs depuis la description ---
      if (item.description) {
        // Parser les attributs comme "Type : Figurine articul√©e Mati√®re : Plastique Taille : 15cm"
        const attrPattern = /(Type|Mati√®re|Taille|Origine|Ann√©e|Condition)\s*:\s*([^:]+?)(?=(?:Type|Mati√®re|Taille|Origine|Ann√©e|Condition)\s*:|$)/gi;
        const attrMatches = [...item.description.matchAll(attrPattern)];
        
        for (const m of attrMatches) {
          const key = m[1].toLowerCase();
          const value = m[2].trim();
          item.attributes[key] = value;
          
          // Mapper les attributs sp√©cifiques
          if (key === 'ann√©e') {
            item.year = value;
          }
        }
      }
      
      // --- Extraction suppl√©mentaire des caract√©ristiques depuis le HTML ---
      const charPattern = /<div[^>]*>(?:Type|Mati√®re|Taille|Origine|Ann√©e|Condition)\s*:\s*([^<]+)<\/div>/gi;
      const charMatches = [...html.matchAll(charPattern)];
      
      for (const m of charMatches) {
        const fullMatch = m[0];
        const keyMatch = fullMatch.match(/(Type|Mati√®re|Taille|Origine|Ann√©e|Condition)/i);
        if (keyMatch) {
          const key = keyMatch[1].toLowerCase();
          const value = m[1].replace(/&nbsp;/g, ' ').replace(/&eacute;/g, '√©').trim();
          if (!item.attributes[key]) {
            item.attributes[key] = value;
          }
        }
      }
      
      console.log(`[LuluBerlu] ‚úÖ Item r√©cup√©r√©: ${item.name || item.id}`);
      console.log(`[LuluBerlu]    Images: ${item.images.length}, Prix: ${item.price || 'N/A'}, R√©f: ${item.reference || 'N/A'}`);
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, item);
      return item;

    } catch (err) {
      lastError = err;
      console.warn(`[LuluBerlu] Erreur tentative ${attempt}: ${err.message}`);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// Fonctions Rebrickable (API officielle)
// Documentation: https://rebrickable.com/api/v3/docs/
// N√©cessite une cl√© API (gratuite avec compte)
// -----------------------------

/**
 * Effectue une requ√™te √† l'API Rebrickable
 * @param {string} endpoint - Endpoint API (ex: "/lego/sets/")
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {object} params - Param√®tres query string optionnels
 * @returns {Promise<object>} - R√©ponse JSON de l'API
 */
async function rebrickableRequest(endpoint, apiKey, params = {}) {
  const url = new URL(`${REBRICKABLE_BASE_URL}${endpoint}`);
  
  // Ajouter les param√®tres √† l'URL
  for (const [key, value] of Object.entries(params)) {
    if (value !== undefined && value !== null) {
      url.searchParams.append(key, value);
    }
  }
  
  console.log(`[Rebrickable] Requ√™te: ${url.toString()}`);
  
  const response = await fetch(url.toString(), {
    method: 'GET',
    headers: {
      'Authorization': `key ${apiKey}`,
      'Accept': 'application/json'
    }
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error(`[Rebrickable] Erreur HTTP ${response.status}: ${errorText}`);
    
    if (response.status === 401) {
      throw new Error("Cl√© API Rebrickable invalide ou manquante");
    } else if (response.status === 404) {
      throw new Error("Set non trouv√©");
    } else if (response.status === 429) {
      throw new Error("Limite de requ√™tes Rebrickable d√©pass√©e (rate limit)");
    }
    
    throw new Error(`Erreur Rebrickable: ${response.status} - ${errorText}`);
  }
  
  return response.json();
}

/**
 * Recherche des sets LEGO sur Rebrickable
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {number} maxResults - Nombre max de r√©sultats
 * @param {object} options - Options suppl√©mentaires (theme_id, min_year, max_year, min_parts, max_parts)
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchRebrickable(query, apiKey, maxResults = REBRICKABLE_DEFAULT_MAX, options = {}) {
  const cacheKey = `rebrickable_search_${query}_${maxResults}_${JSON.stringify(options)}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour recherche: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  const params = {
    search: query,
    page_size: Math.min(maxResults, 1000), // Max 1000 par page
    ordering: '-year', // Plus r√©cents d'abord
    ...options
  };
  
  try {
    const data = await rebrickableRequest('/lego/sets/', apiKey, params);
    
    const result = {
      count: data.count || 0,
      next: data.next,
      previous: data.previous,
      sets: (data.results || []).map(set => ({
        set_num: set.set_num,
        name: set.name,
        year: set.year,
        theme_id: set.theme_id,
        num_parts: set.num_parts,
        set_img_url: set.set_img_url,
        set_url: set.set_url,
        last_modified_dt: set.last_modified_dt
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} sets trouv√©s pour "${query}"`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un set LEGO par son num√©ro
 * @param {string} setNum - Num√©ro du set (ex: "75192-1" ou "75192")
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - D√©tails du set
 */
async function getRebrickableSet(setNum, apiKey) {
  // Ajouter -1 si pas de suffixe
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_set_${setNum}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour set: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest(`/lego/sets/${setNum}/`, apiKey);
    
    const result = {
      set_num: data.set_num,
      name: data.name,
      year: data.year,
      theme_id: data.theme_id,
      num_parts: data.num_parts,
      set_img_url: data.set_img_url,
      set_url: data.set_url,
      last_modified_dt: data.last_modified_dt,
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ Set trouv√©: ${result.name} (${result.set_num})`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les pi√®ces d'un set LEGO
 * @param {string} setNum - Num√©ro du set
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {number} maxParts - Nombre max de pi√®ces √† retourner
 * @returns {Promise<object>} - Liste des pi√®ces
 */
async function getRebrickableSetParts(setNum, apiKey, maxParts = 500) {
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_parts_${setNum}_${maxParts}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour pi√®ces: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest(`/lego/sets/${setNum}/parts/`, apiKey, {
      page_size: Math.min(maxParts, 1000)
    });
    
    const result = {
      set_num: setNum,
      count: data.count || 0,
      parts: (data.results || []).map(p => ({
        part_num: p.part?.part_num,
        name: p.part?.name,
        part_cat_id: p.part?.part_cat_id,
        part_url: p.part?.part_url,
        part_img_url: p.part?.part_img_url,
        color_id: p.color?.id,
        color_name: p.color?.name,
        color_rgb: p.color?.rgb,
        quantity: p.quantity,
        is_spare: p.is_spare,
        element_id: p.element_id
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} pi√®ces pour set ${setNum}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les minifigs d'un set LEGO
 * @param {string} setNum - Num√©ro du set
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - Liste des minifigs
 */
async function getRebrickableSetMinifigs(setNum, apiKey) {
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_minifigs_${setNum}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour minifigs: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest(`/lego/sets/${setNum}/minifigs/`, apiKey);
    
    const result = {
      set_num: setNum,
      count: data.count || 0,
      minifigs: (data.results || []).map(m => ({
        fig_num: m.set_num,
        name: m.set_name,
        quantity: m.quantity,
        set_img_url: m.set_img_url
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} minifigs pour set ${setNum}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les th√®mes LEGO disponibles
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {number} parentId - ID du th√®me parent (optionnel, pour sous-th√®mes)
 * @returns {Promise<object>} - Liste des th√®mes
 */
async function getRebrickableThemes(apiKey, parentId = null) {
  const cacheKey = `rebrickable_themes_${parentId || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour th√®mes`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const params = { page_size: 1000 };
    if (parentId) {
      params.parent_id = parentId;
    }
    
    const data = await rebrickableRequest('/lego/themes/', apiKey, params);
    
    const result = {
      count: data.count || 0,
      themes: (data.results || []).map(t => ({
        id: t.id,
        name: t.name,
        parent_id: t.parent_id
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} th√®mes r√©cup√©r√©s`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les couleurs LEGO disponibles
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - Liste des couleurs
 */
async function getRebrickableColors(apiKey) {
  const cacheKey = 'rebrickable_colors';
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour couleurs`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest('/lego/colors/', apiKey, { page_size: 500 });
    
    const result = {
      count: data.count || 0,
      colors: (data.results || []).map(c => ({
        id: c.id,
        name: c.name,
        rgb: c.rgb,
        is_trans: c.is_trans
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} couleurs r√©cup√©r√©es`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

// -----------------------------
// Fonctions d'interconnexion LEGO <-> Rebrickable
// -----------------------------

/**
 * Convertit un ID LEGO en format Rebrickable
 * LEGO: 75192 -> Rebrickable: 75192-1
 * @param {string} legoId - ID au format LEGO
 * @returns {string} - ID au format Rebrickable
 */
function legoIdToRebrickable(legoId) {
  if (!legoId) return null;
  const id = String(legoId).trim();
  if (id.includes('-')) return id;
  return `${id}-1`;
}

/**
 * Convertit un ID Rebrickable en format LEGO
 * Rebrickable: 75192-1 -> LEGO: 75192
 * @param {string} rebrickableId - ID au format Rebrickable
 * @returns {string} - ID au format LEGO
 */
function rebrickableIdToLego(rebrickableId) {
  if (!rebrickableId) return null;
  const id = String(rebrickableId).trim();
  return id.replace(/-\d+$/, '');
}

/**
 * D√©tecte si une requ√™te est une recherche par ID de set ou par texte
 * @param {string} query - La requ√™te
 * @returns {boolean} - true si c'est un ID de set
 */
function isSetNumber(query) {
  if (!query) return false;
  const q = String(query).trim();
  // Patterns: 75192, 75192-1, 75192-2, etc.
  return /^\d{4,6}(-\d+)?$/.test(q);
}

/**
 * R√©cup√®re les infos compl√®tes d'un set Rebrickable (set + minifigs + parts)
 * @param {string} setNum - Num√©ro du set
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {object} options - Options (includeParts, includeMinifigs, maxParts)
 * @returns {Promise<object>} - Infos compl√®tes du set
 */
async function getRebrickableSetFull(setNum, apiKey, options = {}) {
  const {
    includeParts = true,
    includeMinifigs = true,
    maxParts = 500
  } = options;
  
  // Normaliser l'ID
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_full_${setNum}_${includeParts}_${includeMinifigs}_${maxParts}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour set complet: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Rebrickable] R√©cup√©ration compl√®te du set ${setNum}...`);
  
  // R√©cup√©rer le set de base
  const setData = await getRebrickableSet(setNum, apiKey);
  
  const result = {
    ...setData,
    minifigs: null,
    parts: null
  };
  
  // R√©cup√©rer les minifigs en parall√®le avec les parts
  const promises = [];
  
  if (includeMinifigs) {
    promises.push(
      getRebrickableSetMinifigs(setNum, apiKey)
        .then(data => { result.minifigs = data; })
        .catch(err => { 
          console.warn(`[Rebrickable] Erreur minifigs: ${err.message}`);
          result.minifigs = { count: 0, minifigs: [], error: err.message };
        })
    );
  }
  
  if (includeParts) {
    promises.push(
      getRebrickableSetParts(setNum, apiKey, maxParts)
        .then(data => { result.parts = data; })
        .catch(err => {
          console.warn(`[Rebrickable] Erreur parts: ${err.message}`);
          result.parts = { count: 0, parts: [], error: err.message };
        })
    );
  }
  
  await Promise.all(promises);
  
  console.log(`[Rebrickable] ‚úÖ Set complet: ${result.name}, ${result.minifigs?.count || 0} minifigs, ${result.parts?.count || 0} parts`);
  
  setCache(cacheKey, result);
  return result;
}

/**
 * Enrichit les donn√©es LEGO avec les infos Rebrickable (parts, minifigs)
 * @param {object} legoData - Donn√©es du produit LEGO
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - Donn√©es enrichies
 */
async function enrichLegoWithRebrickable(legoData, apiKey) {
  if (!apiKey || !legoData) return legoData;
  
  const productCode = legoData.productCode || legoData.id;
  if (!productCode) return legoData;
  
  const setNum = legoIdToRebrickable(productCode);
  
  console.log(`[Enrichment] Enrichissement LEGO ${productCode} avec Rebrickable...`);
  
  try {
    // R√©cup√©rer les donn√©es Rebrickable
    const [minifigsData, partsData] = await Promise.all([
      getRebrickableSetMinifigs(setNum, apiKey).catch(err => {
        console.warn(`[Enrichment] Minifigs non trouv√©es: ${err.message}`);
        return null;
      }),
      getRebrickableSetParts(setNum, apiKey, 100).catch(err => {
        console.warn(`[Enrichment] Parts non trouv√©es: ${err.message}`);
        return null;
      })
    ]);
    
    // Enrichir les donn√©es
    const enriched = {
      ...legoData,
      rebrickable: {
        set_num: setNum,
        minifigs: minifigsData ? {
          count: minifigsData.count,
          items: minifigsData.minifigs
        } : null,
        parts: partsData ? {
          count: partsData.count,
          sample: partsData.parts.slice(0, 20) // Premiers 20 parts seulement
        } : null
      }
    };
    
    console.log(`[Enrichment] ‚úÖ LEGO enrichi avec ${minifigsData?.count || 0} minifigs, ${partsData?.count || 0} parts`);
    return enriched;
    
  } catch (err) {
    console.warn(`[Enrichment] √âchec enrichissement: ${err.message}`);
    return legoData;
  }
}

/**
 * Enrichit les donn√©es Rebrickable avec les infos LEGO (manuels, prix)
 * @param {object} rebrickableData - Donn√©es du set Rebrickable
 * @param {string} lang - Langue pour LEGO
 * @returns {Promise<object>} - Donn√©es enrichies
 */
async function enrichRebrickableWithLego(rebrickableData, lang = DEFAULT_LOCALE) {
  if (!rebrickableData) return rebrickableData;
  
  const setNum = rebrickableData.set_num;
  if (!setNum) return rebrickableData;
  
  const legoId = rebrickableIdToLego(setNum);
  
  console.log(`[Enrichment] Enrichissement Rebrickable ${setNum} avec LEGO...`);
  
  try {
    // R√©cup√©rer les instructions LEGO
    const instructions = await getBuildingInstructions(legoId, lang).catch(err => {
      console.warn(`[Enrichment] Instructions non trouv√©es: ${err.message}`);
      return null;
    });
    
    // R√©cup√©rer les d√©tails produit LEGO (pour le prix)
    const productDetails = await getProductDetails(legoId, lang).catch(err => {
      console.warn(`[Enrichment] D√©tails produit non trouv√©s: ${err.message}`);
      return null;
    });
    
    // Enrichir les donn√©es
    const enriched = {
      ...rebrickableData,
      lego: {
        id: legoId,
        url: productDetails?.url || `https://www.lego.com/${lang.toLowerCase()}/product/${legoId}`,
        price: productDetails?.price || null,
        listPrice: productDetails?.listPrice || null,
        availability: productDetails?.availability || null,
        availabilityText: productDetails?.availabilityText || null,
        instructions: instructions ? {
          count: instructions.manuals?.length || 0,
          manuals: instructions.manuals || []
        } : null
      }
    };
    
    console.log(`[Enrichment] ‚úÖ Rebrickable enrichi avec ${instructions?.manuals?.length || 0} manuels`);
    return enriched;
    
  } catch (err) {
    console.warn(`[Enrichment] √âchec enrichissement: ${err.message}`);
    return rebrickableData;
  }
}

/**
 * Recherche intelligente sur Rebrickable avec pagination
 * G√®re automatiquement la recherche par ID vs texte
 * @param {string} query - Recherche (ID ou texte)
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats
 */
async function smartRebrickableSearch(query, apiKey, options = {}) {
  const {
    page = 1,
    pageSize = 20,
    enrichWithLego = false,
    lang = DEFAULT_LOCALE,
    ...searchOptions
  } = options;
  
  // D√©terminer si c'est une recherche par ID
  if (isSetNumber(query)) {
    console.log(`[Rebrickable] Recherche par ID de set: ${query}`);
    
    // Recherche par ID -> r√©cup√©rer le set complet
    let setData = await getRebrickableSetFull(query, apiKey, {
      includeParts: true,
      includeMinifigs: true,
      maxParts: options.maxParts || 500
    });
    
    // Enrichir avec LEGO si demand√©
    if (enrichWithLego) {
      setData = await enrichRebrickableWithLego(setData, lang);
    }
    
    // Ajouter les champs type et lego_id
    return {
      ...setData,
      type: 'set_id',
      lego_id: rebrickableIdToLego(setData.set_num)
    };
  }
  
  // Recherche par texte
  console.log(`[Rebrickable] Recherche par texte: "${query}" (page ${page}, ${pageSize}/page)`);
  
  const cacheKey = `rebrickable_smart_${query}_${page}_${pageSize}_${JSON.stringify(searchOptions)}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour recherche smart: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  const params = {
    search: query,
    page: page,
    page_size: pageSize,
    ordering: '-year',
    ...searchOptions
  };
  
  try {
    const data = await rebrickableRequest('/lego/sets/', apiKey, params);
    
    const result = {
      query: query,
      type: 'text_search',
      pagination: {
        page: page,
        page_size: pageSize,
        total_count: data.count || 0,
        total_pages: Math.ceil((data.count || 0) / pageSize),
        has_next: !!data.next,
        has_previous: !!data.previous
      },
      sets: (data.results || []).map(set => ({
        set_num: set.set_num,
        lego_id: rebrickableIdToLego(set.set_num),
        name: set.name,
        year: set.year,
        theme_id: set.theme_id,
        num_parts: set.num_parts,
        set_img_url: set.set_img_url,
        set_url: set.set_url,
        last_modified_dt: set.last_modified_dt
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.pagination.total_count} sets trouv√©s, page ${page}/${result.pagination.total_pages}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

// ============================================================================
// GOOGLE BOOKS - Fonctions et helpers
// ============================================================================

/**
 * V√©rifie si une cha√Æne ressemble √† un ISBN (10 ou 13 chiffres)
 * @param {string} query - La cha√Æne √† v√©rifier
 * @returns {boolean} - true si c'est un ISBN probable
 */
function isIsbn(query) {
  if (!query) return false;
  const cleaned = String(query).replace(/[-\s]/g, '').toUpperCase();
  // ISBN-13: 13 chiffres
  if (/^\d{13}$/.test(cleaned)) return true;
  // ISBN-10: 9 chiffres + 1 chiffre ou X
  if (/^\d{9}[\dX]$/.test(cleaned)) return true;
  return false;
}

/**
 * Valide un ISBN (checksum)
 * @param {string} isbn - L'ISBN √† valider
 * @returns {boolean} - true si valide
 */
function validateIsbn(isbn) {
  if (!isbn) return false;
  const cleaned = String(isbn).replace(/[-\s]/g, '').toUpperCase();
  
  // ISBN-13
  if (/^\d{13}$/.test(cleaned)) {
    let sum = 0;
    for (let i = 0; i < 13; i++) {
      const digit = parseInt(cleaned[i], 10);
      sum += (i % 2 === 0) ? digit : digit * 3;
    }
    return sum % 10 === 0;
  }
  
  // ISBN-10
  if (/^\d{9}[\dX]$/.test(cleaned)) {
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      sum += (i + 1) * parseInt(cleaned[i], 10);
    }
    const check = sum % 11;
    const last = cleaned[9];
    if (check === 10) return last === 'X';
    return parseInt(last, 10) === check;
  }
  
  return false;
}

/**
 * Convertit ISBN-10 en ISBN-13
 * @param {string} isbn10 - ISBN-10
 * @returns {string|null} - ISBN-13 ou null si invalide
 */
function isbn10to13(isbn10) {
  const cleaned = String(isbn10).replace(/[-\s]/g, '').toUpperCase();
  if (!/^\d{9}[\dX]$/.test(cleaned)) return null;
  
  const core = '978' + cleaned.substring(0, 9);
  let sum = 0;
  for (let i = 0; i < 12; i++) {
    const digit = parseInt(core[i], 10);
    sum += (i % 2 === 0) ? digit : digit * 3;
  }
  const mod = sum % 10;
  const check = (mod === 0) ? 0 : (10 - mod);
  return core + check;
}

/**
 * Recherche sur Google Books API
 * @param {string} query - Requ√™te de recherche (texte ou ISBN)
 * @param {string} apiKey - Cl√© API Google
 * @param {object} options - Options (lang, maxResults)
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchGoogleBooks(query, apiKey, options = {}) {
  const {
    lang = null,
    maxResults = GOOGLE_BOOKS_DEFAULT_MAX
  } = options;
  
  if (!apiKey) {
    throw new Error("Cl√© API Google Books requise");
  }
  
  // D√©terminer si c'est une recherche par ISBN
  const isIsbnQuery = isIsbn(query);
  const searchType = isIsbnQuery ? 'isbn' : 'text';
  
  // Normaliser maxResults
  const limit = Math.min(Math.max(1, maxResults), GOOGLE_BOOKS_MAX_LIMIT);
  
  // Construire la cl√© de cache
  const cacheKey = `googlebooks_search_${searchType}_${query}_${lang}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Google Books] Cache hit pour: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Google Books] Recherche ${searchType}: "${query}" (lang: ${lang || 'any'}, max: ${limit})`);
  metrics.sources.googlebooks.requests++;
  
  try {
    // Construire l'URL
    let url = `${GOOGLE_BOOKS_BASE_URL}/volumes?`;
    
    if (isIsbnQuery) {
      // Recherche par ISBN
      const cleanedIsbn = query.replace(/[-\s]/g, '');
      url += `q=isbn:${encodeURIComponent(cleanedIsbn)}`;
    } else {
      // Recherche par texte
      url += `q=${encodeURIComponent(query)}`;
    }
    
    url += `&key=${encodeURIComponent(apiKey)}`;
    url += `&maxResults=${limit}`;
    
    if (lang) {
      // langRestrict utilise les codes ISO 639-1 (fr, en, es, etc.)
      const langCode = lang.substring(0, 2).toLowerCase();
      url += `&langRestrict=${langCode}`;
    }
    
    console.log(`[Google Books] URL: ${url.replace(apiKey, '***')}`);
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[Google Books] Erreur HTTP ${response.status}: ${errorText}`);
      
      if (response.status === 403) {
        throw new Error("Cl√© API Google Books invalide ou quota d√©pass√©");
      } else if (response.status === 429) {
        throw new Error("Trop de requ√™tes - rate limit atteint");
      }
      throw new Error(`Erreur Google Books API: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Parser les r√©sultats
    const items = data.items || [];
    const totalItems = data.totalItems || 0;
    
    const books = items.map(item => {
      const vol = item.volumeInfo || {};
      const saleInfo = item.saleInfo || {};
      
      // Extraire les identifiants (ISBN-10, ISBN-13)
      const identifiers = {};
      if (vol.industryIdentifiers) {
        for (const id of vol.industryIdentifiers) {
          if (id.type === 'ISBN_10') identifiers.isbn_10 = id.identifier;
          else if (id.type === 'ISBN_13') identifiers.isbn_13 = id.identifier;
          else if (id.type === 'OTHER') identifiers.other = id.identifier;
        }
      }
      
      // Construire l'URL de la couverture en haute r√©solution
      let coverUrl = null;
      if (vol.imageLinks) {
        // Pr√©f√©rer: extraLarge > large > medium > small > thumbnail
        coverUrl = vol.imageLinks.extraLarge || 
                   vol.imageLinks.large || 
                   vol.imageLinks.medium || 
                   vol.imageLinks.small || 
                   vol.imageLinks.thumbnail;
        // Supprimer le zoom et forcer HTTPS
        if (coverUrl) {
          coverUrl = coverUrl.replace(/&edge=curl/g, '')
                            .replace(/zoom=\d+/g, 'zoom=1')
                            .replace('http://', 'https://');
        }
      }
      
      return {
        id: item.id,
        title: vol.title || null,
        originalTitle: null,
        authors: vol.authors || [],
        editors: vol.publisher ? [vol.publisher] : [],
        releaseDate: vol.publishedDate || null,
        genres: vol.categories || [],
        pages: vol.pageCount || null,
        serie: null,
        synopsis: vol.description || null,
        language: vol.language || null,
        tome: null,
        image: coverUrl ? [coverUrl] : [],
        isbn: identifiers.isbn_13 || identifiers.isbn_10 || null,
        price: null,
        previewLink: vol.previewLink || null,
        source: 'google_books'
      };
    });
    
    const result = {
      query: query,
      type: searchType,
      totalItems: totalItems,
      count: books.length,
      books: books,
      source: "google_books"
    };
    
    console.log(`[Google Books] ‚úÖ ${totalItems} r√©sultats trouv√©s, ${books.length} retourn√©s`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.googlebooks.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un livre par son ID Google Books
 * @param {string} volumeId - ID du volume Google Books
 * @param {string} apiKey - Cl√© API Google
 * @returns {Promise<object>} - D√©tails du livre
 */
async function getGoogleBookById(volumeId, apiKey) {
  if (!apiKey) {
    throw new Error("Cl√© API Google Books requise");
  }
  
  const cacheKey = `googlebooks_volume_${volumeId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Google Books] Cache hit pour volume: ${volumeId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Google Books] R√©cup√©ration volume: ${volumeId}`);
  metrics.sources.googlebooks.requests++;
  
  try {
    const url = `${GOOGLE_BOOKS_BASE_URL}/volumes/${encodeURIComponent(volumeId)}?key=${encodeURIComponent(apiKey)}`;
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Volume ${volumeId} non trouv√©`);
      } else if (response.status === 403) {
        throw new Error("Cl√© API Google Books invalide ou quota d√©pass√©");
      }
      throw new Error(`Erreur Google Books API: ${response.status}`);
    }
    
    const item = await response.json();
    const vol = item.volumeInfo || {};
    const saleInfo = item.saleInfo || {};
    const accessInfo = item.accessInfo || {};
    
    // Extraire les identifiants
    const identifiers = {};
    if (vol.industryIdentifiers) {
      for (const id of vol.industryIdentifiers) {
        if (id.type === 'ISBN_10') identifiers.isbn_10 = id.identifier;
        else if (id.type === 'ISBN_13') identifiers.isbn_13 = id.identifier;
        else identifiers[id.type.toLowerCase()] = id.identifier;
      }
    }
    
    // Couvertures en diff√©rentes tailles
    const covers = {};
    if (vol.imageLinks) {
      for (const [size, url] of Object.entries(vol.imageLinks)) {
        covers[size] = url.replace('http://', 'https://').replace(/&edge=curl/g, '');
      }
    }
    
    // Construire le tableau d'images (diff√©rentes tailles disponibles)
    const imageArray = [];
    if (covers.extraLarge) imageArray.push(covers.extraLarge);
    if (covers.large) imageArray.push(covers.large);
    if (covers.medium) imageArray.push(covers.medium);
    if (covers.small) imageArray.push(covers.small);
    if (covers.thumbnail) imageArray.push(covers.thumbnail);
    
    const result = {
      id: item.id,
      title: vol.title || null,
      originalTitle: null,
      authors: vol.authors || [],
      editors: vol.publisher ? [vol.publisher] : [],
      releaseDate: vol.publishedDate || null,
      genres: vol.categories || [],
      pages: vol.pageCount || null,
      serie: null,
      synopsis: vol.description || null,
      language: vol.language || null,
      tome: null,
      image: imageArray,
      isbn: identifiers.isbn_13 || identifiers.isbn_10 || null,
      price: null,
      previewLink: vol.previewLink || null,
      infoLink: vol.infoLink || null,
      source: "google_books"
    };
    
    console.log(`[Google Books] ‚úÖ Volume r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.googlebooks.errors++;
    throw err;
  }
}

// ============================================================================
// OPENLIBRARY - Fonctions et helpers
// ============================================================================

/**
 * Recherche sur OpenLibrary API (pas de cl√© API requise)
 * @param {string} query - Requ√™te de recherche (texte ou ISBN)
 * @param {object} options - Options (lang, maxResults)
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchOpenLibrary(query, options = {}) {
  const {
    lang = null,
    maxResults = OPENLIBRARY_DEFAULT_MAX
  } = options;
  
  // D√©terminer si c'est une recherche par ISBN
  const isIsbnQuery = isIsbn(query);
  const searchType = isIsbnQuery ? 'isbn' : 'text';
  
  // Normaliser maxResults
  const limit = Math.min(Math.max(1, maxResults), OPENLIBRARY_MAX_LIMIT);
  
  // Construire la cl√© de cache
  const cacheKey = `openlibrary_search_${searchType}_${query}_${lang}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[OpenLibrary] Cache hit pour: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[OpenLibrary] Recherche ${searchType}: "${query}" (lang: ${lang || 'any'}, max: ${limit})`);
  metrics.sources.openlibrary.requests++;
  
  try {
    let result;
    
    if (isIsbnQuery) {
      // Recherche par ISBN - utiliser l'API bibkeys
      result = await searchOpenLibraryByIsbn(query, lang);
    } else {
      // Recherche par texte - utiliser l'API search
      result = await searchOpenLibraryByText(query, lang, limit);
    }
    
    console.log(`[OpenLibrary] ‚úÖ ${result.totalItems || result.count} r√©sultats trouv√©s`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.openlibrary.errors++;
    throw err;
  }
}

/**
 * Recherche OpenLibrary par ISBN
 * @param {string} isbn - ISBN
 * @param {string} lang - Langue pr√©f√©r√©e
 * @returns {Promise<object>} - R√©sultat
 */
async function searchOpenLibraryByIsbn(isbn, lang = null) {
  const cleanedIsbn = isbn.replace(/[-\s]/g, '');
  
  // API bibkeys pour ISBN
  const url = `${OPENLIBRARY_BASE_URL}/api/books?bibkeys=ISBN:${encodeURIComponent(cleanedIsbn)}&format=json&jscmd=data`;
  
  console.log(`[OpenLibrary] URL ISBN: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur OpenLibrary API: ${response.status}`);
  }
  
  const data = await response.json();
  const key = `ISBN:${cleanedIsbn}`;
  
  if (!data[key]) {
    // ISBN non trouv√©
    return {
      query: isbn,
      type: 'isbn',
      totalItems: 0,
      count: 0,
      books: [],
      source: "openlibrary"
    };
  }
  
  const book = data[key];
  
  // Parser le r√©sultat
  const parsedBook = parseOpenLibraryBook(book, cleanedIsbn);
  
  return {
    query: isbn,
    type: 'isbn',
    totalItems: 1,
    count: 1,
    books: [parsedBook],
    source: "openlibrary"
  };
}

/**
 * Recherche OpenLibrary par texte
 * @param {string} query - Requ√™te texte
 * @param {string} lang - Langue pr√©f√©r√©e
 * @param {number} limit - Nombre max de r√©sultats
 * @returns {Promise<object>} - R√©sultats
 */
async function searchOpenLibraryByText(query, lang = null, limit = OPENLIBRARY_DEFAULT_MAX) {
  // API search.json
  let url = `${OPENLIBRARY_BASE_URL}/search.json?q=${encodeURIComponent(query)}&limit=${limit}`;
  
  // Filtrage par langue si sp√©cifi√©
  if (lang) {
    const langCode = lang.substring(0, 2).toLowerCase();
    // Mapping des codes langue vers OpenLibrary
    const langMap = { 'en': 'eng', 'fr': 'fre', 'es': 'spa', 'de': 'ger', 'it': 'ita', 'pt': 'por' };
    if (langMap[langCode]) {
      url += `&language=${langMap[langCode]}`;
    }
  }
  
  console.log(`[OpenLibrary] URL texte: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur OpenLibrary API: ${response.status}`);
  }
  
  const data = await response.json();
  const docs = data.docs || [];
  const numFound = data.numFound || 0;
  
  // Parser les r√©sultats - Format Harmonis√©
  const books = docs.map(doc => {
    // Titre
    const title = doc.title || doc.title_suggest || null;
    
    // Auteurs
    const authors = doc.author_name || [];
    
    // √âditeurs
    const editors = doc.publisher || [];
    
    // Date de publication
    let releaseDate = null;
    if (doc.first_publish_year) {
      releaseDate = String(doc.first_publish_year);
    } else if (doc.publish_year && doc.publish_year.length > 0) {
      releaseDate = String(doc.publish_year[0]);
    }
    
    // ISBN - prendre le premier ISBN-13 ou ISBN-10
    let isbn = null;
    if (doc.isbn && doc.isbn.length > 0) {
      for (const isb of doc.isbn) {
        const cleaned = isb.replace(/[-\s]/g, '');
        if (cleaned.length === 13) {
          isbn = cleaned;
          break;
        } else if (cleaned.length === 10 && !isbn) {
          isbn = cleaned;
        }
      }
    }
    
    // Images - construire le tableau avec diff√©rentes tailles
    const images = [];
    if (doc.cover_i) {
      images.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg`);
      images.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-M.jpg`);
      images.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-S.jpg`);
    } else if (isbn) {
      images.push(`https://covers.openlibrary.org/b/isbn/${isbn}-L.jpg`);
      images.push(`https://covers.openlibrary.org/b/isbn/${isbn}-M.jpg`);
      images.push(`https://covers.openlibrary.org/b/isbn/${isbn}-S.jpg`);
    }
    
    // Cl√© OpenLibrary
    const olKey = doc.key || null;
    const olId = olKey ? olKey.replace('/works/', '') : null;
    
    // Genres/Sujets
    const genres = doc.subject ? doc.subject.slice(0, 10) : [];
    
    // Langue
    const language = doc.language ? doc.language[0] : null;
    
    // Format Harmonis√©
    return {
      id: olId,
      type: "book",
      title: title,
      originalTitle: null,
      authors: authors,
      editors: editors,
      releaseDate: releaseDate,
      genres: genres,
      pages: null,
      serie: null,
      synopsis: null,
      language: language,
      tome: null,
      image: images,
      isbn: isbn,
      price: null,
      url: olId ? `https://openlibrary.org/works/${olId}` : null,
      source: "openlibrary"
    };
  });
  
  return {
    query: query,
    type: 'text',
    totalItems: numFound,
    count: books.length,
    books: books,
    source: "openlibrary"
  };
}

/**
 * Parse un livre OpenLibrary (format bibkeys/data)
 * @param {object} book - Donn√©es brutes
 * @param {string} isbn - ISBN utilis√© pour la recherche
 * @returns {object} - Livre format√©
 */
function parseOpenLibraryBook(book, isbn = null) {
  // Auteurs
  const authors = (book.authors || []).map(a => a.name).filter(Boolean);
  
  // √âditeurs
  const editors = (book.publishers || []).map(p => p.name).filter(Boolean);
  
  // Identifiants - r√©cup√©rer l'ISBN
  let isbnValue = null;
  if (book.identifiers) {
    if (book.identifiers.isbn_13 && book.identifiers.isbn_13[0]) {
      isbnValue = book.identifiers.isbn_13[0];
    } else if (book.identifiers.isbn_10 && book.identifiers.isbn_10[0]) {
      isbnValue = book.identifiers.isbn_10[0];
    }
  }
  // Ajouter l'ISBN de recherche si pas d√©j√† pr√©sent
  if (!isbnValue && isbn) {
    isbnValue = isbn.replace(/[-\s]/g, '');
  }
  
  // ID OpenLibrary
  const olId = book.identifiers?.openlibrary?.[0] || null;
  
  // Images - construire le tableau avec diff√©rentes tailles
  const images = [];
  if (book.cover) {
    if (book.cover.large) images.push(book.cover.large);
    if (book.cover.medium) images.push(book.cover.medium);
    if (book.cover.small) images.push(book.cover.small);
  }
  
  // Sujets/Genres
  const genres = (book.subjects || []).map(s => s.name).filter(Boolean).slice(0, 10);
  
  // Synopsis - peut √™tre dans excerpts ou notes
  let synopsis = null;
  if (book.excerpts && book.excerpts.length > 0) {
    synopsis = book.excerpts[0].text || null;
  } else if (book.notes) {
    synopsis = typeof book.notes === 'string' ? book.notes : book.notes.value || null;
  }
  
  // Format Harmonis√©
  return {
    id: olId,
    type: "book",
    title: book.title || null,
    originalTitle: null,
    authors: authors,
    editors: editors,
    releaseDate: book.publish_date || null,
    genres: genres,
    pages: book.number_of_pages || null,
    serie: null,
    synopsis: synopsis,
    language: null,
    tome: null,
    image: images,
    isbn: isbnValue,
    price: null,
    url: book.url || (olId ? `https://openlibrary.org/books/${olId}` : null),
    source: "openlibrary"
  };
}

/**
 * R√©cup√®re les d√©tails d'un livre par son ID OpenLibrary (work ou edition)
 * @param {string} olId - ID OpenLibrary (ex: OL1234W pour work, OL1234M pour edition)
 * @returns {Promise<object>} - D√©tails du livre
 */
async function getOpenLibraryById(olId) {
  const cacheKey = `openlibrary_${olId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[OpenLibrary] Cache hit pour: ${olId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[OpenLibrary] R√©cup√©ration: ${olId}`);
  metrics.sources.openlibrary.requests++;
  
  try {
    // D√©terminer le type (work ou edition)
    let url;
    const isWork = olId.endsWith('W');
    const isEdition = olId.endsWith('M');
    
    if (isWork) {
      url = `${OPENLIBRARY_BASE_URL}/works/${olId}.json`;
    } else if (isEdition) {
      url = `${OPENLIBRARY_BASE_URL}/books/${olId}.json`;
    } else {
      // Essayer comme work par d√©faut
      url = `${OPENLIBRARY_BASE_URL}/works/OL${olId}W.json`;
    }
    
    console.log(`[OpenLibrary] URL: ${url}`);
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Livre ${olId} non trouv√© sur OpenLibrary`);
      }
      throw new Error(`Erreur OpenLibrary API: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Format work - Format Harmonis√©
    if (data.type?.key === '/type/work') {
      // Construire le tableau d'images
      const images = data.covers ? data.covers.slice(0, 5).map(id => 
        `https://covers.openlibrary.org/b/id/${id}-L.jpg`
      ) : [];
      // Ajouter les tailles moyennes
      if (data.covers && data.covers[0]) {
        images.push(`https://covers.openlibrary.org/b/id/${data.covers[0]}-M.jpg`);
      }
      
      // Genres/Sujets
      const genres = data.subjects || [];
      
      // Synopsis
      const synopsis = typeof data.description === 'string' ? data.description : data.description?.value || null;
      
      // === ENRICHISSEMENT : R√©cup√©rer les auteurs ===
      let authors = [];
      if (data.authors && data.authors.length > 0) {
        const authorPromises = data.authors.slice(0, 5).map(async (authorRef) => {
          const authorKey = authorRef.author?.key || authorRef.key;
          if (!authorKey) return null;
          try {
            const authorResp = await fetch(`${OPENLIBRARY_BASE_URL}${authorKey}.json`, {
              headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
            });
            if (authorResp.ok) {
              const authorData = await authorResp.json();
              return authorData.name || authorData.personal_name || null;
            }
          } catch (e) {
            console.log(`[OpenLibrary] Erreur r√©cup√©ration auteur: ${e.message}`);
          }
          return null;
        });
        const authorResults = await Promise.all(authorPromises);
        authors = authorResults.filter(Boolean);
      }
      
      // === ENRICHISSEMENT : R√©cup√©rer la premi√®re √©dition pour ISBN/√©diteur ===
      let isbn = null;
      let editors = [];
      let pages = null;
      let releaseDate = data.first_publish_date || null;
      let language = null;
      
      try {
        const editionsUrl = `${OPENLIBRARY_BASE_URL}/works/${olId}/editions.json?limit=5`;
        console.log(`[OpenLibrary] R√©cup√©ration √©ditions: ${editionsUrl}`);
        const editionsResp = await fetch(editionsUrl, {
          headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
        });
        
        if (editionsResp.ok) {
          const editionsData = await editionsResp.json();
          const editions = editionsData.entries || [];
          
          // Chercher la meilleure √©dition (avec ISBN-13 de pr√©f√©rence)
          for (const edition of editions) {
            if (!isbn) {
              isbn = edition.isbn_13?.[0] || edition.isbn_10?.[0] || null;
            }
            if (editors.length === 0 && edition.publishers) {
              editors = edition.publishers;
            }
            if (!pages && edition.number_of_pages) {
              pages = edition.number_of_pages;
            }
            if (!language && edition.languages) {
              language = edition.languages[0]?.key?.replace('/languages/', '') || null;
            }
            // Si on a tout, arr√™ter
            if (isbn && editors.length > 0 && pages && language) break;
          }
        }
      } catch (e) {
        console.log(`[OpenLibrary] Erreur r√©cup√©ration √©ditions: ${e.message}`);
      }
      
      const result = {
        id: olId,
        type: "work",
        title: data.title || null,
        originalTitle: null,
        authors: authors,
        editors: editors,
        releaseDate: releaseDate,
        genres: genres.slice(0, 15),
        pages: pages,
        serie: null,
        synopsis: synopsis,
        language: language,
        tome: null,
        image: images,
        isbn: isbn,
        price: null,
        url: `https://openlibrary.org/works/${olId}`,
        source: "openlibrary",
        // Champs additionnels sp√©cifiques au work
        subjectPlaces: data.subject_places || [],
        subjectTimes: data.subject_times || [],
        subjectPeople: data.subject_people || [],
        links: data.links || []
      };
      
      console.log(`[OpenLibrary] ‚úÖ Work r√©cup√©r√©: ${result.title} (ISBN: ${isbn || 'N/A'}, Auteurs: ${authors.length})`);
      setCache(cacheKey, result);
      return result;
    }
    
    // Format edition - Format Harmonis√©
    // Construire le tableau d'images
    const images = data.covers ? data.covers.slice(0, 3).map(id => 
      `https://covers.openlibrary.org/b/id/${id}-L.jpg`
    ) : [];
    if (data.covers && data.covers[0]) {
      images.push(`https://covers.openlibrary.org/b/id/${data.covers[0]}-M.jpg`);
    }
    
    // ISBN
    const isbn = data.isbn_13?.[0] || data.isbn_10?.[0] || null;
    
    // Synopsis
    const synopsis = typeof data.description === 'string' ? data.description : data.description?.value || null;
    
    // Langues
    const languages = data.languages ? data.languages.map(l => l.key?.replace('/languages/', '')) : [];
    
    // === ENRICHISSEMENT : R√©cup√©rer les auteurs depuis le work parent ===
    let authors = [];
    if (data.works && data.works[0]?.key) {
      try {
        const workResp = await fetch(`${OPENLIBRARY_BASE_URL}${data.works[0].key}.json`, {
          headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
        });
        if (workResp.ok) {
          const workData = await workResp.json();
          if (workData.authors && workData.authors.length > 0) {
            const authorPromises = workData.authors.slice(0, 5).map(async (authorRef) => {
              const authorKey = authorRef.author?.key || authorRef.key;
              if (!authorKey) return null;
              try {
                const authorResp = await fetch(`${OPENLIBRARY_BASE_URL}${authorKey}.json`, {
                  headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
                });
                if (authorResp.ok) {
                  const authorData = await authorResp.json();
                  return authorData.name || authorData.personal_name || null;
                }
              } catch (e) {}
              return null;
            });
            const authorResults = await Promise.all(authorPromises);
            authors = authorResults.filter(Boolean);
          }
        }
      } catch (e) {
        console.log(`[OpenLibrary] Erreur r√©cup√©ration work parent: ${e.message}`);
      }
    }
    
    const result = {
      id: olId,
      type: "edition",
      title: data.title || null,
      originalTitle: null,
      authors: authors,
      editors: data.publishers || [],
      releaseDate: data.publish_date || null,
      genres: [],
      pages: data.number_of_pages || null,
      serie: null,
      synopsis: synopsis,
      language: languages[0] || null,
      tome: null,
      image: images,
      isbn: isbn,
      price: null,
      url: `https://openlibrary.org/books/${olId}`,
      source: "openlibrary",
      // Champs additionnels sp√©cifiques √† l'√©dition
      physicalFormat: data.physical_format || null,
      workKey: data.works?.[0]?.key || null,
      allLanguages: languages
    };
    
    console.log(`[OpenLibrary] ‚úÖ Edition r√©cup√©r√©e: ${result.title} (ISBN: ${isbn || 'N/A'})`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.openlibrary.errors++;
    throw err;
  }
}


// -----------------------------
// Fonctions TVDB (API TV/Films)
// -----------------------------

/**
 * Obtient un token d'acc√®s TVDB
 * Token valide ~1 mois
 */
async function getTvdbToken(apiKey) {
  if (tvdbTokenCache.token && Date.now() < tvdbTokenCache.expiresAt) {
    console.log(`[TVDB] Utilisation du token en cache`);
    return tvdbTokenCache.token;
  }
  
  console.log(`[TVDB] Obtention d'un nouveau token...`);
  
  try {
    const response = await fetch(`${TVDB_BASE_URL}/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({ apikey: apiKey })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur login TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    // Le token TVDB est valide ~1 mois, on le cache pour 25 jours
    tvdbTokenCache.token = data.data.token;
    tvdbTokenCache.expiresAt = Date.now() + (25 * 24 * 60 * 60 * 1000);
    
    console.log(`[TVDB] ‚úÖ Token obtenu, expire dans 25 jours`);
    return data.data.token;
    
  } catch (err) {
    console.error(`[TVDB] Erreur login:`, err.message);
    throw err;
  }
}

/**
 * Recherche sur TVDB (s√©ries, films, personnes, compagnies)
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Cl√© API TVDB
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchTvdb(query, apiKey, options = {}) {
  const {
    max = TVDB_DEFAULT_MAX,
    type = null,      // series, movie, person, company
    lang = null,      // Code langue (fra, eng, etc.)
    year = null       // Ann√©e de sortie
  } = options;
  
  const cacheKey = `tvdb_search_${query}_${max}_${type}_${lang}_${year}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TVDB] Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TVDB] Recherche: "${query}" (type: ${type || 'all'}, lang: ${lang || 'default'}, max: ${max})`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    const params = new URLSearchParams({ query });
    if (type) params.append('type', type);
    if (lang) params.append('language', lang);
    if (year) params.append('year', year);
    params.append('limit', Math.min(max, TVDB_MAX_LIMIT));
    
    const url = `${TVDB_BASE_URL}/search?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.data || []).slice(0, max).map(item => ({
      id: item.tvdb_id || item.id,
      type: item.type || null,
      name: item.name || item.title,
      slug: item.slug,
      year: item.year || (item.first_air_time ? new Date(item.first_air_time).getFullYear() : null),
      overview: item.overview || null,
      overviews: item.overviews || null,  // Traductions disponibles
      primaryLanguage: item.primary_language || null,
      status: item.status || null,
      network: item.network || null,
      country: item.country || null,
      thumbnail: item.thumbnail || item.image_url || null,
      image: item.image || item.image_url || null,
      aliases: item.aliases || [],
      objectID: item.objectID,
      url: item.type === 'series' 
        ? `https://thetvdb.com/series/${item.slug}`
        : item.type === 'movie'
        ? `https://thetvdb.com/movies/${item.slug}`
        : `https://thetvdb.com/search?query=${encodeURIComponent(item.name || query)}`,
      source: "tvdb"
    }));
    
    const result = {
      query,
      type: type || 'all',
      total: results.length,
      results,
      source: "tvdb"
    };
    
    console.log(`[TVDB] ‚úÖ ${results.length} r√©sultat(s) trouv√©(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'une s√©rie TVDB par ID
 */
async function getTvdbSeriesById(id, apiKey, lang = null) {
  const cacheKey = `tvdb_series_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TVDB] Cache hit: series ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TVDB] R√©cup√©ration s√©rie: ${id}`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    // R√©cup√®re les infos √©tendues
    const url = `${TVDB_BASE_URL}/series/${id}/extended`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`S√©rie TVDB ${id} non trouv√©e`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const series = data.data;
    
    // R√©cup√®re les traductions si langue sp√©cifi√©e
    let translations = null;
    if (lang) {
      try {
        const transResponse = await fetch(`${TVDB_BASE_URL}/series/${id}/translations/${lang}`, {
          headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json' }
        });
        if (transResponse.ok) {
          const transData = await transResponse.json();
          translations = transData.data;
        }
      } catch (e) {
        console.log(`[TVDB] Pas de traduction ${lang} pour s√©rie ${id}`);
      }
    }
    
    const result = {
      id: series.id,
      type: 'series',
      name: translations?.name || series.name,
      originalName: series.name,
      slug: series.slug,
      overview: translations?.overview || series.overview,
      firstAired: series.firstAired,
      lastAired: series.lastAired,
      nextAired: series.nextAired,
      status: series.status?.name || null,
      year: series.year,
      averageRuntime: series.averageRuntime,
      score: series.score,
      originalCountry: series.originalCountry,
      originalLanguage: series.originalLanguage,
      defaultSeasonType: series.defaultSeasonType,
      isOrderRandomized: series.isOrderRandomized,
      lastUpdated: series.lastUpdated,
      
      // Images
      image: series.image,
      artworks: series.artworks?.slice(0, 20).map(a => ({
        id: a.id,
        type: a.type,
        image: a.image,
        thumbnail: a.thumbnail,
        language: a.language,
        score: a.score
      })) || [],
      
      // Genres
      genres: series.genres?.map(g => ({
        id: g.id,
        name: g.name,
        slug: g.slug
      })) || [],
      
      // Personnages principaux
      characters: series.characters?.slice(0, 30).map(c => ({
        id: c.id,
        name: c.name,
        peopleId: c.peopleId,
        personName: c.personName,
        image: c.image,
        type: c.type,
        sort: c.sort
      })) || [],
      
      // Saisons
      seasons: series.seasons?.map(s => ({
        id: s.id,
        number: s.number,
        name: s.name,
        type: s.type?.name,
        image: s.image
      })) || [],
      
      // R√©seaux/Plateformes
      companies: series.companies?.map(c => ({
        id: c.id,
        name: c.name,
        slug: c.slug,
        country: c.country,
        activeDate: c.activeDate,
        companyType: c.companyType?.name
      })) || [],
      
      // Contenu associ√©
      remoteIds: series.remoteIds || [],
      trailers: series.trailers?.map(t => ({
        id: t.id,
        name: t.name,
        url: t.url,
        runtime: t.runtime,
        language: t.language
      })) || [],
      
      lists: series.lists?.slice(0, 10).map(l => ({
        id: l.id,
        name: l.name,
        overview: l.overview,
        url: l.url
      })) || [],
      
      contentRatings: series.contentRatings || [],
      
      url: `https://thetvdb.com/series/${series.slug}`,
      source: "tvdb"
    };
    
    console.log(`[TVDB] ‚úÖ S√©rie r√©cup√©r√©e: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un film TVDB par ID
 */
async function getTvdbMovieById(id, apiKey, lang = null) {
  const cacheKey = `tvdb_movie_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TVDB] Cache hit: movie ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TVDB] R√©cup√©ration film: ${id}`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    const url = `${TVDB_BASE_URL}/movies/${id}/extended`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Film TVDB ${id} non trouv√©`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const movie = data.data;
    
    // R√©cup√®re les traductions si langue sp√©cifi√©e
    let translations = null;
    if (lang) {
      try {
        const transResponse = await fetch(`${TVDB_BASE_URL}/movies/${id}/translations/${lang}`, {
          headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json' }
        });
        if (transResponse.ok) {
          const transData = await transResponse.json();
          translations = transData.data;
        }
      } catch (e) {
        console.log(`[TVDB] Pas de traduction ${lang} pour film ${id}`);
      }
    }
    
    const result = {
      id: movie.id,
      type: 'movie',
      name: translations?.name || movie.name,
      originalName: movie.name,
      slug: movie.slug,
      overview: translations?.overview || movie.overview,
      year: movie.year,
      runtime: movie.runtime,
      score: movie.score,
      status: movie.status?.name || null,
      originalCountry: movie.originalCountry,
      originalLanguage: movie.originalLanguage,
      lastUpdated: movie.lastUpdated,
      
      // Dates de sortie
      releases: movie.releases?.map(r => ({
        country: r.country,
        date: r.date,
        detail: r.detail
      })) || [],
      
      // Images
      image: movie.image,
      artworks: movie.artworks?.slice(0, 20).map(a => ({
        id: a.id,
        type: a.type,
        image: a.image,
        thumbnail: a.thumbnail,
        language: a.language,
        score: a.score
      })) || [],
      
      // Genres
      genres: movie.genres?.map(g => ({
        id: g.id,
        name: g.name,
        slug: g.slug
      })) || [],
      
      // Personnages
      characters: movie.characters?.slice(0, 30).map(c => ({
        id: c.id,
        name: c.name,
        peopleId: c.peopleId,
        personName: c.personName,
        image: c.image,
        type: c.type
      })) || [],
      
      // Studios/Producteurs
      companies: movie.companies?.map(c => ({
        id: c.id,
        name: c.name,
        slug: c.slug,
        country: c.country,
        companyType: c.companyType?.name
      })) || [],
      
      // Box office
      boxOffice: movie.boxOffice,
      boxOfficeUS: movie.boxOfficeUS,
      budget: movie.budget,
      
      // Trailers
      trailers: movie.trailers?.map(t => ({
        id: t.id,
        name: t.name,
        url: t.url,
        runtime: t.runtime,
        language: t.language
      })) || [],
      
      remoteIds: movie.remoteIds || [],
      contentRatings: movie.contentRatings || [],
      
      url: `https://thetvdb.com/movies/${movie.slug}`,
      source: "tvdb"
    };
    
    console.log(`[TVDB] ‚úÖ Film r√©cup√©r√©: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

// -----------------------------
// Fonctions TMDB (API TV/Films)
// -----------------------------

/**
 * Recherche multi sur TMDB (films, s√©ries, personnes)
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Cl√© API TMDB
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchTmdb(query, apiKey, options = {}) {
  const {
    max = TMDB_DEFAULT_MAX,
    type = null,      // movie, tv, person, multi (d√©faut)
    lang = 'fr-FR',   // Code langue ISO 639-1 + pays
    page = 1,
    year = null,
    includeAdult = false
  } = options;
  
  const searchType = type || 'multi';
  const cacheKey = `tmdb_search_${query}_${searchType}_${max}_${lang}_${page}_${year}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TMDB] Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TMDB] Recherche: "${query}" (type: ${searchType}, lang: ${lang}, page: ${page})`);
  metrics.sources.tmdb.requests++;
  
  try {
    const params = new URLSearchParams({
      api_key: apiKey,
      query: query,
      language: lang,
      page: page,
      include_adult: includeAdult
    });
    
    // Param√®tres sp√©cifiques selon le type
    if (year) {
      if (searchType === 'movie') {
        params.append('primary_release_year', year);
      } else if (searchType === 'tv') {
        params.append('first_air_date_year', year);
      } else if (searchType === 'multi') {
        params.append('year', year);
      }
    }
    
    const url = `${TMDB_BASE_URL}/search/${searchType}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.results || []).slice(0, max).map(item => {
      const mediaType = item.media_type || searchType;
      const isMovie = mediaType === 'movie';
      const isTv = mediaType === 'tv';
      const isPerson = mediaType === 'person';
      
      return {
        id: item.id,
        mediaType: mediaType,
        title: item.title || item.name,
        originalTitle: item.original_title || item.original_name,
        overview: item.overview || null,
        releaseDate: item.release_date || item.first_air_date || null,
        year: (item.release_date || item.first_air_date) 
          ? new Date(item.release_date || item.first_air_date).getFullYear() 
          : null,
        popularity: item.popularity,
        voteAverage: item.vote_average,
        voteCount: item.vote_count,
        originalLanguage: item.original_language,
        genreIds: item.genre_ids || [],
        adult: item.adult || false,
        
        // Images
        poster: item.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${item.poster_path}` : null,
        posterSmall: item.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${item.poster_path}` : null,
        backdrop: item.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${item.backdrop_path}` : null,
        
        // Sp√©cifique aux personnes
        profilePath: isPerson && item.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${item.profile_path}` : null,
        knownFor: isPerson ? (item.known_for || []).map(k => ({
          id: k.id,
          mediaType: k.media_type,
          title: k.title || k.name,
          poster: k.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${k.poster_path}` : null
        })) : null,
        knownForDepartment: item.known_for_department || null,
        
        // Sp√©cifique aux s√©ries
        originCountry: isTv ? item.origin_country : null,
        
        url: isMovie 
          ? `https://www.themoviedb.org/movie/${item.id}`
          : isTv 
          ? `https://www.themoviedb.org/tv/${item.id}`
          : `https://www.themoviedb.org/person/${item.id}`,
        source: "tmdb"
      };
    });
    
    const result = {
      query,
      searchType,
      page: data.page,
      totalPages: data.total_pages,
      totalResults: data.total_results,
      resultsOnPage: results.length,
      results,
      source: "tmdb"
    };
    
    console.log(`[TMDB] ‚úÖ ${results.length} r√©sultat(s) sur ${data.total_results} total`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un film TMDB par ID
 */
async function getTmdbMovieById(id, apiKey, lang = 'fr-FR') {
  const cacheKey = `tmdb_movie_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TMDB] Cache hit: movie ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TMDB] R√©cup√©ration film: ${id}`);
  metrics.sources.tmdb.requests++;
  
  try {
    // R√©cup√®re le film avec credits et videos
    const params = new URLSearchParams({
      api_key: apiKey,
      language: lang,
      append_to_response: 'credits,videos,keywords,recommendations,similar,external_ids,release_dates'
    });
    
    const url = `${TMDB_BASE_URL}/movie/${id}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Film TMDB ${id} non trouv√©`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const movie = await response.json();
    
    const result = {
      id: movie.id,
      type: 'movie',
      imdbId: movie.imdb_id,
      title: movie.title,
      originalTitle: movie.original_title,
      tagline: movie.tagline,
      overview: movie.overview,
      releaseDate: movie.release_date,
      year: movie.release_date ? new Date(movie.release_date).getFullYear() : null,
      runtime: movie.runtime,
      status: movie.status,
      adult: movie.adult,
      video: movie.video,
      
      // Scores
      popularity: movie.popularity,
      voteAverage: movie.vote_average,
      voteCount: movie.vote_count,
      
      // Langues & pays
      originalLanguage: movie.original_language,
      spokenLanguages: movie.spoken_languages?.map(l => ({
        code: l.iso_639_1,
        name: l.name,
        englishName: l.english_name
      })) || [],
      productionCountries: movie.production_countries?.map(c => ({
        code: c.iso_3166_1,
        name: c.name
      })) || [],
      
      // Finances
      budget: movie.budget,
      revenue: movie.revenue,
      
      // Images
      poster: movie.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${movie.poster_path}` : null,
      posterOriginal: movie.poster_path ? `${TMDB_IMAGE_BASE_URL}/original${movie.poster_path}` : null,
      backdrop: movie.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${movie.backdrop_path}` : null,
      backdropOriginal: movie.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/original${movie.backdrop_path}` : null,
      
      // Genres
      genres: movie.genres?.map(g => ({ id: g.id, name: g.name })) || [],
      
      // Studios
      productionCompanies: movie.production_companies?.map(c => ({
        id: c.id,
        name: c.name,
        logo: c.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.logo_path}` : null,
        country: c.origin_country
      })) || [],
      
      // Collections
      belongsToCollection: movie.belongs_to_collection ? {
        id: movie.belongs_to_collection.id,
        name: movie.belongs_to_collection.name,
        poster: movie.belongs_to_collection.poster_path 
          ? `${TMDB_IMAGE_BASE_URL}/w500${movie.belongs_to_collection.poster_path}` : null,
        backdrop: movie.belongs_to_collection.backdrop_path
          ? `${TMDB_IMAGE_BASE_URL}/w1280${movie.belongs_to_collection.backdrop_path}` : null
      } : null,
      
      // Credits
      cast: movie.credits?.cast?.slice(0, 20).map(c => ({
        id: c.id,
        name: c.name,
        character: c.character,
        order: c.order,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      crew: movie.credits?.crew?.filter(c => 
        ['Director', 'Writer', 'Screenplay', 'Producer', 'Executive Producer', 'Original Music Composer'].includes(c.job)
      ).map(c => ({
        id: c.id,
        name: c.name,
        job: c.job,
        department: c.department,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      // Videos (bandes-annonces)
      videos: movie.videos?.results?.filter(v => v.site === 'YouTube').map(v => ({
        id: v.id,
        key: v.key,
        name: v.name,
        type: v.type,
        official: v.official,
        url: `https://www.youtube.com/watch?v=${v.key}`
      })) || [],
      
      // Mots-cl√©s
      keywords: movie.keywords?.keywords?.map(k => k.name) || [],
      
      // IDs externes
      externalIds: {
        imdb: movie.external_ids?.imdb_id,
        facebook: movie.external_ids?.facebook_id,
        instagram: movie.external_ids?.instagram_id,
        twitter: movie.external_ids?.twitter_id,
        wikidata: movie.external_ids?.wikidata_id
      },
      
      // Classifications par pays
      certifications: movie.release_dates?.results?.map(r => ({
        country: r.iso_3166_1,
        certification: r.release_dates?.[0]?.certification || null,
        releaseDate: r.release_dates?.[0]?.release_date || null
      })).filter(c => c.certification) || [],
      
      // Recommandations
      recommendations: movie.recommendations?.results?.slice(0, 10).map(r => ({
        id: r.id,
        title: r.title,
        releaseDate: r.release_date,
        voteAverage: r.vote_average,
        poster: r.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${r.poster_path}` : null
      })) || [],
      
      // Films similaires
      similar: movie.similar?.results?.slice(0, 10).map(s => ({
        id: s.id,
        title: s.title,
        releaseDate: s.release_date,
        voteAverage: s.vote_average,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null
      })) || [],
      
      homepage: movie.homepage || null,
      url: `https://www.themoviedb.org/movie/${movie.id}`,
      source: "tmdb"
    };
    
    console.log(`[TMDB] ‚úÖ Film r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'une s√©rie TV TMDB par ID
 */
async function getTmdbTvById(id, apiKey, lang = 'fr-FR') {
  const cacheKey = `tmdb_tv_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TMDB] Cache hit: tv ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TMDB] R√©cup√©ration s√©rie: ${id}`);
  metrics.sources.tmdb.requests++;
  
  try {
    const params = new URLSearchParams({
      api_key: apiKey,
      language: lang,
      append_to_response: 'credits,videos,keywords,recommendations,similar,external_ids,content_ratings'
    });
    
    const url = `${TMDB_BASE_URL}/tv/${id}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`S√©rie TMDB ${id} non trouv√©e`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const tv = await response.json();
    
    const result = {
      id: tv.id,
      type: 'tv',
      name: tv.name,
      originalName: tv.original_name,
      tagline: tv.tagline,
      overview: tv.overview,
      firstAirDate: tv.first_air_date,
      lastAirDate: tv.last_air_date,
      year: tv.first_air_date ? new Date(tv.first_air_date).getFullYear() : null,
      status: tv.status,
      tvType: tv.type,
      inProduction: tv.in_production,
      adult: tv.adult,
      
      // √âpisodes
      numberOfSeasons: tv.number_of_seasons,
      numberOfEpisodes: tv.number_of_episodes,
      episodeRunTime: tv.episode_run_time || [],
      
      // Derniers √©pisodes
      lastEpisodeToAir: tv.last_episode_to_air ? {
        id: tv.last_episode_to_air.id,
        name: tv.last_episode_to_air.name,
        overview: tv.last_episode_to_air.overview,
        airDate: tv.last_episode_to_air.air_date,
        seasonNumber: tv.last_episode_to_air.season_number,
        episodeNumber: tv.last_episode_to_air.episode_number,
        voteAverage: tv.last_episode_to_air.vote_average
      } : null,
      nextEpisodeToAir: tv.next_episode_to_air ? {
        id: tv.next_episode_to_air.id,
        name: tv.next_episode_to_air.name,
        overview: tv.next_episode_to_air.overview,
        airDate: tv.next_episode_to_air.air_date,
        seasonNumber: tv.next_episode_to_air.season_number,
        episodeNumber: tv.next_episode_to_air.episode_number
      } : null,
      
      // Scores
      popularity: tv.popularity,
      voteAverage: tv.vote_average,
      voteCount: tv.vote_count,
      
      // Langues & pays
      originalLanguage: tv.original_language,
      languages: tv.languages || [],
      originCountry: tv.origin_country || [],
      spokenLanguages: tv.spoken_languages?.map(l => ({
        code: l.iso_639_1,
        name: l.name,
        englishName: l.english_name
      })) || [],
      productionCountries: tv.production_countries?.map(c => ({
        code: c.iso_3166_1,
        name: c.name
      })) || [],
      
      // Images
      poster: tv.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${tv.poster_path}` : null,
      posterOriginal: tv.poster_path ? `${TMDB_IMAGE_BASE_URL}/original${tv.poster_path}` : null,
      backdrop: tv.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${tv.backdrop_path}` : null,
      backdropOriginal: tv.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/original${tv.backdrop_path}` : null,
      
      // Genres
      genres: tv.genres?.map(g => ({ id: g.id, name: g.name })) || [],
      
      // R√©seaux de diffusion
      networks: tv.networks?.map(n => ({
        id: n.id,
        name: n.name,
        logo: n.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${n.logo_path}` : null,
        country: n.origin_country
      })) || [],
      
      // Studios
      productionCompanies: tv.production_companies?.map(c => ({
        id: c.id,
        name: c.name,
        logo: c.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.logo_path}` : null,
        country: c.origin_country
      })) || [],
      
      // Cr√©ateurs
      createdBy: tv.created_by?.map(c => ({
        id: c.id,
        name: c.name,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      // Saisons
      seasons: tv.seasons?.map(s => ({
        id: s.id,
        name: s.name,
        overview: s.overview,
        seasonNumber: s.season_number,
        episodeCount: s.episode_count,
        airDate: s.air_date,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null,
        voteAverage: s.vote_average
      })) || [],
      
      // Credits
      cast: tv.credits?.cast?.slice(0, 20).map(c => ({
        id: c.id,
        name: c.name,
        character: c.character,
        order: c.order,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      crew: tv.credits?.crew?.filter(c => 
        ['Executive Producer', 'Creator', 'Original Music Composer', 'Director of Photography'].includes(c.job)
      ).map(c => ({
        id: c.id,
        name: c.name,
        job: c.job,
        department: c.department,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      // Videos
      videos: tv.videos?.results?.filter(v => v.site === 'YouTube').map(v => ({
        id: v.id,
        key: v.key,
        name: v.name,
        type: v.type,
        official: v.official,
        url: `https://www.youtube.com/watch?v=${v.key}`
      })) || [],
      
      // Mots-cl√©s
      keywords: tv.keywords?.results?.map(k => k.name) || [],
      
      // IDs externes
      externalIds: {
        imdb: tv.external_ids?.imdb_id,
        tvdb: tv.external_ids?.tvdb_id,
        facebook: tv.external_ids?.facebook_id,
        instagram: tv.external_ids?.instagram_id,
        twitter: tv.external_ids?.twitter_id,
        wikidata: tv.external_ids?.wikidata_id
      },
      
      // Classifications
      contentRatings: tv.content_ratings?.results?.map(r => ({
        country: r.iso_3166_1,
        rating: r.rating
      })) || [],
      
      // Recommandations
      recommendations: tv.recommendations?.results?.slice(0, 10).map(r => ({
        id: r.id,
        name: r.name,
        firstAirDate: r.first_air_date,
        voteAverage: r.vote_average,
        poster: r.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${r.poster_path}` : null
      })) || [],
      
      // S√©ries similaires
      similar: tv.similar?.results?.slice(0, 10).map(s => ({
        id: s.id,
        name: s.name,
        firstAirDate: s.first_air_date,
        voteAverage: s.vote_average,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null
      })) || [],
      
      homepage: tv.homepage || null,
      url: `https://www.themoviedb.org/tv/${tv.id}`,
      source: "tmdb"
    };
    
    console.log(`[TMDB] ‚úÖ S√©rie r√©cup√©r√©e: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

// ======================================================
// IMDB API Functions (via imdbapi.dev - NO API KEY NEEDED)
// ======================================================

/**
 * Recherche de titres sur IMDB via imdbapi.dev
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchImdb(query, options = {}) {
  const {
    max = IMDB_DEFAULT_MAX
  } = options;
  
  // Limiter max au maximum autoris√©
  const limit = Math.min(max, IMDB_MAX_LIMIT);
  
  const cacheKey = `imdb_search_${query}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[IMDB] Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[IMDB] Recherche: "${query}" (limit: ${limit})`);
  metrics.sources.imdb.requests++;
  
  try {
    const params = new URLSearchParams({
      query: query,
      limit: limit
    });
    
    const url = `${IMDB_BASE_URL}/search/titles?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.titles || []).map(item => ({
      id: item.id,
      type: item.type,
      title: item.primaryTitle,
      originalTitle: item.originalTitle,
      year: item.startYear,
      endYear: item.endYear || null,
      runtimeMinutes: item.runtimeSeconds ? Math.round(item.runtimeSeconds / 60) : null,
      genres: item.genres || [],
      rating: item.rating ? {
        average: item.rating.aggregateRating,
        votes: item.rating.voteCount
      } : null,
      poster: item.primaryImage?.url || null,
      posterWidth: item.primaryImage?.width || null,
      posterHeight: item.primaryImage?.height || null,
      isAdult: item.isAdult || false,
      url: `https://www.imdb.com/title/${item.id}/`,
      source: "imdb"
    }));
    
    const result = {
      query,
      resultsCount: results.length,
      results,
      source: "imdb"
    };
    
    console.log(`[IMDB] ‚úÖ ${results.length} r√©sultat(s) trouv√©(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un titre IMDB par ID
 * @param {string} titleId - ID IMDB (format: tt1234567)
 * @returns {Promise<object>} - D√©tails du titre
 */
async function getImdbTitleById(titleId) {
  const cacheKey = `imdb_title_${titleId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[IMDB] Cache hit: title ${titleId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[IMDB] R√©cup√©ration titre: ${titleId}`);
  metrics.sources.imdb.requests++;
  
  try {
    const url = `${IMDB_BASE_URL}/titles/${titleId}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404 || response.status === 5) {
        throw new Error(`Titre IMDB ${titleId} non trouv√©`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const title = await response.json();
    
    // V√©rifier si erreur dans la r√©ponse
    if (title.code === 5 || title.message === 'Not Found') {
      throw new Error(`Titre IMDB ${titleId} non trouv√©`);
    }
    
    const result = {
      id: title.id,
      type: title.type,
      title: title.primaryTitle,
      originalTitle: title.originalTitle || title.primaryTitle,
      year: title.startYear,
      endYear: title.endYear || null,
      runtimeMinutes: title.runtimeSeconds ? Math.round(title.runtimeSeconds / 60) : null,
      isAdult: title.isAdult || false,
      
      // Rating
      rating: title.rating ? {
        average: title.rating.aggregateRating,
        votes: title.rating.voteCount
      } : null,
      
      // Metacritic
      metacritic: title.metacritic ? {
        score: title.metacritic.score,
        reviewCount: title.metacritic.reviewCount
      } : null,
      
      // Plot
      plot: title.plot || null,
      
      // Genres
      genres: title.genres || [],
      
      // Image
      poster: title.primaryImage?.url || null,
      posterWidth: title.primaryImage?.width || null,
      posterHeight: title.primaryImage?.height || null,
      
      // Credits
      directors: (title.directors || []).map(d => ({
        id: d.id,
        name: d.displayName,
        alternativeNames: d.alternativeNames || [],
        image: d.primaryImage?.url || null,
        professions: d.primaryProfessions || []
      })),
      
      writers: (title.writers || []).map(w => ({
        id: w.id,
        name: w.displayName,
        alternativeNames: w.alternativeNames || [],
        image: w.primaryImage?.url || null,
        professions: w.primaryProfessions || []
      })),
      
      stars: (title.stars || []).map(s => ({
        id: s.id,
        name: s.displayName,
        alternativeNames: s.alternativeNames || [],
        image: s.primaryImage?.url || null,
        professions: s.primaryProfessions || []
      })),
      
      // Origin
      originCountries: (title.originCountries || []).map(c => ({
        code: c.code,
        name: c.name
      })),
      
      spokenLanguages: (title.spokenLanguages || []).map(l => ({
        code: l.code,
        name: l.name
      })),
      
      // Interests/Tags
      interests: (title.interests || []).filter(i => !i.isSubgenre).map(i => ({
        id: i.id,
        name: i.name
      })),
      subgenres: (title.interests || []).filter(i => i.isSubgenre).map(i => ({
        id: i.id,
        name: i.name
      })),
      
      url: `https://www.imdb.com/title/${title.id}/`,
      source: "imdb"
    };
    
    console.log(`[IMDB] ‚úÖ Titre r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

/**
 * Liste/Browse des titres IMDB avec filtres
 * @param {object} options - Options de filtrage
 * @returns {Promise<object>} - Liste de titres
 */
async function browseImdbTitles(options = {}) {
  const {
    types = [],           // MOVIE, TV_SERIES, TV_MINI_SERIES, TV_SPECIAL, TV_MOVIE, SHORT, VIDEO, VIDEO_GAME
    genres = [],          // Action, Comedy, Drama, etc.
    startYear = null,     // Ann√©e de d√©but
    endYear = null,       // Ann√©e de fin
    minRating = null,     // Note minimum (0-10)
    maxRating = null,     // Note maximum (0-10)
    sortBy = 'SORT_BY_POPULARITY',  // SORT_BY_POPULARITY, SORT_BY_RELEASE_DATE, SORT_BY_USER_RATING, SORT_BY_USER_RATING_COUNT, SORT_BY_YEAR
    sortOrder = 'DESC',   // ASC, DESC
    pageToken = null,     // Token de pagination
    limit = IMDB_DEFAULT_MAX
  } = options;
  
  // Construire une cl√© de cache unique
  const cacheKey = `imdb_browse_${types.join(',')}_${genres.join(',')}_${startYear}_${endYear}_${minRating}_${maxRating}_${sortBy}_${sortOrder}_${pageToken}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[IMDB] Cache hit: browse`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[IMDB] Browse titles: types=${types.join(',')}, genres=${genres.join(',')}, years=${startYear}-${endYear}`);
  metrics.sources.imdb.requests++;
  
  try {
    const params = new URLSearchParams();
    
    // Types
    if (types.length > 0) {
      types.forEach(t => params.append('types', t));
    }
    
    // Genres
    if (genres.length > 0) {
      genres.forEach(g => params.append('genres', g));
    }
    
    // Ann√©es
    if (startYear) params.append('startYear', startYear);
    if (endYear) params.append('endYear', endYear);
    
    // Rating
    if (minRating !== null) params.append('minAggregateRating', minRating);
    if (maxRating !== null) params.append('maxAggregateRating', maxRating);
    
    // Tri
    params.append('sortBy', sortBy);
    params.append('sortOrder', sortOrder);
    
    // Pagination
    if (pageToken) params.append('pageToken', pageToken);
    
    const url = `${IMDB_BASE_URL}/titles?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    // Limiter les r√©sultats
    const titles = (data.titles || []).slice(0, limit);
    
    const results = titles.map(item => ({
      id: item.id,
      type: item.type,
      title: item.primaryTitle,
      originalTitle: item.originalTitle,
      year: item.startYear,
      endYear: item.endYear || null,
      runtimeMinutes: item.runtimeSeconds ? Math.round(item.runtimeSeconds / 60) : null,
      genres: item.genres || [],
      rating: item.rating ? {
        average: item.rating.aggregateRating,
        votes: item.rating.voteCount
      } : null,
      plot: item.plot || null,
      poster: item.primaryImage?.url || null,
      isAdult: item.isAdult || false,
      url: `https://www.imdb.com/title/${item.id}/`,
      source: "imdb"
    }));
    
    const result = {
      filters: {
        types: types.length > 0 ? types : 'all',
        genres: genres.length > 0 ? genres : 'all',
        years: {
          start: startYear || 'any',
          end: endYear || 'any'
        },
        rating: {
          min: minRating || 'any',
          max: maxRating || 'any'
        },
        sortBy,
        sortOrder
      },
      totalCount: data.totalCount || null,
      resultsCount: results.length,
      nextPageToken: data.nextPageToken || null,
      results,
      source: "imdb"
    };
    
    console.log(`[IMDB] ‚úÖ ${results.length} titre(s) trouv√©(s) sur ${data.totalCount || '?'} total`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

// ======================================================
// Jikan API Functions (MyAnimeList - NO API KEY NEEDED)
// ======================================================

/**
 * Recherche d'anime sur Jikan (MyAnimeList)
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchJikanAnime(query, options = {}) {
  const {
    max = JIKAN_DEFAULT_MAX,
    page = 1,
    type = null,        // tv, movie, ova, special, ona, music
    status = null,      // airing, complete, upcoming
    rating = null,      // g, pg, pg13, r17, r, rx
    orderBy = null,     // mal_id, title, start_date, end_date, episodes, score, scored_by, rank, popularity, members, favorites
    sort = null         // asc, desc
  } = options;
  
  const limit = Math.min(max, JIKAN_MAX_LIMIT);
  
  const cacheKey = `jikan_anime_${query}_${limit}_${page}_${type}_${status}_${rating}_${orderBy}_${sort}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Jikan] Cache hit: anime ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Jikan] Recherche anime: "${query}" (limit: ${limit}, page: ${page})`);
  metrics.sources.jikan.requests++;
  
  try {
    const params = new URLSearchParams({
      q: query,
      limit: limit,
      page: page
    });
    
    if (type) params.append('type', type);
    if (status) params.append('status', status);
    if (rating) params.append('rating', rating);
    if (orderBy) params.append('order_by', orderBy);
    if (sort) params.append('sort', sort);
    
    const url = `${JIKAN_BASE_URL}/anime?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur Jikan ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.data || []).map(item => ({
      id: item.mal_id,
      type: item.type,
      title: item.title,
      titleEnglish: item.title_english || null,
      titleJapanese: item.title_japanese || null,
      titles: (item.titles || []).map(t => ({ type: t.type, title: t.title })),
      episodes: item.episodes,
      status: item.status,
      airing: item.airing,
      aired: item.aired ? {
        from: item.aired.from,
        to: item.aired.to,
        string: item.aired.string
      } : null,
      duration: item.duration,
      rating: item.rating,
      score: item.score,
      scoredBy: item.scored_by,
      rank: item.rank,
      popularity: item.popularity,
      members: item.members,
      favorites: item.favorites,
      synopsis: item.synopsis,
      background: item.background,
      season: item.season,
      year: item.year,
      studios: (item.studios || []).map(s => ({ id: s.mal_id, name: s.name })),
      genres: (item.genres || []).map(g => ({ id: g.mal_id, name: g.name })),
      themes: (item.themes || []).map(t => ({ id: t.mal_id, name: t.name })),
      demographics: (item.demographics || []).map(d => ({ id: d.mal_id, name: d.name })),
      image: item.images?.jpg?.large_image_url || item.images?.jpg?.image_url || null,  // Alias standard
      poster: item.images?.jpg?.large_image_url || item.images?.jpg?.image_url || null,
      posterSmall: item.images?.jpg?.small_image_url || null,
      trailer: item.trailer?.url || null,
      url: item.url,
      source: "jikan_anime"
    }));
    
    const result = {
      query,
      pagination: {
        currentPage: data.pagination?.current_page || page,
        lastPage: data.pagination?.last_visible_page || 1,
        hasNextPage: data.pagination?.has_next_page || false,
        totalResults: data.pagination?.items?.total || results.length
      },
      resultsCount: results.length,
      results,
      source: "jikan_anime"
    };
    
    console.log(`[Jikan] ‚úÖ ${results.length} anime(s) trouv√©(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.jikan.errors++;
    throw err;
  }
}

/**
 * Recherche de manga sur Jikan (MyAnimeList)
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchJikanManga(query, options = {}) {
  const {
    max = JIKAN_DEFAULT_MAX,
    page = 1,
    type = null,        // manga, novel, lightnovel, oneshot, doujin, manhwa, manhua
    status = null,      // publishing, complete, hiatus, discontinued, upcoming
    orderBy = null,     // mal_id, title, start_date, end_date, chapters, volumes, score, scored_by, rank, popularity, members, favorites
    sort = null         // asc, desc
  } = options;
  
  const limit = Math.min(max, JIKAN_MAX_LIMIT);
  
  const cacheKey = `jikan_manga_${query}_${limit}_${page}_${type}_${status}_${orderBy}_${sort}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Jikan] Cache hit: manga ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Jikan] Recherche manga: "${query}" (limit: ${limit}, page: ${page})`);
  metrics.sources.jikan.requests++;
  
  try {
    const params = new URLSearchParams({
      q: query,
      limit: limit,
      page: page
    });
    
    if (type) params.append('type', type);
    if (status) params.append('status', status);
    if (orderBy) params.append('order_by', orderBy);
    if (sort) params.append('sort', sort);
    
    const url = `${JIKAN_BASE_URL}/manga?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur Jikan ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.data || []).map(item => ({
      id: item.mal_id,
      type: item.type,
      // === Format harmonis√© livres ===
      title: item.title,
      originalTitle: item.title_japanese || null,
      authors: (item.authors || []).map(a => a.name),
      editors: (item.serializations || []).map(s => s.name),
      releaseDate: item.published?.from || null,
      genres: (item.genres || []).map(g => g.name),
      pages: null,
      serie: null,
      synopsis: item.synopsis,
      language: 'ja',
      tome: item.volumes || null,
      image: [item.images?.jpg?.large_image_url, item.images?.jpg?.image_url, item.images?.jpg?.small_image_url].filter(Boolean),
      isbn: null,
      price: null,
      score: item.score,
      status: item.status,
      url: item.url,
      source: "jikan_manga"
    }));
    
    const result = {
      query,
      pagination: {
        currentPage: data.pagination?.current_page || page,
        lastPage: data.pagination?.last_visible_page || 1,
        hasNextPage: data.pagination?.has_next_page || false,
        totalResults: data.pagination?.items?.total || results.length
      },
      resultsCount: results.length,
      results,
      source: "jikan_manga"
    };
    
    console.log(`[Jikan] ‚úÖ ${results.length} manga(s) trouv√©(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.jikan.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un anime par ID MyAnimeList
 * @param {number} animeId - ID MyAnimeList de l'anime
 * @returns {Promise<object>} - D√©tails de l'anime
 */
async function getJikanAnimeById(animeId) {
  const cacheKey = `jikan_anime_detail_${animeId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Jikan] Cache hit: anime detail ${animeId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Jikan] R√©cup√©ration anime: ${animeId}`);
  metrics.sources.jikan.requests++;
  
  try {
    const url = `${JIKAN_BASE_URL}/anime/${animeId}/full`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Anime ${animeId} non trouv√© sur MyAnimeList`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur Jikan ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const item = data.data;
    
    const result = {
      id: item.mal_id,
      type: item.type,
      title: item.title,
      titleEnglish: item.title_english || null,
      titleJapanese: item.title_japanese || null,
      titles: (item.titles || []).map(t => ({ type: t.type, title: t.title })),
      episodes: item.episodes,
      status: item.status,
      airing: item.airing,
      aired: item.aired ? {
        from: item.aired.from,
        to: item.aired.to,
        string: item.aired.string
      } : null,
      duration: item.duration,
      rating: item.rating,
      score: item.score,
      scoredBy: item.scored_by,
      rank: item.rank,
      popularity: item.popularity,
      members: item.members,
      favorites: item.favorites,
      synopsis: item.synopsis,
      background: item.background,
      season: item.season,
      year: item.year,
      broadcast: item.broadcast ? {
        day: item.broadcast.day,
        time: item.broadcast.time,
        timezone: item.broadcast.timezone,
        string: item.broadcast.string
      } : null,
      producers: (item.producers || []).map(p => ({ id: p.mal_id, name: p.name, type: p.type })),
      licensors: (item.licensors || []).map(l => ({ id: l.mal_id, name: l.name })),
      studios: (item.studios || []).map(s => ({ id: s.mal_id, name: s.name })),
      source: item.source,
      genres: (item.genres || []).map(g => ({ id: g.mal_id, name: g.name })),
      themes: (item.themes || []).map(t => ({ id: t.mal_id, name: t.name })),
      demographics: (item.demographics || []).map(d => ({ id: d.mal_id, name: d.name })),
      relations: (item.relations || []).map(r => ({
        relation: r.relation,
        entries: (r.entry || []).map(e => ({ id: e.mal_id, type: e.type, name: e.name, url: e.url }))
      })),
      streaming: (item.streaming || []).map(s => ({ name: s.name, url: s.url })),
      external: (item.external || []).map(e => ({ name: e.name, url: e.url })),
      poster: item.images?.jpg?.large_image_url || item.images?.jpg?.image_url || null,
      posterSmall: item.images?.jpg?.small_image_url || null,
      trailer: item.trailer ? {
        youtubeId: item.trailer.youtube_id,
        url: item.trailer.url,
        embedUrl: item.trailer.embed_url,
        thumbnail: item.trailer.images?.maximum_image_url || item.trailer.images?.large_image_url || null
      } : null,
      url: item.url,
      dataSource: "jikan_anime"
    };
    
    console.log(`[Jikan] ‚úÖ Anime r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.jikan.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un manga par ID MyAnimeList
 * @param {number} mangaId - ID MyAnimeList du manga
 * @returns {Promise<object>} - D√©tails du manga
 */
async function getJikanMangaById(mangaId) {
  const cacheKey = `jikan_manga_detail_${mangaId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Jikan] Cache hit: manga detail ${mangaId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Jikan] R√©cup√©ration manga: ${mangaId}`);
  metrics.sources.jikan.requests++;
  
  try {
    const url = `${JIKAN_BASE_URL}/manga/${mangaId}/full`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Manga ${mangaId} non trouv√© sur MyAnimeList`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur Jikan ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const item = data.data;
    
    // Extraire les noms d'auteurs
    const authorNames = (item.authors || []).map(a => a.name);
    
    // Extraire les noms de genres
    const genreNames = (item.genres || []).map(g => g.name);
    
    // Extraire les noms de serializations (√©diteurs)
    const editorNames = (item.serializations || []).map(s => s.name);
    
    const imageUrl = item.images?.jpg?.large_image_url || item.images?.jpg?.image_url || null;
    const imageArray = [item.images?.jpg?.large_image_url, item.images?.jpg?.image_url, item.images?.jpg?.small_image_url].filter(Boolean);
    
    const result = {
      id: item.mal_id,
      type: item.type,
      title: item.title,
      originalTitle: item.title_japanese || null,
      authors: authorNames,
      editors: editorNames,
      releaseDate: item.published?.from || null,
      genres: genreNames,
      pages: null,
      serie: null,
      synopsis: item.synopsis,
      language: 'ja',
      tome: item.volumes || null,
      image: imageArray,
      isbn: null,
      price: null,
      chapters: item.chapters,
      status: item.status,
      score: item.score,
      rank: item.rank,
      popularity: item.popularity,
      url: item.url,
      source: "jikan_manga"
    };
    
    console.log(`[Jikan] ‚úÖ Manga r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.jikan.errors++;
    throw err;
  }
}

// ======================================================
// Comic Vine API Functions (Comics US)
// ======================================================

/**
 * Recherche de comics/volumes sur Comic Vine
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchComicVine(query, options = {}) {
  metrics.sources.comicvine.requests++;
  const max = Math.min(options.max || COMICVINE_DEFAULT_MAX, COMICVINE_MAX_LIMIT);
  const resourceType = options.type || 'volume'; // volume, issue, character, person
  
  const cacheKey = `comicvine_search_${resourceType}_${query}_${max}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    const params = new URLSearchParams({
      api_key: COMICVINE_API_KEY,
      format: 'json',
      query: query,
      resources: resourceType,
      limit: max.toString()
    });

    const url = `${COMICVINE_BASE_URL}/search/?${params.toString()}`;
    console.log(`[ComicVine] Recherche: ${query} (type: ${resourceType}, max: ${max})`);

    const response = await fetch(url, {
      headers: {
        'User-Agent': USER_AGENT
      }
    });

    if (!response.ok) {
      throw new Error(`Comic Vine API error: ${response.status}`);
    }

    const data = await response.json();
    
    if (data.error !== "OK") {
      throw new Error(`Comic Vine error: ${data.error}`);
    }

    const results = (data.results || []).map(item => {
      const imageArray = [item.image?.original_url, item.image?.medium_url, item.image?.thumb_url].filter(Boolean);
      
      // Structure commune pour diff√©rents types de ressources
      const result = {
        id: item.id,
        type: item.resource_type,
        title: item.name,
        originalTitle: null,
        authors: [],
        editors: item.publisher ? [item.publisher.name] : [],
        releaseDate: item.cover_date || (item.start_year ? `${item.start_year}` : null),
        genres: [],
        pages: null,
        serie: item.volume ? { id: item.volume.id, name: item.volume.name } : null,
        synopsis: item.deck || null,
        language: 'en',
        tome: item.issue_number || null,
        image: imageArray,
        isbn: null,
        price: null,
        url: item.site_detail_url,
        source: 'comicvine'
      };

      // Champs sp√©cifiques aux volumes
      if (item.resource_type === 'volume') {
        result.serie = { id: item.id, name: item.name };
        result.issueCount = item.count_of_issues;
      }

      // Champs sp√©cifiques aux issues
      if (item.resource_type === 'issue') {
        result.tome = item.issue_number;
        result.releaseDate = item.cover_date || item.store_date || null;
      }

      // Champs sp√©cifiques aux personnages
      if (item.resource_type === 'character') {
        result.realName = item.real_name;
      }

      return result;
    });

    const result = {
      query,
      resourceType,
      totalResults: data.number_of_total_results,
      pageResults: data.number_of_page_results,
      resultsCount: results.length,
      results,
      source: 'comicvine'
    };

    console.log(`[ComicVine] ‚úÖ ${results.length} r√©sultats trouv√©s`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.comicvine.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un volume Comic Vine par ID
 * @param {string|number} volumeId - ID du volume
 * @returns {Promise<object>} - D√©tails du volume
 */
async function getComicVineVolume(volumeId) {
  metrics.sources.comicvine.requests++;
  
  const cacheKey = `comicvine_volume_${volumeId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    const url = `${COMICVINE_BASE_URL}/volume/4050-${volumeId}/?api_key=${COMICVINE_API_KEY}&format=json`;
    console.log(`[ComicVine] R√©cup√©ration volume ID: ${volumeId}`);

    const response = await fetch(url, {
      headers: {
        'User-Agent': USER_AGENT
      }
    });

    if (!response.ok) {
      throw new Error(`Comic Vine API error: ${response.status}`);
    }

    const data = await response.json();
    
    if (data.error !== "OK") {
      throw new Error(`Comic Vine error: ${data.error}`);
    }

    const item = data.results;
    if (!item) {
      return null;
    }

    const imageArray = [item.image?.original_url, item.image?.medium_url, item.image?.thumb_url].filter(Boolean);
    
    // Extraire les auteurs depuis people
    const authorsList = (item.people || []).map(p => p.name);
    
    const result = {
      id: item.id,
      type: 'volume',
      title: item.name,
      originalTitle: null,
      authors: authorsList,
      editors: item.publisher ? [item.publisher.name] : [],
      releaseDate: item.start_year ? `${item.start_year}` : null,
      genres: [],
      pages: null,
      serie: { id: item.id, name: item.name },
      synopsis: item.deck || null,
      language: 'en',
      tome: null,
      image: imageArray,
      isbn: null,
      price: null,
      issueCount: item.count_of_issues,
      // Note: 'issues' supprim√© car trop volumineux (ex: Wolverine = 445 issues)
      // Utiliser /comicvine/volume/:id/issues si besoin de lister les num√©ros
      url: item.site_detail_url,
      source: 'comicvine'
    };

    console.log(`[ComicVine] ‚úÖ Volume r√©cup√©r√©: ${result.title} (${result.issueCount} issues)`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.comicvine.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un issue Comic Vine par ID
 * @param {string|number} issueId - ID de l'issue
 * @returns {Promise<object>} - D√©tails de l'issue
 */
async function getComicVineIssue(issueId) {
  metrics.sources.comicvine.requests++;
  
  const cacheKey = `comicvine_issue_${issueId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    const url = `${COMICVINE_BASE_URL}/issue/4000-${issueId}/?api_key=${COMICVINE_API_KEY}&format=json`;
    console.log(`[ComicVine] R√©cup√©ration issue ID: ${issueId}`);

    const response = await fetch(url, {
      headers: {
        'User-Agent': USER_AGENT
      }
    });

    if (!response.ok) {
      throw new Error(`Comic Vine API error: ${response.status}`);
    }

    const data = await response.json();
    
    if (data.error !== "OK") {
      throw new Error(`Comic Vine error: ${data.error}`);
    }

    const item = data.results;
    if (!item) {
      return null;
    }

    const imageArray = [item.image?.original_url, item.image?.medium_url, item.image?.thumb_url].filter(Boolean);
    
    // Extraire les auteurs depuis person_credits
    const authorsList = (item.person_credits || []).map(p => p.name);

    const result = {
      id: item.id,
      type: 'issue',
      title: item.name || (item.volume ? `${item.volume.name} #${item.issue_number}` : `Issue #${item.issue_number}`),
      originalTitle: null,
      authors: authorsList,
      editors: item.volume?.publisher ? [item.volume.publisher] : [],
      releaseDate: item.cover_date || item.store_date || null,
      genres: [],
      pages: null,
      serie: item.volume ? { id: item.volume.id, name: item.volume.name } : null,
      synopsis: item.deck || null,
      language: 'en',
      tome: item.issue_number,
      image: imageArray,
      isbn: null,
      price: null,
      url: item.site_detail_url,
      source: 'comicvine'
    };

    console.log(`[ComicVine] ‚úÖ Issue r√©cup√©r√©: ${result.serie?.name} #${result.tome}`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.comicvine.errors++;
    throw err;
  }
}

// ======================================================
// MangaDex API Functions (Manga - NO API KEY NEEDED)
// ======================================================

/**
 * Recherche de manga sur MangaDex
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchMangaDex(query, options = {}) {
  metrics.sources.mangadex.requests++;
  const max = Math.min(options.max || MANGADEX_DEFAULT_MAX, MANGADEX_MAX_LIMIT);
  const lang = options.lang || null; // Filtrer par langue disponible
  
  const cacheKey = `mangadex_search_${query}_${max}_${lang || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    const params = new URLSearchParams({
      title: query,
      limit: max.toString(),
      'includes[]': 'author',
      'order[relevance]': 'desc'
    });

    // Ajouter le filtre de langue si sp√©cifi√©
    if (lang) {
      params.append('availableTranslatedLanguage[]', lang);
    }
    // Ajouter les includes pour cover_art et artist
    params.append('includes[]', 'artist');
    params.append('includes[]', 'cover_art');

    const url = `${MANGADEX_BASE_URL}/manga?${params.toString()}`;
    console.log(`[MangaDex] Recherche: ${query} (max: ${max}, lang: ${lang || 'all'})`);

    const response = await fetch(url, {
      headers: {
        'User-Agent': USER_AGENT
      }
    });

    if (!response.ok) {
      throw new Error(`MangaDex API error: ${response.status}`);
    }

    const data = await response.json();
    
    const results = (data.data || []).map(item => {
      const attrs = item.attributes;
      
      // Extraire les relations
      const authors = item.relationships?.filter(r => r.type === 'author') || [];
      const artists = item.relationships?.filter(r => r.type === 'artist') || [];
      const coverArt = item.relationships?.find(r => r.type === 'cover_art');
      
      // Construire l'URL de la couverture
      let coverUrl = null;
      if (coverArt?.attributes?.fileName) {
        coverUrl = `${MANGADEX_COVERS_URL}/${item.id}/${coverArt.attributes.fileName}`;
      }

      // Extraire le titre dans la langue pr√©f√©r√©e
      const titleObj = attrs.title || {};
      const title = titleObj.en || titleObj.ja || titleObj['ja-ro'] || Object.values(titleObj)[0] || 'Unknown';
      
      // Extraire les titres alternatifs
      const altTitles = (attrs.altTitles || []).map(t => {
        const lang = Object.keys(t)[0];
        return { lang, title: t[lang] };
      });

      // Extraire la description dans la langue pr√©f√©r√©e
      const descObj = attrs.description || {};
      const description = descObj.fr || descObj.en || Object.values(descObj)[0] || null;

      // Extraire les tags
      const tags = (attrs.tags || []).map(tag => ({
        id: tag.id,
        name: tag.attributes?.name?.en || Object.values(tag.attributes?.name || {})[0] || 'Unknown',
        group: tag.attributes?.group
      }));

      // Extraire les noms de genre √† partir des tags
      const genreNames = tags.filter(t => t.group === 'genre').map(t => t.name);

      return {
        id: item.id,
        type: 'manga',
        title: title,
        originalTitle: titleObj.ja || titleObj['ja-ro'] || null,
        authors: authors.map(a => a.attributes?.name || 'Unknown'),
        editors: [],
        releaseDate: attrs.year ? `${attrs.year}` : null,
        genres: genreNames,
        pages: null,
        serie: null,
        synopsis: description,
        language: attrs.originalLanguage || 'ja',
        tome: attrs.lastVolume || null,
        image: coverUrl ? [coverUrl, `${coverUrl}.512.jpg`, `${coverUrl}.256.jpg`].filter(Boolean) : [] ? [coverUrl, `${coverUrl}.512.jpg`, `${coverUrl}.256.jpg`].filter(Boolean) : [],
        isbn: null,
        price: null,
        status: attrs.status,
        contentRating: attrs.contentRating,
        url: `https://mangadex.org/title/${item.id}`,
        source: 'mangadex'
      };
    });

    const result = {
      query,
      language: lang || 'all',
      totalResults: data.total,
      resultsCount: results.length,
      results,
      source: 'mangadex'
    };

    console.log(`[MangaDex] ‚úÖ ${results.length} r√©sultats trouv√©s`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.mangadex.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un manga MangaDex par ID
 * @param {string} mangaId - ID UUID du manga
 * @returns {Promise<object>} - D√©tails du manga
 */
async function getMangaDexById(mangaId) {
  metrics.sources.mangadex.requests++;
  
  const cacheKey = `mangadex_manga_${mangaId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    const params = new URLSearchParams();
    params.append('includes[]', 'author');
    params.append('includes[]', 'artist');
    params.append('includes[]', 'cover_art');

    const url = `${MANGADEX_BASE_URL}/manga/${mangaId}?${params.toString()}`;
    console.log(`[MangaDex] R√©cup√©ration manga ID: ${mangaId}`);

    const response = await fetch(url, {
      headers: {
        'User-Agent': USER_AGENT
      }
    });

    if (!response.ok) {
      if (response.status === 404) {
        return null;
      }
      throw new Error(`MangaDex API error: ${response.status}`);
    }

    const data = await response.json();
    const item = data.data;
    
    if (!item) {
      return null;
    }

    const attrs = item.attributes;
    
    // Extraire les relations
    const authors = item.relationships?.filter(r => r.type === 'author') || [];
    const artists = item.relationships?.filter(r => r.type === 'artist') || [];
    const coverArt = item.relationships?.find(r => r.type === 'cover_art');
    
    // Construire l'URL de la couverture
    let coverUrl = null;
    if (coverArt?.attributes?.fileName) {
      coverUrl = `${MANGADEX_COVERS_URL}/${item.id}/${coverArt.attributes.fileName}`;
    }

    // Extraire le titre
    const titleObj = attrs.title || {};
    const title = titleObj.en || titleObj.ja || titleObj['ja-ro'] || Object.values(titleObj)[0] || 'Unknown';
    
    // Extraire les titres alternatifs
    const altTitles = (attrs.altTitles || []).map(t => {
      const lang = Object.keys(t)[0];
      return { lang, title: t[lang] };
    });

    // Extraire toutes les descriptions
    const descriptions = attrs.description || {};

    // Extraire les tags
    const tags = (attrs.tags || []).map(tag => ({
      id: tag.id,
      name: tag.attributes?.name?.en || Object.values(tag.attributes?.name || {})[0] || 'Unknown',
      group: tag.attributes?.group
    }));

    // Extraire les noms de genre √† partir des tags
    const genreNames = tags.filter(t => t.group === 'genre').map(t => t.name);
    
    // Extraire les noms des auteurs
    const authorNames = authors.map(a => a.attributes?.name || 'Unknown');

    const result = {
      id: item.id,
      type: 'manga',
      title: title,
      originalTitle: titleObj.ja || titleObj['ja-ro'] || null,
      authors: authorNames,
      editors: [],
      releaseDate: attrs.year ? `${attrs.year}` : null,
      genres: genreNames,
      pages: null,
      serie: null,
      synopsis: descriptions.en || descriptions.fr || Object.values(descriptions)[0] || null,
      language: attrs.originalLanguage || 'ja',
      tome: attrs.lastVolume || null,
      image: coverUrl,
      isbn: null,
      price: null,
      status: attrs.status,
      contentRating: attrs.contentRating,
      url: `https://mangadex.org/title/${item.id}`,
      source: 'mangadex'
    };

    console.log(`[MangaDex] ‚úÖ Manga r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.mangadex.errors++;
    throw err;
  }
}

// ======================================================
// Bedetheque Functions (BD Franco-Belge - Scraping)
// ======================================================

/**
 * Recherche rapide de s√©ries via l'API AJAX de Bedetheque (autocomplete)
 * Cette API ne n√©cessite pas FlareSolverr et est plus rapide
 * @param {string} query - Terme de recherche (min 3 caract√®res)
 * @returns {Promise<Array>} - Liste de s√©ries {id, name, category}
 */
async function searchBedethequeAjax(query) {
  if (!query || query.length < 3) {
    return [];
  }
  
  const cacheKey = `bedetheque_ajax_${query}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }
  
  try {
    console.log(`[Bedetheque] Recherche AJAX: ${query}`);
    const url = `${BEDETHEQUE_BASE_URL}/ajax/tout?term=${encodeURIComponent(query)}`;
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (!response.ok) {
      console.log(`[Bedetheque] AJAX erreur HTTP: ${response.status}`);
      return [];
    }
    
    const data = await response.json();
    
    // Transformer les r√©sultats: format {id: "S59", label: "Ast√©rix", ...}
    const results = data
      .filter(item => item.id && item.id.startsWith('S')) // Seulement les s√©ries (pas les auteurs 'A')
      .map(item => ({
        id: parseInt(item.id.replace('S', '')),
        name: item.label || item.value,
        category: item.category || 'S√©ries'
      }));
    
    console.log(`[Bedetheque] AJAX: ${results.length} s√©ries trouv√©es`);
    setCache(cacheKey, results, 600); // Cache 10 min
    return results;
    
  } catch (err) {
    console.log(`[Bedetheque] AJAX erreur: ${err.message}`);
    return [];
  }
}

/**
 * Recherche de s√©ries sur Bedetheque
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchBedetheque(query, options = {}) {
  metrics.sources.bedetheque.requests++;
  const max = Math.min(options.max || BEDETHEQUE_DEFAULT_MAX, 50);
  
  const cacheKey = `bedetheque_search_${query}_${max}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    // Utiliser FlareSolverr pour contourner les protections
    console.log(`[Bedetheque] Recherche: ${query} (max: ${max})`);
    
    // Utiliser l'URL de recherche par nom qui fonctionne
    // Format: https://www.bedetheque.com/bandes_dessinees_QUERY.html
    // Normaliser la query: retirer les accents et remplacer espaces par _
    const urlQuery = query
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')  // Retirer les accents
      .toLowerCase()
      .replace(/\s+/g, '_');
    const searchUrl = `${BEDETHEQUE_BASE_URL}/bandes_dessinees_${encodeURIComponent(urlQuery)}.html`;
    
    console.log(`[Bedetheque] URL: ${searchUrl}`);
    
    const response = await fetch(`${FSR_BASE}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        cmd: "request.get",
        url: searchUrl,
        maxTimeout: 30000,
        session: fsrSessionId
      })
    });

    const data = await response.json();
    
    if (data.status !== "ok") {
      throw new Error(`FlareSolverr error: ${data.message || 'Unknown error'}`);
    }

    const html = data.solution?.response || "";
    
    // Parser les r√©sultats de recherche
    const results = [];
    const seenIds = new Set();
    
    // Regex pour extraire les liens vers les s√©ries
    // Format: href="https://www.bedetheque.com/serie-59-BD-Asterix.html"
    // Capture: ID et nom de la s√©rie
    const serieRegex = /href="[^"]*\/serie-(\d+)-BD-([^"]+)\.html"/gi;
    let match;
    
    // Normaliser la query pour la comparaison (retirer accents)
    const normalizeStr = (str) => str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
    const normalizedQuery = normalizeStr(query);
    
    while ((match = serieRegex.exec(html)) !== null && results.length < max) {
      const [fullMatch, id, namePart] = match;
      
      // √âviter les doublons
      if (seenIds.has(id)) continue;
      seenIds.add(id);
      
      // Convertir le nom de l'URL en nom lisible
      const name = decodeHtmlEntities(decodeURIComponent(namePart).replace(/-/g, ' ').trim());
      if (!name || name.length < 2) continue;
      
      // V√©rifier que le nom contient le terme de recherche (filtrage sans accents)
      const normalizedName = normalizeStr(name);
      if (!normalizedName.includes(normalizedQuery)) continue;
      
      results.push({
        id: parseInt(id),
        type: 'serie',
        name: name,
        url: `${BEDETHEQUE_BASE_URL}/serie-${id}-BD-${namePart}.html`,
        source: 'bedetheque'
      });
    }

    const result = {
      query,
      resultsCount: results.length,
      results,
      source: 'bedetheque',
      note: 'R√©sultats de recherche par scraping - certaines donn√©es peuvent √™tre incompl√®tes'
    };

    console.log(`[Bedetheque] ‚úÖ ${results.length} s√©ries trouv√©es`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.bedetheque.errors++;
    throw err;
  }
}

/**
 * Recherche d'albums sur Bedetheque via la page d'albums d'une s√©rie
 * Strat√©gie: recherche les s√©ries correspondantes, puis r√©cup√®re leurs albums
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche (max, serieId)
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchBedethequeAlbums(query, options = {}) {
  metrics.sources.bedetheque.requests++;
  const max = Math.min(options.max || BEDETHEQUE_DEFAULT_MAX, 50);
  const serieId = options.serieId || null;
  
  const cacheKey = `bedetheque_albums_${query}_${serieId || 'search'}_${max}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[Bedetheque] Recherche albums: ${query} (serieId: ${serieId || 'auto'}, max: ${max})`);
    
    let seriesData = []; // Stocker { id, name, url } pour chaque s√©rie
    
    if (serieId) {
      // Si un serieId est fourni, on a besoin du nom de la s√©rie pour l'URL
      // Options: 1) fourni via options.serieName, 2) fourni via query, 3) √©chec
      const serieName = options.serieName || query;
      
      if (serieName) {
        // G√©n√©rer le slug √† partir du nom
        const slug = serieName
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[^\w\s-]/g, '')
          .replace(/\s+/g, '-');
        
        seriesData = [{ 
          id: parseInt(serieId), 
          name: serieName, 
          url: `${BEDETHEQUE_BASE_URL}/serie-${serieId}-BD-${slug}.html`
        }];
        console.log(`[Bedetheque] S√©rie ${serieId} avec nom: ${serieName}`);
      } else {
        // Sans nom, on essaie de chercher via AJAX avec le serieId
        // Malheureusement Bedetheque ne supporte pas la recherche par ID seul
        console.log(`[Bedetheque] ‚ö†Ô∏è S√©rie ${serieId} sans nom - impossible de construire l'URL`);
        return {
          query,
          searchType: 'albums',
          error: true,
          message: 'Pour rechercher les albums d\'une s√©rie par ID, vous devez fournir le nom de la s√©rie via le param√®tre serieName ou q',
          example: `/bedetheque/search/albums?serieId=${serieId}&q=NomDeLaSerie`,
          resultsCount: 0,
          results: [],
          source: 'bedetheque'
        };
      }
    } else {
      // Essayer d'abord l'API AJAX (plus rapide, pas besoin de FlareSolverr)
      const ajaxResults = await searchBedethequeAjax(query);
      
      if (ajaxResults.length > 0) {
        // Utiliser les r√©sultats AJAX - on a l'ID et le nom, mais pas l'URL
        // On doit construire l'URL √† partir du nom de la s√©rie
        seriesData = ajaxResults.slice(0, 3).map(s => {
          // G√©n√©rer le slug URL √† partir du nom (sans accents, tirets √† la place des espaces)
          const slug = s.name
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^\w\s-]/g, '')
            .replace(/\s+/g, '-');
          return {
            id: s.id,
            name: s.name,
            url: `${BEDETHEQUE_BASE_URL}/serie-${s.id}-BD-${slug}.html`
          };
        });
        console.log(`[Bedetheque] Utilis√© AJAX: ${seriesData.length} s√©ries`);
      } else {
        // Fallback sur la recherche classique avec FlareSolverr
        console.log(`[Bedetheque] AJAX sans r√©sultat, fallback sur scraping`);
        const seriesResult = await searchBedetheque(query, { max: 5 });
        if (seriesResult.results && seriesResult.results.length > 0) {
          seriesData = seriesResult.results.slice(0, 3).map(s => ({
            id: s.id,
            name: s.name,
            url: s.url
          }));
        }
      }
    }
    
    if (seriesData.length === 0) {
      return {
        query,
        searchType: 'albums',
        resultsCount: 0,
        results: [],
        source: 'bedetheque',
        note: 'Aucune s√©rie trouv√©e correspondant √† la recherche. Essayez /bedetheque/search pour trouver une s√©rie.'
      };
    }
    
    // R√©cup√©rer les albums de chaque s√©rie trouv√©e
    const allAlbums = [];
    const normalizeStr = (str) => str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
    const normalizedQuery = normalizeStr(query);
    
    for (const serie of seriesData) {
      if (allAlbums.length >= max) break;
      
      // Construire l'URL des albums √† partir de l'URL de la s√©rie
      // serie-59-BD-Asterix.html => albums-59-BD-Asterix.html
      let albumsUrl;
      if (serie.url) {
        albumsUrl = serie.url.replace('/serie-', '/albums-');
      } else {
        // Fallback si on n'a que l'ID
        albumsUrl = `${BEDETHEQUE_BASE_URL}/albums-${serie.id}-BD-.html`;
      }
      console.log(`[Bedetheque] R√©cup√©ration albums s√©rie ${serie.id}: ${albumsUrl}`);
      
      const response = await fetch(`${FSR_BASE}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          cmd: "request.get",
          url: albumsUrl,
          maxTimeout: 30000,
          session: fsrSessionId
        })
      });

      const data = await response.json();
      
      if (data.status !== "ok") {
        console.log(`[Bedetheque] Erreur pour s√©rie ${serie.id}: ${data.message}`);
        continue;
      }

      const html = data.solution?.response || "";
      
      // Extraire le nom de la s√©rie depuis le HTML si pas d√©j√† connu
      let currentSerieName = serie.name;
      if (!currentSerieName) {
        const serieNameMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i);
        currentSerieName = serieNameMatch ? decodeHtmlEntities(serieNameMatch[1].trim()) : null;
      }
      
      // Parser les albums
      // Format avec image-tooltip: 
      // <a class="image-tooltip" rel="URL_MINIATURE" href="URL_ALBUM">
      //   <span class="serie">Nom s√©rie</span>
      //   <span class="num">1</span><span class="numa">b</span>
      //   <span class="titre">Titre album</span>
      //   <span class="dl">MM/YYYY</span>
      // </a>
      
      // Format r√©el des pages albums Bedetheque (gallery-couv-large):
      // <li>
      //   <a href="...BD-...-ID.html" title="Voir la fiche Album de SERIE -N- TITRE">
      //     <img src=".../thb_couv/xxx.jpg" class="fadeover couv libre" alt="SERIE -N- TITRE">
      //   </a>
      //   <div class="sous-titre"><b>Tome N</b> - TITRE</div>
      // </li>
      
      const seenIds = new Set();
      
      // M√©thode 1: Parser le format gallery-couv-large (images avec sous-titre)
      // Capturer les <li> contenant un album avec image
      const albumBlockRegex = /<li>\s*<a[^>]*href="([^"]*\/BD-[^"]*-(\d+)\.html)"[^>]*title="([^"]*)"[^>]*>\s*<img[^>]*src="([^"]*)"[^>]*>\s*<\/a>\s*<div class="sous-titre">([\s\S]*?)<\/div>\s*<\/li>/gi;
      let blockMatch;
      
      while ((blockMatch = albumBlockRegex.exec(html)) !== null && allAlbums.length < max) {
        const [, url, albumId, titleAttr, thumbnail, sousTitreHtml] = blockMatch;
        
        if (!albumId || seenIds.has(albumId)) continue;
        seenIds.add(albumId);
        
        // Extraire tome et titre depuis le sous-titre
        // Format: <b>Tome 1</b> - <span class="numa-serie"><b>b</b> - </span> Titre
        //    ou: <b>Tome 1</b> - Titre
        //    ou: <b>INT</b> - Titre
        //    ou: Simplement le titre
        let tome = null;
        let tomeVariant = null;
        let albumTitle = null;
        
        // D'abord, chercher une variante numa-serie (b, c, etc.)
        const numaSerieMatch = sousTitreHtml.match(/<span class="numa-serie"><b>([a-zA-Z]+)<\/b>\s*-\s*<\/span>/i);
        if (numaSerieMatch) {
          tomeVariant = numaSerieMatch[1];
        }
        
        // Ensuite, extraire le tome
        const tomeMatch = sousTitreHtml.match(/<b>(?:Tome\s*)?(\d+)([a-zA-Z]*)<\/b>/i);
        const intMatch = sousTitreHtml.match(/<b>(INT|HS|TL)<\/b>/i);
        
        if (tomeMatch) {
          tome = parseInt(tomeMatch[1]) || null;
          // Variante directement apr√®s le num√©ro (ex: <b>1b</b>)
          if (tomeMatch[2] && !tomeVariant) {
            tomeVariant = tomeMatch[2];
          }
        } else if (intMatch) {
          tomeVariant = intMatch[1]; // INT, HS, TL
        }
        
        // Extraire le titre (apr√®s tous les tags et tirets)
        // Nettoyer les balises HTML et extraire le titre proprement
        let cleanText = sousTitreHtml
          .replace(/<b>[^<]*<\/b>\s*-?\s*/gi, '')  // Retirer les <b>...</b> et tirets
          .replace(/<span[^>]*>[^<]*<\/span>\s*/gi, '')  // Retirer les spans
          .replace(/<[^>]*>/g, '')  // Retirer tout autre tag HTML
          .trim();
        
        if (cleanText) {
          albumTitle = decodeHtmlEntities(cleanText);
        }
        
        // Fallback: extraire du title attribute si pas de titre
        if (!albumTitle && titleAttr) {
          const titleMatch = titleAttr.match(/Album de .+? -(\d+[a-zA-Z]?)- (.+)$/i);
          if (titleMatch) {
            albumTitle = decodeHtmlEntities(titleMatch[2].trim());
            if (!tome) {
              const numPart = titleMatch[1];
              tome = parseInt(numPart) || null;
              const variantMatch = numPart.match(/\d+([a-zA-Z]+)/);
              if (variantMatch) tomeVariant = variantMatch[1];
            }
          }
        }
        
        // Si on a une query sans serieId sp√©cifique et plusieurs s√©ries, filtrer par pertinence
        if (query && !serieId && seriesData.length > 1) {
          const normalizedTitle = normalizeStr(albumTitle || '');
          const normalizedSerie = normalizeStr(currentSerieName || '');
          // Accepter si le titre ou la s√©rie contient la query
          if (!normalizedTitle.includes(normalizedQuery) && !normalizedSerie.includes(normalizedQuery)) {
            continue;
          }
        }
        
        allAlbums.push({
          id: parseInt(albumId),
          type: 'album',
          title: albumTitle,
          tome: tome,
          tomeVariant: tomeVariant || undefined,
          serie: currentSerieName ? { id: serie.id, name: currentSerieName } : null,
          image: thumbnail ? [thumbnail] : [],
          url: url,
          source: 'bedetheque'
        });
      }
      
      // M√©thode 2: Fallback - liens simples sans image structur√©e
      if (allAlbums.length === 0) {
        const albumRegexOld = /href="([^"]*\/BD-([^"]+)-(\d+)\.html)"[^>]*title="([^"]*)"/gi;
        let match;
        
        while ((match = albumRegexOld.exec(html)) !== null && allAlbums.length < max) {
          const [, url, namePart, albumId, title] = match;
          
          if (!albumId || seenIds.has(albumId)) continue;
          seenIds.add(albumId);
          
          let albumTitle = null;
          let tome = null;
          
          const titleParts = title.match(/Album de .+? -(\d+)- (.+)$/i);
          if (titleParts) {
            tome = parseInt(titleParts[1]) || null;
            albumTitle = decodeHtmlEntities(titleParts[2].trim());
          } else {
            albumTitle = decodeHtmlEntities(namePart.replace(/-/g, ' ').trim());
            const tomeMatch = namePart.match(/Tome-(\d+)/i);
            tome = tomeMatch ? parseInt(tomeMatch[1]) : null;
          }
          
          // Chercher une image correspondante dans le HTML
          const imgPattern = new RegExp(`<img[^>]*src="([^"]*thb_couv[^"]*)"[^>]*alt="[^"]*${albumId}`, 'i');
          const imgMatch = html.match(imgPattern);
          
          allAlbums.push({
            id: parseInt(albumId),
            type: 'album',
            title: albumTitle,
            tome: tome,
            serie: currentSerieName ? { id: serie.id, name: currentSerieName } : null,
            image: imgMatch ? [imgMatch[1]] : [],
            url: url,
            source: 'bedetheque'
          });
        }
      }
    }

    const result = {
      query,
      searchType: 'albums',
      seriesSearched: seriesData.map(s => s.id),
      resultsCount: allAlbums.length,
      results: allAlbums,
      source: 'bedetheque',
      note: serieId 
        ? 'Albums de la s√©rie sp√©cifi√©e' 
        : 'Albums trouv√©s via recherche de s√©ries. Utilisez serieId pour cibler une s√©rie sp√©cifique.'
    };

    console.log(`[Bedetheque] ‚úÖ ${allAlbums.length} albums trouv√©s`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.bedetheque.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'une s√©rie Bedetheque par ID
 * @param {string|number} serieId - ID de la s√©rie
 * @returns {Promise<object>} - D√©tails de la s√©rie
 */
async function getBedethequeSerieById(serieId) {
  metrics.sources.bedetheque.requests++;
  
  const cacheKey = `bedetheque_serie_${serieId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[Bedetheque] R√©cup√©ration s√©rie ID: ${serieId}`);
    
    // Construire l'URL de la s√©rie (on ne connait pas le nom, on utilise un placeholder)
    const serieUrl = `${BEDETHEQUE_BASE_URL}/serie-${serieId}-BD-.html`;
    
    const response = await fetch(`${FSR_BASE}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        cmd: "request.get",
        url: serieUrl,
        maxTimeout: 30000,
        session: fsrSessionId
      })
    });

    const data = await response.json();
    
    if (data.status !== "ok") {
      throw new Error(`FlareSolverr error: ${data.message || 'Unknown error'}`);
    }

    const html = data.solution?.response || "";
    const finalUrl = data.solution?.url || serieUrl;

    // Extraire le titre de la s√©rie
    let serieName = null;
    const titleMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i) || 
                       html.match(/<title>([^<|]+)/i);
    if (titleMatch) {
      serieName = decodeHtmlEntities(titleMatch[1].trim());
    }

    // Extraire la description/synopsis
    let synopsis = null;
    const synopsisMatch = html.match(/<div class="serie-info"[^>]*>([\s\S]*?)<\/div>/i) ||
                          html.match(/<p class="serie-resume"[^>]*>([\s\S]*?)<\/p>/i);
    if (synopsisMatch) {
      synopsis = decodeHtmlEntities(synopsisMatch[1].replace(/<[^>]+>/g, ' ').trim());
    }

    // Extraire l'image de couverture
    let cover = null;
    const coverMatch = html.match(/src="(https?:\/\/[^"]*couv[^"]*\.jpg)"/i) ||
                       html.match(/src="(https?:\/\/[^"]*media[^"]*\.jpg)"/i);
    if (coverMatch) {
      cover = coverMatch[1];
    }

    // Extraire les albums
    const albums = [];
    const albumRegex = /<a[^>]*href="(https?:\/\/www\.bedetheque\.com\/BD-[^"]*-(\d+)\.html)"[^>]*title="([^"]*)"[^>]*>/gi;
    let match;
    const seenAlbumIds = new Set();
    
    while ((match = albumRegex.exec(html)) !== null) {
      const [, url, id, title] = match;
      
      if (seenAlbumIds.has(id)) continue;
      seenAlbumIds.add(id);
      
      const cleanTitle = decodeHtmlEntities(title.trim());
      if (!cleanTitle) continue;
      
      albums.push({
        id: parseInt(id),
        title: cleanTitle,
        url,
        source: 'bedetheque'
      });
    }

    // Extraire les auteurs (sc√©nariste, dessinateur)
    const authors = [];
    const authorRegex = /<a[^>]*href="[^"]*auteur-[^"]*"[^>]*>([^<]+)<\/a>/gi;
    while ((match = authorRegex.exec(html)) !== null) {
      const name = decodeHtmlEntities(match[1].trim());
      if (name && !authors.includes(name)) {
        authors.push(name);
      }
    }

    // Extraire le genre
    let genre = null;
    const genreMatch = html.match(/Genre\s*:\s*<[^>]*>([^<]+)/i);
    if (genreMatch) {
      genre = decodeHtmlEntities(genreMatch[1].trim());
    }

    // Extraire le statut
    let status = null;
    if (html.includes('S√©rie termin√©e') || html.includes('s√©rie termin√©e')) {
      status = 'Termin√©e';
    } else if (html.includes('S√©rie en cours') || html.includes('s√©rie en cours')) {
      status = 'En cours';
    }

    const result = {
      id: parseInt(serieId),
      type: 'serie',
      title: serieName,
      originalTitle: null,
      authors: authors,
      editors: [],
      releaseDate: null,
      genres: genre ? [genre] : [],
      pages: null,
      serie: null,
      synopsis: synopsis,
      language: 'fr',
      tome: null,
      image: cover ? [cover] : [],
      isbn: null,
      price: null,
      status: status,
      albumCount: albums.length,
      albums: albums,
      url: finalUrl,
      source: 'bedetheque'
    };

    console.log(`[Bedetheque] ‚úÖ S√©rie r√©cup√©r√©e: ${result.title || 'Unknown'} (${albums.length} albums)`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.bedetheque.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un album Bedetheque par ID
 * @param {string|number} albumId - ID de l'album
 * @returns {Promise<object>} - D√©tails de l'album
 */
async function getBedethequeAlbumById(albumId) {
  metrics.sources.bedetheque.requests++;
  
  const cacheKey = `bedetheque_album_${albumId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[Bedetheque] R√©cup√©ration album ID: ${albumId}`);
    
    // Construire l'URL de l'album
    const albumUrl = `${BEDETHEQUE_BASE_URL}/BD--${albumId}.html`;
    
    const response = await fetch(`${FSR_BASE}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        cmd: "request.get",
        url: albumUrl,
        maxTimeout: 30000,
        session: fsrSessionId
      })
    });

    const data = await response.json();
    
    if (data.status !== "ok") {
      throw new Error(`FlareSolverr error: ${data.message || 'Unknown error'}`);
    }

    const html = data.solution?.response || "";
    const finalUrl = data.solution?.url || albumUrl;

    // Extraire le titre de la s√©rie (h1) et le titre de l'album (h2)
    let serieTitle = null;
    let albumTitle = null;
    
    // Titre de la s√©rie dans h1
    const serieTitleMatch = html.match(/<h1[^>]*>\s*<a[^>]*>([^<]+)<\/a>\s*<\/h1>/i);
    if (serieTitleMatch) {
      serieTitle = decodeHtmlEntities(serieTitleMatch[1].trim());
    }
    
    // Titre de l'album dans h2 (apr√®s le num√©ro de tome)
    // Format: <h2>1<span class="numa">b</span>.  Titre de l'album </h2>
    const albumTitleMatch = html.match(/<h2[^>]*>(?:[\s\S]*?<\/span>)?\s*\.?\s*([^<]+?)\s*<\/h2>/i);
    if (albumTitleMatch) {
      // Nettoyer le titre: retirer les espaces multiples et le point initial
      albumTitle = decodeHtmlEntities(albumTitleMatch[1].trim())
        .replace(/^\s*\.\s*/, '')
        .replace(/\s+/g, ' ')
        .trim();
    }
    
    // Fallback sur meta itemprop="name"
    if (!albumTitle) {
      const metaNameMatch = html.match(/<meta\s+itemprop="name"\s+content="([^"]+)"/i);
      if (metaNameMatch) {
        albumTitle = decodeHtmlEntities(metaNameMatch[1].trim());
      }
    }

    // Extraire la s√©rie avec ID
    let serie = null;
    const serieMatch = html.match(/<a[^>]*href="[^"]*serie-(\d+)-[^"]*"[^>]*title="([^"]+)"[^>]*>/i) ||
                       html.match(/<a[^>]*href="[^"]*serie-(\d+)-[^"]*"[^>]*>([^<]+)<\/a>/i);
    if (serieMatch) {
      serie = {
        id: parseInt(serieMatch[1]),
        name: decodeHtmlEntities(serieMatch[2].trim())
      };
    }

    // Extraire le tome (num√©ro + √©ventuelle lettre comme "1b")
    let tome = null;
    let tomeVariant = null;
    const tomeFullMatch = html.match(/<h2[^>]*>\s*(\d+)\s*(?:<span[^>]*>([a-z])<\/span>)?/i);
    if (tomeFullMatch) {
      tome = parseInt(tomeFullMatch[1]);
      tomeVariant = tomeFullMatch[2] || null;
    }

    // Extraire les images (couverture, planches, verso)
    const images = [];
    
    // Image de couverture principale
    const coverMatch = html.match(/src="(https?:\/\/[^"]*\/media\/Couvertures\/[^"]+\.jpg)"/i) ||
                       html.match(/itemprop="image"[^>]*src="([^"]+)"/i);
    if (coverMatch) {
      images.push(coverMatch[1]);
    }
    
    // Images de planches (extraits)
    const planchesRegex = /href="(https?:\/\/[^"]*\/media\/Planches\/[^"]+\.jpg)"/gi;
    let plancheMatch;
    while ((plancheMatch = planchesRegex.exec(html)) !== null) {
      if (!images.includes(plancheMatch[1])) {
        images.push(plancheMatch[1]);
      }
    }
    
    // Image du verso
    const versoMatch = html.match(/href="(https?:\/\/[^"]*\/media\/Versos\/[^"]+\.jpg)"/i);
    if (versoMatch && !images.includes(versoMatch[1])) {
      images.push(versoMatch[1]);
    }

    // Extraire le synopsis
    let synopsis = null;
    const synopsisMatch = html.match(/<div class="album-resume"[^>]*>([\s\S]*?)<\/div>/i) ||
                          html.match(/<p class="resume"[^>]*>([\s\S]*?)<\/p>/i) ||
                          html.match(/id="p-serie"[^>]*>([\s\S]*?)<\/p>/i);
    if (synopsisMatch) {
      synopsis = decodeHtmlEntities(synopsisMatch[1].replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim());
      if (!synopsis || synopsis.length < 5) synopsis = null;
    }

    // Extraire l'ISBN
    let isbn = null;
    const isbnMatch = html.match(/ISBN\s*:?\s*([0-9X-]+)/i) ||
                      html.match(/EAN\s*:?\s*(\d{13})/i);
    if (isbnMatch) {
      isbn = isbnMatch[1].replace(/-/g, '');
    }

    // Extraire la date de d√©p√¥t l√©gal (format MM/YYYY ou DD/MM/YYYY)
    let releaseDate = null;
    let year = null;
    
    // Date dans le calendrier avec icon-calendar
    const depotLegalMatch = html.match(/icon-calendar[^>]*><\/i>\s*(\d{1,2}\/\d{4})/i) ||
                            html.match(/D√©pot l√©gal[^>]*>\s*(\d{1,2}\/\d{4})/i);
    if (depotLegalMatch) {
      releaseDate = depotLegalMatch[1].trim();
      // Extraire l'ann√©e
      const yearFromDate = releaseDate.match(/(\d{4})/);
      if (yearFromDate) year = parseInt(yearFromDate[1]);
    }
    
    // Date dans meta itemprop="datePublished"
    if (!releaseDate) {
      const metaDateMatch = html.match(/<meta\s+itemprop="datePublished"\s+content="([^"]+)"/i);
      if (metaDateMatch) {
        releaseDate = metaDateMatch[1];
        const yearFromMeta = releaseDate.match(/(\d{4})/);
        if (yearFromMeta) year = parseInt(yearFromMeta[1]);
      }
    }
    
    // Ann√©e seule dans span.annee
    if (!year) {
      const yearMatch = html.match(/<span class="annee">(\d{4})<\/span>/i);
      if (yearMatch) {
        year = parseInt(yearMatch[1]);
      }
    }

    // Extraire l'√©diteur (publisher)
    let publisher = null;
    const publisherMatch = html.match(/itemprop="publisher"[^>]*>([^<]+)<\/span>/i) ||
                           html.match(/class="editeur"[^>]*>([^<]+)<\/span>/i);
    if (publisherMatch) {
      publisher = decodeHtmlEntities(publisherMatch[1].trim());
    }

    // Extraire les auteurs avec leurs r√¥les
    const authors = [];
    const authorsDetailed = [];
    
    // Chercher dans la liste d√©taill√©e des auteurs (liste-auteurs)
    const listeAuteursMatch = html.match(/<div class="liste-auteurs">([\s\S]*?)<\/div>/i);
    if (listeAuteursMatch) {
      const listeHtml = listeAuteursMatch[1];
      // Pattern: <a href="...">Nom</a> <span class="metier">(R√¥le)</span>
      const auteurRoleRegex = /<a[^>]*href="[^"]*auteur-(\d+)[^"]*"[^>]*>\s*([^<]+)\s*<\/a>\s*<span class="metier">\(([^)]+)\)<\/span>/gi;
      let auteurMatch;
      while ((auteurMatch = auteurRoleRegex.exec(listeHtml)) !== null) {
        const authorId = parseInt(auteurMatch[1]);
        const name = decodeHtmlEntities(auteurMatch[2].trim());
        const role = decodeHtmlEntities(auteurMatch[3].trim());
        
        if (name && !authors.includes(name)) {
          authors.push(name);
        }
        authorsDetailed.push({
          id: authorId,
          name: name,
          role: role
        });
      }
    }
    
    // Fallback: chercher les auteurs simples si pas de liste d√©taill√©e
    if (authors.length === 0) {
      const authorRegex = /<a[^>]*href="[^"]*auteur-[^"]*"[^>]*>\s*<span[^>]*>([^<]+)<\/span>\s*<\/a>/gi;
      let match;
      while ((match = authorRegex.exec(html)) !== null) {
        const name = decodeHtmlEntities(match[1].trim());
        if (name && !authors.includes(name)) {
          authors.push(name);
        }
      }
    }

    // Extraire le prix
    let price = null;
    const priceMatch = html.match(/Prix\s*:?\s*([0-9,.]+)\s*‚Ç¨/i) ||
                       html.match(/(\d+[.,]\d{2})\s*‚Ç¨/);
    if (priceMatch) {
      price = parseFloat(priceMatch[1].replace(',', '.'));
    }

    // Extraire le nombre de pages
    let pages = null;
    const pagesMatch = html.match(/itemprop="numberOfPages"[^>]*>(\d+)<\/span>/i) ||
                       html.match(/(\d+)\s*pages/i);
    if (pagesMatch) {
      pages = parseInt(pagesMatch[1]);
    }

    // Extraire le genre depuis meta itemprop="genre"
    const genres = [];
    const genreMatch = html.match(/<meta\s+itemprop="genre"\s+content="([^"]+)"/i);
    if (genreMatch) {
      // Format: "Europe - Science-fiction"
      // S√©parer uniquement sur " - " (avec espaces) pour ne pas casser "Science-fiction"
      const genreParts = genreMatch[1].split(' - ').map(g => g.trim()).filter(g => g);
      genres.push(...genreParts);
    }

    // Extraire le format (Format normal, Grand format, etc.)
    let format = null;
    const formatMatch = html.match(/icon-tablet[^>]*><\/i>\s*([^<]+)/i) ||
                        html.match(/Format\s*:\s*([^<\n]+)/i);
    if (formatMatch) {
      format = decodeHtmlEntities(formatMatch[1].trim());
    }

    // Extraire le copyright
    let copyright = null;
    const copyrightMatch = html.match(/<div class="copyrightserie">([^<]+)<\/div>/i);
    if (copyrightMatch) {
      copyright = decodeHtmlEntities(copyrightMatch[1].trim());
    }

    // Extraire le type de couverture (souple, rigide)
    let coverType = null;
    if (html.includes('title="Couverture souple"')) {
      coverType = 'souple';
    } else if (html.includes('title="Couverture rigide"') || html.includes('title="Couverture cartonn√©e"')) {
      coverType = 'rigide';
    }

    // V√©rifier si c'est une √©dition originale
    const isOriginalEdition = html.includes('title="Edition originale"');

    // Extraire la langue
    let language = 'fr';
    const langMatch = html.match(/<meta\s+itemprop="inLanguage"\s+content="([^"]+)"/i);
    if (langMatch) {
      language = langMatch[1];
    }

    // ============================================
    // Extraction depuis la section structur√©e (tab_content_liste_albums)
    // ============================================
    const listeAlbumsMatch = html.match(/<div class="tab_content_liste_albums">([\s\S]*?)<\/div>/i);
    
    // Estimation / Cote
    let estimation = null;
    const estimationMatch = html.match(/<label>Estimation\s*:\s*<\/label>([^<]+)/i);
    if (estimationMatch) {
      const estValue = estimationMatch[1].trim();
      if (estValue.toLowerCase() !== 'non cot√©' && estValue !== '') {
        // Essayer d'extraire une valeur num√©rique
        const priceFromEst = estValue.match(/([0-9,.]+)\s*‚Ç¨?/);
        if (priceFromEst) {
          estimation = parseFloat(priceFromEst[1].replace(',', '.'));
        } else {
          estimation = estValue;
        }
      }
    }

    // EAN/ISBN depuis la section structur√©e (plus fiable)
    if (!isbn) {
      const eanIsbnMatch = html.match(/<label>EAN\/ISBN\s*:\s*<\/label>\s*<span>([^<]*)<\/span>/i);
      if (eanIsbnMatch && eanIsbnMatch[1].trim()) {
        isbn = eanIsbnMatch[1].trim().replace(/-/g, '');
      }
    }

    // Nombre de planches (peut √™tre diff√©rent de pages)
    let planches = null;
    const planchesMatch = html.match(/<label>Planches\s*:?\s*<\/label>\s*<span>(\d+)<\/span>/i);
    if (planchesMatch) {
      planches = parseInt(planchesMatch[1]);
      // Si pages n'est pas d√©fini, utiliser planches
      if (!pages) pages = planches;
    }

    // Info √©dition (notes sp√©ciales)
    let editionInfo = null;
    const infoEditionMatch = html.match(/<span class="infoedition"><em>Info √©dition\s*:\s*<\/em>([^<]+)<\/span>/i);
    if (infoEditionMatch) {
      editionInfo = decodeHtmlEntities(infoEditionMatch[1].trim());
    }

    // Date de cr√©ation dans la base Bedetheque
    let createdAt = null;
    const createdMatch = html.match(/<label>Cr√©√© le\s*:\s*<\/label>(\d{2}\/\d{2}\/\d{4})/i) ||
                         html.match(/Album cr√©√©[^>]*le\s*(\d{2}\/\d{2}\/\d{4})/i);
    if (createdMatch) {
      createdAt = createdMatch[1];
    }

    // Date de modification
    let updatedAt = null;
    const updatedMatch = html.match(/maj\s*(\d{2}\/\d{2}\/\d{4})\s*(\d{2}:\d{2})?/i) ||
                         html.match(/modification le\s*(\d{2}\/\d{2}\/\d{4})/i);
    if (updatedMatch) {
      updatedAt = updatedMatch[1];
      if (updatedMatch[2]) {
        updatedAt += ' ' + updatedMatch[2];
      }
    }

    // Collection
    let collection = null;
    const collectionMatch = html.match(/<label>Collection\s*:\s*<\/label>\s*<span>([^<]+)<\/span>/i) ||
                            html.match(/<label>Collection\s*:\s*<\/label>([^<]+)/i);
    if (collectionMatch) {
      collection = decodeHtmlEntities(collectionMatch[1].trim());
    }

    const result = {
      id: parseInt(albumId),
      type: 'album',
      title: albumTitle || serieTitle,
      originalTitle: null,
      authors: authors,
      authorsDetailed: authorsDetailed.length > 0 ? authorsDetailed : undefined,
      editors: publisher ? [publisher] : [],
      collection: collection,
      releaseDate: releaseDate,
      year: year,
      genres: genres,
      pages: pages,
      planches: planches !== pages ? planches : undefined,
      format: format,
      coverType: coverType,
      isOriginalEdition: isOriginalEdition,
      serie: serie,
      tome: tome,
      tomeVariant: tomeVariant,
      synopsis: synopsis,
      editionInfo: editionInfo,
      language: language,
      image: images,
      isbn: isbn,
      price: price,
      estimation: estimation,
      copyright: copyright,
      createdAt: createdAt,
      updatedAt: updatedAt,
      url: finalUrl,
      source: 'bedetheque'
    };

    console.log(`[Bedetheque] ‚úÖ Album r√©cup√©r√©: ${result.title || 'Unknown'}`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.bedetheque.errors++;
    throw err;
  }
}


// ========================================
// MEGA CONSTRUX (Mattel - API Searchspring)
// ========================================

/**
 * Recherche de produits Mega Construx via l'API Searchspring de Mattel
 * @param {string} query - Terme de recherche
 * @param {object} options - Options (max, page)
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchMega(query, options = {}) {
  metrics.sources.mega.requests++;
  const max = Math.min(options.max || MEGA_DEFAULT_MAX, MEGA_MAX_LIMIT);
  const page = options.page || 1;
  const lang = options.lang || MEGA_DEFAULT_LANG;
  
  // D√©terminer la r√©gion (US ou EU) selon la langue
  const region = MEGA_LANG_REGION[lang] || 'EU';
  const apiUrl = region === 'US' ? MEGA_API_URL_US : MEGA_API_URL_EU;
  const siteId = region === 'US' ? MEGA_SITE_ID_US : MEGA_SITE_ID_EU;
  const baseUrl = region === 'US' ? MEGA_BASE_URL_US : MEGA_BASE_URL_EU;
  const currency = region === 'US' ? 'USD' : 'EUR';
  
  const cacheKey = `mega_search_${query}_${max}_${page}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[MEGA] Recherche: ${query} (max: ${max}, page: ${page}, lang: ${lang})`);
    
    // Ajouter "mega" √† la requ√™te pour filtrer les produits Mega
    const searchQuery = query.toLowerCase().includes('mega') ? query : `mega ${query}`;
    
    // Construire l'URL avec filtre de langue pour EU
    let url = `${apiUrl}?siteId=${siteId}&q=${encodeURIComponent(searchQuery)}&resultsFormat=native&resultsPerPage=${max}&page=${page}`;
    if (region === 'EU') {
      url += `&filter.ss_filter_tags_language=${lang}`;
    }
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'ToysAPI/1.14'
      }
    });

    if (!response.ok) {
      throw new Error(`Searchspring error: ${response.status}`);
    }

    const data = await response.json();
    
    // Transformer les r√©sultats
    const results = (data.results || []).map(item => {
      // Extraire le nombre de pi√®ces du titre si disponible
      const piecesMatch = item.name?.match(/\((\d+)\s*(?:Pieces?|Pcs?|pi√®ces?|Onderdelen|Teile|Pezzi)\)/i);
      const pieces = piecesMatch ? parseInt(piecesMatch[1]) : null;
      
      // Extraire l'√¢ge recommand√© depuis metafields si disponible
      let ageRange = null;
      try {
        if (item.metafields) {
          const metaStr = item.metafields.replace(/&quot;/g, '"');
          const ageMatch = metaStr.match(/"age_grade":\s*"([^"]+)"/);
          if (ageMatch) {
            ageRange = ageMatch[1];
          }
        }
      } catch (e) {}
      
      // Construire l'URL produit avec le pr√©fixe de langue pour EU
      let productUrl = null;
      if (item.url) {
        if (region === 'EU') {
          const langPrefix = lang.toLowerCase();
          productUrl = `${baseUrl}/${langPrefix}${item.url}`;
        } else {
          productUrl = `${baseUrl}${item.url}`;
        }
      }
      
      return {
        id: item.uid || item.id,
        type: 'building_set',
        title: item.name,
        description: item.description || null,
        brand: item.brand || 'MEGA',
        sku: item.sku || null,
        price: item.price ? parseFloat(item.price) : null,
        currency: currency,
        image: item.imageUrl || (item.images && item.images[0]) || null,
        pieces: pieces,
        ageRange: ageRange,
        rating: item.rating ? parseFloat(item.rating) : null,
        ratingCount: item.ratingCount ? parseInt(item.ratingCount) : null,
        inStock: item.ss_available === '1' || item.in_stock_offers === '1',
        url: productUrl,
        lang: lang,
        source: 'mega'
      };
    });

    const result = {
      query,
      page: page,
      totalResults: data.pagination?.totalResults || results.length,
      totalPages: data.pagination?.totalPages || 1,
      resultsCount: results.length,
      results,
      lang: lang,
      region: region,
      source: 'mega',
      note: `Produits Mega Construx depuis Mattel Shop (${currency})`
    };

    console.log(`[MEGA] ‚úÖ ${results.length} produits trouv√©s (total: ${result.totalResults})`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.mega.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un produit Mega Construx par ID ou SKU
 * @param {string} productId - ID ou SKU du produit
 * @param {object} options - Options (lang)
 * @returns {Promise<object>} - D√©tails du produit
 */
async function getMegaProductById(productId, options = {}) {
  metrics.sources.mega.requests++;
  const lang = options.lang || MEGA_DEFAULT_LANG;
  
  // D√©terminer la r√©gion (US ou EU) selon la langue
  const region = MEGA_LANG_REGION[lang] || 'EU';
  const apiUrl = region === 'US' ? MEGA_API_URL_US : MEGA_API_URL_EU;
  const siteId = region === 'US' ? MEGA_SITE_ID_US : MEGA_SITE_ID_EU;
  const baseUrl = region === 'US' ? MEGA_BASE_URL_US : MEGA_BASE_URL_EU;
  const currency = region === 'US' ? 'USD' : 'EUR';
  
  const cacheKey = `mega_product_${productId}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[MEGA] R√©cup√©ration produit: ${productId} (lang: ${lang})`);
    
    // Rechercher par SKU ou ID avec filtre langue
    let url = `${apiUrl}?siteId=${siteId}&q=${encodeURIComponent(productId)}&resultsFormat=native&resultsPerPage=10`;
    if (region === 'EU') {
      url += `&filter.ss_filter_tags_language=${lang}`;
    }
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'ToysAPI/1.14'
      }
    });

    if (!response.ok) {
      throw new Error(`Searchspring error: ${response.status}`);
    }

    const data = await response.json();
    
    // Trouver le produit correspondant (par UID ou SKU)
    let item = (data.results || []).find(r => 
      r.uid === productId || 
      r.sku === productId || 
      r.id === productId ||
      r.sku?.toUpperCase() === productId.toUpperCase()
    );
    
    // Si pas trouv√© avec le SKU exact, prendre le premier r√©sultat
    if (!item && data.results?.length > 0) {
      item = data.results[0];
    }
    
    if (!item) {
      throw new Error(`Produit non trouv√©: ${productId}`);
    }
    
    // Extraire les donn√©es enrichies depuis metafields
    let enrichedData = {};
    try {
      if (item.metafields) {
        const metaStr = item.metafields.replace(/&quot;/g, '"').replace(/\\&quot;/g, '"');
        
        // Age
        const ageMatch = metaStr.match(/"age_grade":\s*"([^"]+)"/);
        if (ageMatch) enrichedData.ageRange = ageMatch[1];
        
        // UPC/EAN
        const upcMatch = metaStr.match(/"upc_ean":\s*"([^"]+)"/);
        if (upcMatch) enrichedData.upc = upcMatch[1];
        
        // Cat√©gorie
        const categoryMatch = metaStr.match(/"web_category":\s*"([^"]+)"/);
        if (categoryMatch) enrichedData.category = categoryMatch[1];
        
        // Sous-type (franchise)
        const subtypeMatch = metaStr.match(/"subtype":\s*"([^"]+)"/);
        if (subtypeMatch) enrichedData.franchise = subtypeMatch[1];
        
        // Features (bullet points)
        const features = [];
        for (let i = 1; i <= 5; i++) {
          const featureMatch = metaStr.match(new RegExp(`"bullet_feature_${i}":\\s*"([^"]+)"`));
          if (featureMatch) {
            features.push(featureMatch[1].replace(/\\"/g, '"').replace(/\\u00e9/g, '√©'));
          }
        }
        if (features.length > 0) enrichedData.features = features;
      }
    } catch (e) {
      console.log(`[MEGA] Erreur parsing metafields: ${e.message}`);
    }
    
    // Extraire le nombre de pi√®ces du titre
    const piecesMatch = item.name?.match(/\((\d+)\s*(?:Pieces?|Pcs?|pi√®ces?|Onderdelen|Teile|Pezzi)\)/i);
    const pieces = piecesMatch ? parseInt(piecesMatch[1]) : null;
    
    // Construire l'URL produit avec le pr√©fixe de langue pour EU
    let productUrl = null;
    if (item.url) {
      if (region === 'EU') {
        const langPrefix = lang.toLowerCase();
        productUrl = `${baseUrl}/${langPrefix}${item.url}`;
      } else {
        productUrl = `${baseUrl}${item.url}`;
      }
    }
    
    const result = {
      id: item.uid || item.id,
      type: 'building_set',
      title: item.name,
      description: item.description || null,
      brand: item.brand || 'MEGA',
      sku: item.sku || null,
      price: item.price ? parseFloat(item.price) : null,
      currency: currency,
      images: item.images || (item.imageUrl ? [item.imageUrl] : []),
      thumbnail: item.thumbnailImageUrl || item.imageUrl || null,
      pieces: pieces,
      ageRange: enrichedData.ageRange || null,
      upc: enrichedData.upc || null,
      category: enrichedData.category || null,
      franchise: enrichedData.franchise || null,
      features: enrichedData.features || null,
      rating: item.rating ? parseFloat(item.rating) : null,
      ratingCount: item.ratingCount ? parseInt(item.ratingCount) : null,
      inStock: item.ss_available === '1' || item.in_stock_offers === '1',
      url: productUrl,
      lang: lang,
      source: 'mega'
    };

    console.log(`[MEGA] ‚úÖ Produit r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.mega.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les instructions de montage pour un produit Mega par SKU
 * Scrape les pages d'instructions de Mattel par cat√©gorie (recherche parall√®le)
 * @param {string} sku - SKU du produit (ex: HMW05, HTH96)
 * @returns {Promise<object>} - Informations sur les instructions
 */
async function getMegaInstructions(sku) {
  metrics.sources.mega.requests++;
  
  const skuLower = sku.toLowerCase();
  const cacheKey = `mega_instructions_${skuLower}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[MEGA] Recherche instructions pour SKU: ${sku}`);
    
    // Liste des cat√©gories d'instructions disponibles (page principale + cat√©gories)
    const categories = [
      '', // Page principale
      'en-us-category-pokemon',
      'en-us-category-halo',
      'en-us-category-barbie',
      'en-us-category-hot-wheels',
      'en-us-category-masters-of-the-universe',
      'en-us-category-tesla',
      'en-us-category-other'
    ];
    
    const baseUrl = `${MEGA_BASE_URL_US}/blogs/mega-building-instructions`;
    
    // Fonction pour extraire le PDF d'une page HTML
    const extractPdfFromHtml = (html) => {
      // Pattern: aria-label="{Nom} - {sku}" href="https://assets.contentstack.io/.../xxx.pdf"
      const regex = new RegExp(
        `aria-label="([^"]+)\\s*-\\s*${skuLower}"[^>]*href="(https://assets\\.contentstack\\.io[^"]+\\.pdf)"`,
        'i'
      );
      const match = html.match(regex);
      if (match) {
        return { name: match[1].trim(), url: match[2] };
      }
      return null;
    };
    
    // Fonction pour scraper une cat√©gorie
    const scrapeCategory = async (category) => {
      const url = category ? `${baseUrl}/tagged/${category}` : baseUrl;
      try {
        const response = await fetch(`${FSR_BASE}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            cmd: "request.get",
            url: url,
            maxTimeout: 30000,
            session: fsrSessionId
          })
        });
        const data = await response.json();
        if (data.status === "ok" && data.solution?.response) {
          const result = extractPdfFromHtml(data.solution.response);
          if (result) {
            return { ...result, category: category || 'page principale' };
          }
        }
      } catch (e) {
        console.log(`[MEGA] Erreur scraping ${url}: ${e.message}`);
      }
      return null;
    };
    
    // Recherche PARALL√àLE dans toutes les cat√©gories (au lieu de s√©quentiel)
    const results = await Promise.all(categories.map(cat => scrapeCategory(cat)));
    
    // Trouver le premier r√©sultat non-null
    const found = results.find(r => r !== null);
    
    if (!found) {
      throw new Error(`Instructions non trouv√©es pour SKU: ${sku}`);
    }
    
    console.log(`[MEGA] ‚úÖ Instructions trouv√©es pour ${sku} dans ${found.category}`);
    
    const result = {
      sku: sku.toUpperCase(),
      productName: found.name,
      instructionsUrl: found.url,
      format: 'PDF',
      source: 'mega',
      note: 'Instructions officielles Mattel'
    };

    // Cache plus long pour les instructions (1 jour)
    setCache(cacheKey, result, 86400000);
    return result;

  } catch (err) {
    metrics.sources.mega.errors++;
    throw err;
  }
}

/**
 * Recherche toutes les instructions disponibles pour une cat√©gorie Mega
 * @param {string} category - Cat√©gorie (pokemon, halo, barbie, hot-wheels, etc.)
 * @returns {Promise<object>} - Liste des instructions
 */
async function listMegaInstructions(category = '') {
  metrics.sources.mega.requests++;
  
  const cacheKey = `mega_instructions_list_${category || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[MEGA] Liste instructions pour cat√©gorie: ${category || 'toutes'}`);
    
    // Mapper les cat√©gories simples vers les tags Mattel
    const categoryMap = {
      'pokemon': 'en-us-category-pokemon',
      'halo': 'en-us-category-halo',
      'barbie': 'en-us-category-barbie',
      'hot-wheels': 'en-us-category-hot-wheels',
      'hotwheels': 'en-us-category-hot-wheels',
      'motu': 'en-us-category-masters-of-the-universe',
      'masters': 'en-us-category-masters-of-the-universe',
      'tesla': 'en-us-category-tesla',
      'other': 'en-us-category-other'
    };
    
    const mattelCategory = categoryMap[category.toLowerCase()] || category;
    const baseUrl = `${MEGA_BASE_URL_US}/blogs/mega-building-instructions`;  // Instructions uniquement sur site US
    const url = mattelCategory ? `${baseUrl}/tagged/${mattelCategory}` : baseUrl;
    
    const response = await fetch(`${FSR_BASE}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        cmd: "request.get",
        url: url,
        maxTimeout: 30000,
        session: fsrSessionId
      })
    });

    const data = await response.json();
    
    if (data.status !== "ok") {
      throw new Error(`FlareSolverr error: ${data.message || 'Unknown error'}`);
    }

    const html = data.solution?.response || "";
    
    // Extraire toutes les instructions
    const instructions = [];
    const regex = /aria-label="([^"]+)\s*-\s*([^"]+)"[^>]*href="(https:\/\/assets\.contentstack\.io[^"]+\.pdf)"/gi;
    let match;
    
    while ((match = regex.exec(html)) !== null) {
      const [, name, sku, pdfUrl] = match;
      instructions.push({
        sku: sku.trim().toUpperCase(),
        productName: name.trim(),
        instructionsUrl: pdfUrl,
        format: 'PDF'
      });
    }
    
    const result = {
      category: category || 'all',
      count: instructions.length,
      instructions,
      source: 'mega'
    };

    console.log(`[MEGA] ‚úÖ ${instructions.length} instructions trouv√©es`);
    // Cache 6h pour les listes
    setCache(cacheKey, result, 21600000);
    return result;

  } catch (err) {
    metrics.sources.mega.errors++;
    throw err;
  }
}

// -----------------------------
// Endpoints Amazon (via FlareSolverr + VPN)
// -----------------------------

// Recherche Amazon
app.get("/amazon/search", async (req, res) => {
  const q = req.query.q;
  const country = req.query.country || "fr";
  const category = req.query.category || null;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const max = req.query.max ? parseInt(req.query.max, 10) : 20;

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await searchAmazon(q, { country, category, page, limit: max });
    addCacheHeaders(res, 600); // Cache 10 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/search:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// D√©tails d'un produit Amazon par ASIN
app.get("/amazon/product/:asin", async (req, res) => {
  const { asin } = req.params;
  const country = req.query.country || "fr";

  if (!asin) return res.status(400).json({ error: "ASIN requis" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await getAmazonProduct(asin, country);
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/product:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Recherche par code-barres (EAN/UPC)
app.get("/amazon/barcode/:code", async (req, res) => {
  const { code } = req.params;
  const country = req.query.country || "fr";
  const category = req.query.category || null;

  if (!code) return res.status(400).json({ error: "Code-barres requis" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await searchAmazonByBarcode(code, { country, category });
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/barcode:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Recherche multi-pays
app.get("/amazon/multi", async (req, res) => {
  const q = req.query.q;
  const countries = req.query.countries ? req.query.countries.split(",") : ["fr", "us", "uk"];
  const category = req.query.category || null;

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await searchAmazonMultiCountry(q, countries, { category });
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/multi:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Comparaison de prix entre marketplaces
app.get("/amazon/compare/:asin", async (req, res) => {
  const { asin } = req.params;
  const countries = req.query.countries ? req.query.countries.split(",") : ["fr", "us", "uk", "de"];

  if (!asin) return res.status(400).json({ error: "ASIN requis" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await compareAmazonPrices(asin, countries);
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/compare:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Statut du VPN Amazon
app.get("/amazon/vpn/status", async (req, res) => {
  try {
    const status = await checkVpnStatus();
    res.json(status);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Rotation d'IP VPN
app.post("/amazon/vpn/rotate", async (req, res) => {
  try {
    const result = await rotateVpnIp();
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Marketplaces et cat√©gories support√©s
app.get("/amazon/marketplaces", (req, res) => {
  res.json(getSupportedMarketplaces());
});

app.get("/amazon/categories", (req, res) => {
  res.json(getSupportedCategories());
});

// -----------------------------
// Endpoints LEGO
// -----------------------------
app.get("/lego/search", async (req, res) => {
  const q = req.query.q;
  const lang = (req.query.lang || DEFAULT_LOCALE);
  const limit = req.query.limit ? parseInt(req.query.limit, 10) : 24;
  const max = req.query.max ? parseInt(req.query.max, 10) : limit; // Alias pour compatibilit√©

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.sources.lego.requests++;
    const perPage = Math.max(1, Math.min(max, 100)); // Entre 1 et 100
    const result = await callLegoGraphqlLib(q, lang, MAX_RETRIES, perPage);
    
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /lego/search:", err);
    metrics.requests.errors++;
    metrics.sources.lego.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Rebrickable (n√©cessite cl√© API)
// La cl√© API doit √™tre fournie via header:
// - X-Encrypted-Key: cl√© chiffr√©e en AES-256-GCM (si API_ENCRYPTION_KEY configur√©e)
// - X-Api-Key: cl√© en clair (seulement si chiffrement d√©sactiv√©)
// -----------------------------

// Recherche de sets LEGO via Rebrickable (recherche intelligente)
// Si q est un num√©ro de set: r√©cup√®re set + minifigs + pi√®ces
// Si q est un texte: recherche avec pagination
app.get("/rebrickable/search", async (req, res) => {
  const q = req.query.q;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const pageSize = req.query.page_size ? parseInt(req.query.page_size, 10) : REBRICKABLE_DEFAULT_MAX;
  const lang = req.query.lang || DEFAULT_LOCALE;
  const enrichLego = req.query.enrich_lego !== 'false'; // Activ√© par d√©faut
  const themeId = req.query.theme_id ? parseInt(req.query.theme_id, 10) : undefined;
  const minYear = req.query.min_year ? parseInt(req.query.min_year, 10) : undefined;
  const maxYear = req.query.max_year ? parseInt(req.query.max_year, 10) : undefined;
  const minParts = req.query.min_parts ? parseInt(req.query.min_parts, 10) : undefined;
  const maxPartsFilter = req.query.max_parts ? parseInt(req.query.max_parts, 10) : undefined;
  const maxPartsLimit = req.query.parts_limit ? parseInt(req.query.parts_limit, 10) : 500;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const searchOptions = {};
    if (themeId) searchOptions.theme_id = themeId;
    if (minYear) searchOptions.min_year = minYear;
    if (maxYear) searchOptions.max_year = maxYear;
    if (minParts) searchOptions.min_parts = minParts;
    if (maxPartsFilter) searchOptions.max_parts = maxPartsFilter;
    
    const result = await smartRebrickableSearchLib(q, apiKey, {
      page,
      pageSize,
      lang,
      enrichWithLego: enrichLego,
      maxParts: maxPartsLimit,
      searchOptions
    });
    
    // Cache plus long pour recherche par ID (1h) vs recherche texte (5min)
    const cacheTime = result.type === 'set_id' ? 3600 : 300;
    addCacheHeaders(res, cacheTime);
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/search:", err);
    metrics.requests.errors++;
    metrics.sources.rebrickable.errors++;
    
    if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else if (err.message.includes("rate limit")) {
      res.status(429).json({ error: err.message });
    } else if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// D√©tails d'un set LEGO via Rebrickable (avec enrichissement LEGO optionnel)
app.get("/rebrickable/set/:setNum", async (req, res) => {
  let setNum = req.params.setNum;
  const includeParts = req.query.parts !== 'false'; // Inclure les pi√®ces par d√©faut
  const includeMinifigs = req.query.minifigs !== 'false'; // Inclure les minifigs par d√©faut
  const enrichLego = req.query.enrich_lego !== 'false'; // Enrichir avec LEGO par d√©faut
  const lang = req.query.lang || DEFAULT_LOCALE;
  const maxParts = req.query.parts_limit ? parseInt(req.query.parts_limit, 10) : 500;
  
  if (!setNum) return res.status(400).json({ error: "param√®tre 'setNum' manquant" });
  
  // Convertir ID LEGO en ID Rebrickable si n√©cessaire
  setNum = legoIdToRebrickable(setNum);
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    let result;
    
    if (includeParts || includeMinifigs) {
      // Utiliser la fonction compl√®te
      result = await getRebrickableSetFullLib(setNum, apiKey, {
        includeParts,
        includeMinifigs,
        maxParts
      });
    } else {
      // Juste les infos de base
      result = await getRebrickableSet(setNum, apiKey);
    }
    
    // Enrichir avec LEGO si demand√©
    if (enrichLego) {
      result = await enrichRebrickableWithLego(result, lang);
    }
    
    // Ajouter lego_id si pas pr√©sent
    if (result.set_num && !result.lego_id) {
      result.lego_id = rebrickableIdToLego(result.set_num);
    }
    
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/set:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Pi√®ces d'un set LEGO via Rebrickable
app.get("/rebrickable/set/:setNum/parts", async (req, res) => {
  const setNum = req.params.setNum;
  const limit = req.query.limit ? parseInt(req.query.limit, 10) : 500;
  
  if (!setNum) return res.status(400).json({ error: "param√®tre 'setNum' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableSetParts(setNum, apiKey, limit);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/set/parts:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Minifigs d'un set LEGO via Rebrickable
app.get("/rebrickable/set/:setNum/minifigs", async (req, res) => {
  const setNum = req.params.setNum;
  
  if (!setNum) return res.status(400).json({ error: "param√®tre 'setNum' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableSetMinifigs(setNum, apiKey);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/set/minifigs:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Liste des th√®mes LEGO via Rebrickable
app.get("/rebrickable/themes", async (req, res) => {
  const parentId = req.query.parent_id ? parseInt(req.query.parent_id, 10) : null;
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableThemes(apiKey, parentId);
    addCacheHeaders(res, 86400); // Cache 24h pour les th√®mes (stable)
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/themes:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Liste des couleurs LEGO via Rebrickable
app.get("/rebrickable/colors", async (req, res) => {
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableColors(apiKey);
    addCacheHeaders(res, 86400); // Cache 24h
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/colors:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Google Books (n√©cessite cl√© API)
// La cl√© API doit √™tre fournie via header:
// - X-Encrypted-Key: cl√© chiffr√©e en AES-256-GCM (si API_ENCRYPTION_KEY configur√©e)
// - X-Api-Key: cl√© en clair (seulement si chiffrement d√©sactiv√©)
// -----------------------------

// Recherche de livres sur Google Books
// Supporte recherche par texte ou par ISBN
app.get("/googlebooks/search", async (req, res) => {
  const q = req.query.q;
  const lang = req.query.lang || null; // Code langue ISO 639-1 (fr, en, es, etc.)
  const maxResults = req.query.max ? parseInt(req.query.max, 10) : GOOGLE_BOOKS_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Google Books requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await searchGoogleBooksLib(q, apiKey, { lang, maxResults });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /googlebooks/search:", err);
    metrics.requests.errors++;
    metrics.sources.googlebooks.errors++;
    
    if (err.message.includes("invalide") || err.message.includes("quota")) {
      res.status(401).json({ error: err.message });
    } else if (err.message.includes("rate limit")) {
      res.status(429).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// D√©tails d'un livre par son ID Google Books
app.get("/googlebooks/book/:volumeId", async (req, res) => {
  let volumeId = req.params.volumeId;
  
  if (!volumeId) return res.status(400).json({ error: "param√®tre 'volumeId' manquant" });
  
  // Nettoyer les pr√©fixes courants
  volumeId = cleanSourceId(volumeId, 'googlebooks');
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Google Books requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getGoogleBookByIdLib(volumeId, apiKey);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /googlebooks/book:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide") || err.message.includes("quota")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Recherche par ISBN sur Google Books (raccourci)
app.get("/googlebooks/isbn/:isbn", async (req, res) => {
  const isbn = req.params.isbn;
  const lang = req.query.lang || null;
  
  if (!isbn) return res.status(400).json({ error: "param√®tre 'isbn' manquant" });
  
  // Valider l'ISBN
  if (!isIsbn(isbn)) {
    return res.status(400).json({ error: "ISBN invalide. Format attendu: 10 ou 13 chiffres" });
  }
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Google Books requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await searchGoogleBooksLib(isbn, apiKey, { lang, maxResults: 1 });
    
    // Si trouv√©, retourner le premier r√©sultat directement
    if (result.books && result.books.length > 0) {
      addCacheHeaders(res, 3600);
      res.json({
        ...result.books[0],
        query: isbn,
        source: "google_books"
      });
    } else {
      res.status(404).json({ error: `Aucun livre trouv√© pour ISBN: ${isbn}` });
    }
  } catch (err) {
    console.error("Erreur /googlebooks/isbn:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("invalide") || err.message.includes("quota")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints OpenLibrary (pas de cl√© API requise)
// -----------------------------

// Recherche de livres sur OpenLibrary
// Supporte recherche par texte ou par ISBN
app.get("/openlibrary/search", async (req, res) => {
  const q = req.query.q;
  const lang = req.query.lang || null; // Code langue ISO 639-1 (fr, en, es, etc.)
  const maxResults = req.query.max ? parseInt(req.query.max, 10) : OPENLIBRARY_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchOpenLibraryLib(q, { lang, maxResults });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /openlibrary/search:", err);
    metrics.requests.errors++;
    metrics.sources.openlibrary.errors++;
    res.status(500).json({ error: err.message });
  }
});

// D√©tails d'un livre par son ID OpenLibrary (work ou edition)
app.get("/openlibrary/book/:olId", async (req, res) => {
  let olId = req.params.olId;
  
  if (!olId) return res.status(400).json({ error: "param√®tre 'olId' manquant" });
  
  // Nettoyer les pr√©fixes courants (olib_, openlibrary_, ol_)
  olId = cleanSourceId(olId, 'openlibrary');
  
  try {
    const result = await getOpenLibraryByIdLib(olId);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /openlibrary/book:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Recherche par ISBN sur OpenLibrary (raccourci)
app.get("/openlibrary/isbn/:isbn", async (req, res) => {
  const isbn = req.params.isbn;
  const lang = req.query.lang || null;
  
  if (!isbn) return res.status(400).json({ error: "param√®tre 'isbn' manquant" });
  
  // Valider l'ISBN
  if (!isIsbn(isbn)) {
    return res.status(400).json({ error: "ISBN invalide. Format attendu: 10 ou 13 chiffres" });
  }
  
  try {
    const result = await searchOpenLibraryLib(isbn, { lang, maxResults: 1 });
    
    // Si trouv√©, retourner le premier r√©sultat directement
    if (result.books && result.books.length > 0) {
      addCacheHeaders(res, 3600);
      res.json({
        ...result.books[0],
        query: isbn,
        source: "openlibrary"
      });
    } else {
      res.status(404).json({ error: `Aucun livre trouv√© pour ISBN: ${isbn}` });
    }
  } catch (err) {
    console.error("Erreur /openlibrary/isbn:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints RAWG (jeux vid√©o)
// -----------------------------

/**
 * Recherche de jeux sur RAWG
 * GET /rawg/search?q=zelda&max=10&page=1&platforms=4,18,1&genres=action&ordering=-rating
 * 
 * Param√®tres:
 * - q: terme de recherche (requis)
 * - max: nombre de r√©sultats par page (d√©faut: 20, max: 40)
 * - page: num√©ro de page (d√©faut: 1)
 * - platforms: IDs de plateformes s√©par√©s par virgule (ex: 4=PC, 18=PS4, 1=Xbox One)
 * - genres: genres s√©par√©s par virgule (ex: action,adventure,rpg)
 * - ordering: tri (-rating, -released, -added, -created, -updated, -metacritic)
 * - dates: plage de dates (ex: 2020-01-01,2023-12-31)
 * - metacritic: plage de score metacritic (ex: 80,100)
 * 
 * Requiert: cl√© API RAWG via X-Api-Key ou X-Encrypted-Key
 */
app.get("/rawg/search", async (req, res) => {
  const query = req.query.q;
  const max = Math.min(parseInt(req.query.max, 10) || RAWG_DEFAULT_MAX, RAWG_MAX_LIMIT);
  const page = parseInt(req.query.page, 10) || 1;
  const platforms = req.query.platforms || null;
  const genres = req.query.genres || null;
  const ordering = req.query.ordering || null;
  const dates = req.query.dates || null;
  const metacritic = req.query.metacritic || null;
  
  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API RAWG requise",
      hint: "Obtenez une cl√© gratuite sur https://rawg.io/apidocs"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await searchRawgLib(query, apiKey, {
      max, page, platforms, genres, ordering, dates, metacritic
    });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /rawg/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("401") || err.message.includes("403")) {
      res.status(401).json({ error: "Cl√© API RAWG invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un jeu sur RAWG
 * GET /rawg/game/:id
 * 
 * :id peut √™tre l'ID num√©rique ou le slug du jeu
 * Ex: /rawg/game/3498 ou /rawg/game/grand-theft-auto-v
 */
app.get("/rawg/game/:id", async (req, res) => {
  const gameId = req.params.id;
  
  if (!gameId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API RAWG requise",
      hint: "Obtenez une cl√© gratuite sur https://rawg.io/apidocs"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getRawgGameDetailsLib(gameId, apiKey);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /rawg/game:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("403")) {
      res.status(401).json({ error: "Cl√© API RAWG invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints IGDB (jeux vid√©o Twitch)
// -----------------------------

/**
 * Recherche de jeux sur IGDB
 * GET /igdb/search?q=zelda&max=10&platforms=48,167&genres=12
 * 
 * Param√®tres:
 * - q: terme de recherche (requis)
 * - max: nombre de r√©sultats (d√©faut: 20, max: 500)
 * - platforms: IDs de plateformes s√©par√©s par virgule
 * - genres: IDs de genres s√©par√©s par virgule
 * 
 * Requiert: cl√© API IGDB au format "clientId:clientSecret" via X-Api-Key ou X-Encrypted-Key
 */
app.get("/igdb/search", async (req, res) => {
  const query = req.query.q;
  const max = Math.min(parseInt(req.query.max, 10) || IGDB_DEFAULT_MAX, IGDB_MAX_LIMIT);
  const platforms = req.query.platforms || null;
  const genres = req.query.genres || null;
  
  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API (format: clientId:clientSecret)
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API IGDB requise (format: clientId:clientSecret)",
      hint: "Cr√©ez une application sur https://dev.twitch.tv/console/apps"
    });
  }
  
  try {
    // Parser les credentials IGDB
    const { clientId, clientSecret } = parseIgdbCredentials(apiKey);
    
    // Obtenir un token OAuth2
    const accessToken = await getIgdbToken(clientId, clientSecret);
    
    metrics.requests.total++;
    const result = await searchIgdbLib(query, clientId, accessToken, { max, platforms, genres });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /igdb/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("Format de cl√©") || err.message.includes("clientId")) {
      res.status(400).json({ 
        error: err.message,
        hint: "Format attendu: clientId:clientSecret"
      });
    } else if (err.message.includes("401") || err.message.includes("403") || err.message.includes("OAuth2")) {
      res.status(401).json({ error: "Credentials IGDB invalides" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un jeu sur IGDB
 * GET /igdb/game/:id
 * 
 * :id peut √™tre l'ID num√©rique ou le slug du jeu
 * Ex: /igdb/game/1942 ou /igdb/game/the-witcher-3-wild-hunt
 */
app.get("/igdb/game/:id", async (req, res) => {
  const gameId = req.params.id;
  
  if (!gameId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API IGDB requise (format: clientId:clientSecret)",
      hint: "Cr√©ez une application sur https://dev.twitch.tv/console/apps"
    });
  }
  
  try {
    // Parser les credentials IGDB
    const { clientId, clientSecret } = parseIgdbCredentials(apiKey);
    
    // Obtenir un token OAuth2
    const accessToken = await getIgdbToken(clientId, clientSecret);
    
    metrics.requests.total++;
    const result = await getIgdbGameDetailsLib(gameId, clientId, accessToken);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /igdb/game:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("Format de cl√©") || err.message.includes("clientId")) {
      res.status(400).json({ 
        error: err.message,
        hint: "Format attendu: clientId:clientSecret"
      });
    } else if (err.message.includes("401") || err.message.includes("403") || err.message.includes("OAuth2")) {
      res.status(401).json({ error: "Credentials IGDB invalides" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints TVDB
// -----------------------------

/**
 * Recherche sur TVDB (s√©ries, films, personnes, compagnies)
 * GET /tvdb/search?q=breaking+bad&type=series&max=10&lang=fra&year=2008
 * 
 * Param√®tres:
 *   q (obligatoire) - Terme de recherche
 *   type (optionnel) - Type de recherche: series, movie, person, company
 *   max (optionnel) - Nombre max de r√©sultats (d√©faut: 20, max: 100)
 *   lang (optionnel) - Code langue (fra, eng, deu, spa, etc.)
 *   year (optionnel) - Ann√©e de sortie
 * 
 * Requiert une cl√© API TVDB via X-Api-Key ou X-Encrypted-Key
 */
app.get("/tvdb/search", async (req, res) => {
  const query = req.query.q;
  const type = req.query.type || null;
  const max = req.query.max ? parseInt(req.query.max, 10) : TVDB_DEFAULT_MAX;
  const lang = req.query.lang || null;
  const year = req.query.year ? parseInt(req.query.year, 10) : null;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TVDB requise",
      hint: "Obtenez une cl√© gratuite sur https://thetvdb.com/api-information"
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchTvdbLib(query, apiKey, { max, type, lang, year });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tvdb/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("401") || err.message.includes("Unauthorized")) {
      res.status(401).json({ error: "Cl√© API TVDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'une s√©rie sur TVDB
 * GET /tvdb/series/:id?lang=fra
 * 
 * :id - ID TVDB de la s√©rie (ex: 81189 pour Breaking Bad)
 * lang (optionnel) - Code langue pour la traduction (fra, eng, deu, etc.)
 */
app.get("/tvdb/series/:id", async (req, res) => {
  const seriesId = req.params.id;
  const lang = req.query.lang || null;
  
  if (!seriesId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TVDB requise",
      hint: "Obtenez une cl√© gratuite sur https://thetvdb.com/api-information"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTvdbSeriesByIdLib(seriesId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tvdb/series:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©e")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Unauthorized")) {
      res.status(401).json({ error: "Cl√© API TVDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un film sur TVDB
 * GET /tvdb/movie/:id?lang=fra
 * 
 * :id - ID TVDB du film
 * lang (optionnel) - Code langue pour la traduction (fra, eng, deu, etc.)
 */
app.get("/tvdb/movie/:id", async (req, res) => {
  const movieId = req.params.id;
  const lang = req.query.lang || null;
  
  if (!movieId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TVDB requise",
      hint: "Obtenez une cl√© gratuite sur https://thetvdb.com/api-information"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTvdbMovieByIdLib(movieId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tvdb/movie:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Unauthorized")) {
      res.status(401).json({ error: "Cl√© API TVDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints TMDB
// -----------------------------

/**
 * Recherche sur TMDB (films, s√©ries TV, personnes)
 * GET /tmdb/search?q=inception&type=movie&max=10&lang=fr-FR&page=1&year=2010
 * 
 * Param√®tres:
 *   q (obligatoire) - Terme de recherche
 *   type (optionnel) - Type de recherche: movie, tv, person, multi (d√©faut)
 *   max (optionnel) - Nombre max de r√©sultats (d√©faut: 20, max: 20 par page)
 *   lang (optionnel) - Langue au format ISO 639-1-ISO 3166-1 (ex: fr-FR, en-US)
 *   page (optionnel) - Num√©ro de page pour la pagination
 *   year (optionnel) - Ann√©e de sortie/diffusion
 *   adult (optionnel) - Inclure le contenu adulte (true/false)
 * 
 * Requiert une cl√© API TMDB via X-Api-Key ou X-Encrypted-Key
 */
app.get("/tmdb/search", async (req, res) => {
  const query = req.query.q;
  const type = req.query.type || null;
  const max = req.query.max ? parseInt(req.query.max, 10) : TMDB_DEFAULT_MAX;
  const lang = req.query.lang || 'fr-FR';
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const year = req.query.year ? parseInt(req.query.year, 10) : null;
  const includeAdult = req.query.adult === 'true';

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TMDB requise",
      hint: "Obtenez une cl√© gratuite sur https://www.themoviedb.org/settings/api"
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchTmdbLib(query, apiKey, { max, type, lang, page, year, includeAdult });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tmdb/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("401") || err.message.includes("Invalid API key")) {
      res.status(401).json({ error: "Cl√© API TMDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un film sur TMDB
 * GET /tmdb/movie/:id?lang=fr-FR
 * 
 * :id - ID TMDB du film (ex: 27205 pour Inception)
 * lang (optionnel) - Langue au format ISO 639-1-ISO 3166-1 (d√©faut: fr-FR)
 * 
 * Inclut: cr√©dits, vid√©os, mots-cl√©s, recommandations, films similaires, IDs externes
 */
app.get("/tmdb/movie/:id", async (req, res) => {
  const movieId = req.params.id;
  const lang = req.query.lang || 'fr-FR';
  
  if (!movieId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TMDB requise",
      hint: "Obtenez une cl√© gratuite sur https://www.themoviedb.org/settings/api"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTmdbMovieByIdLib(movieId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tmdb/movie:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Invalid API key")) {
      res.status(401).json({ error: "Cl√© API TMDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'une s√©rie TV sur TMDB
 * GET /tmdb/tv/:id?lang=fr-FR
 * 
 * :id - ID TMDB de la s√©rie (ex: 1396 pour Breaking Bad)
 * lang (optionnel) - Langue au format ISO 639-1-ISO 3166-1 (d√©faut: fr-FR)
 * 
 * Inclut: cr√©dits, vid√©os, mots-cl√©s, recommandations, s√©ries similaires, IDs externes
 */
app.get("/tmdb/tv/:id", async (req, res) => {
  const tvId = req.params.id;
  const lang = req.query.lang || 'fr-FR';
  
  if (!tvId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TMDB requise",
      hint: "Obtenez une cl√© gratuite sur https://www.themoviedb.org/settings/api"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTmdbTvByIdLib(tvId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tmdb/tv:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©e")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Invalid API key")) {
      res.status(401).json({ error: "Cl√© API TMDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints IMDB (via imdbapi.dev - NO API KEY NEEDED)
// -----------------------------

/**
 * Recherche de titres sur IMDB
 * GET /imdb/search?q=inception&max=10
 * 
 * q (requis) - Terme de recherche
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 20, max: 50)
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/imdb/search", async (req, res) => {
  const query = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : IMDB_DEFAULT_MAX;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.requests.total++;
    const result = await searchImdbLib(query, { max });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /imdb/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * D√©tails d'un titre sur IMDB
 * GET /imdb/title/:id
 * 
 * :id - ID IMDB du titre (format: tt1234567, ex: tt1375666 pour Inception)
 * 
 * Retourne les d√©tails complets incluant: synopsis, casting, r√©alisateurs, genres, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/imdb/title/:id", async (req, res) => {
  const titleId = req.params.id;
  
  if (!titleId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Valider le format de l'ID IMDB
  if (!/^tt\d{7,}$/.test(titleId)) {
    return res.status(400).json({ 
      error: "Format d'ID IMDB invalide",
      hint: "L'ID doit √™tre au format 'tt' suivi d'au moins 7 chiffres (ex: tt1375666)"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getImdbTitleByIdLib(titleId);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /imdb/title:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * Browse/Liste des titres IMDB avec filtres avanc√©s
 * GET /imdb/browse?types=MOVIE&genres=Action&startYear=2020&endYear=2024&minRating=8&sortBy=SORT_BY_USER_RATING&sortOrder=DESC&max=20
 * 
 * types (optionnel) - Types de titres: MOVIE, TV_SERIES, TV_MINI_SERIES, TV_SPECIAL, TV_MOVIE, SHORT, VIDEO, VIDEO_GAME (plusieurs possibles s√©par√©s par virgule)
 * genres (optionnel) - Genres: Action, Comedy, Drama, Horror, Sci-Fi, etc. (plusieurs possibles s√©par√©s par virgule)
 * startYear (optionnel) - Ann√©e de d√©but pour filtrer
 * endYear (optionnel) - Ann√©e de fin pour filtrer
 * minRating (optionnel) - Note minimum (0-10)
 * maxRating (optionnel) - Note maximum (0-10)
 * sortBy (optionnel) - Tri: SORT_BY_POPULARITY (d√©faut), SORT_BY_RELEASE_DATE, SORT_BY_USER_RATING, SORT_BY_USER_RATING_COUNT, SORT_BY_YEAR
 * sortOrder (optionnel) - Ordre: ASC, DESC (d√©faut)
 * pageToken (optionnel) - Token pour la pagination (retourn√© dans nextPageToken)
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 20, max: 50)
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/imdb/browse", async (req, res) => {
  const types = req.query.types ? req.query.types.split(',').map(t => t.trim().toUpperCase()) : [];
  const genres = req.query.genres ? req.query.genres.split(',').map(g => g.trim()) : [];
  const startYear = req.query.startYear ? parseInt(req.query.startYear, 10) : null;
  const endYear = req.query.endYear ? parseInt(req.query.endYear, 10) : null;
  const minRating = req.query.minRating ? parseFloat(req.query.minRating) : null;
  const maxRating = req.query.maxRating ? parseFloat(req.query.maxRating) : null;
  const sortBy = req.query.sortBy || 'SORT_BY_POPULARITY';
  const sortOrder = req.query.sortOrder || 'DESC';
  const pageToken = req.query.pageToken || null;
  const limit = req.query.max ? parseInt(req.query.max, 10) : IMDB_DEFAULT_MAX;

  // Valider les param√®tres
  const validTypes = ['MOVIE', 'TV_SERIES', 'TV_MINI_SERIES', 'TV_SPECIAL', 'TV_MOVIE', 'SHORT', 'VIDEO', 'VIDEO_GAME'];
  const invalidTypes = types.filter(t => !validTypes.includes(t));
  if (invalidTypes.length > 0) {
    return res.status(400).json({ 
      error: `Types invalides: ${invalidTypes.join(', ')}`,
      validTypes
    });
  }
  
  const validSortBy = ['SORT_BY_POPULARITY', 'SORT_BY_RELEASE_DATE', 'SORT_BY_USER_RATING', 'SORT_BY_USER_RATING_COUNT', 'SORT_BY_YEAR'];
  if (!validSortBy.includes(sortBy)) {
    return res.status(400).json({ 
      error: `sortBy invalide: ${sortBy}`,
      validValues: validSortBy
    });
  }
  
  if (sortOrder !== 'ASC' && sortOrder !== 'DESC') {
    return res.status(400).json({ 
      error: `sortOrder invalide: ${sortOrder}`,
      validValues: ['ASC', 'DESC']
    });
  }

  try {
    metrics.requests.total++;
    const result = await browseImdbTitlesLib({
      types,
      genres,
      startYear,
      endYear,
      minRating,
      maxRating,
      sortBy,
      sortOrder,
      pageToken,
      limit
    });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /imdb/browse:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Jikan (MyAnimeList - NO API KEY NEEDED)
// -----------------------------

/**
 * Recherche d'anime sur Jikan (MyAnimeList)
 * GET /jikan/anime?q=naruto&max=25&page=1
 * 
 * q (requis) - Terme de recherche
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 25, max: 25 par page)
 * page (optionnel) - Num√©ro de page pour la pagination (d√©faut: 1)
 * type (optionnel) - Type d'anime: tv, movie, ova, special, ona, music
 * status (optionnel) - Statut: airing, complete, upcoming
 * rating (optionnel) - Classification: g, pg, pg13, r17, r, rx
 * orderBy (optionnel) - Tri par: mal_id, title, start_date, end_date, episodes, score, scored_by, rank, popularity, members, favorites
 * sort (optionnel) - Ordre: asc, desc
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/anime", async (req, res) => {
  const query = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : JIKAN_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const type = req.query.type || null;
  const status = req.query.status || null;
  const rating = req.query.rating || null;
  const orderBy = req.query.orderBy || null;
  const sort = req.query.sort || null;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  // Valider le type si fourni
  const validTypes = ['tv', 'movie', 'ova', 'special', 'ona', 'music'];
  if (type && !validTypes.includes(type.toLowerCase())) {
    return res.status(400).json({ 
      error: `Type invalide: ${type}`,
      validTypes
    });
  }

  // Valider le statut si fourni
  const validStatuses = ['airing', 'complete', 'upcoming'];
  if (status && !validStatuses.includes(status.toLowerCase())) {
    return res.status(400).json({ 
      error: `Statut invalide: ${status}`,
      validStatuses
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchJikanAnimeLib(query, { max, page, type, status, rating, orderBy, sort });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/anime:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * Recherche de manga sur Jikan (MyAnimeList)
 * GET /jikan/manga?q=one+piece&max=25&page=1
 * 
 * q (requis) - Terme de recherche
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 25, max: 25 par page)
 * page (optionnel) - Num√©ro de page pour la pagination (d√©faut: 1)
 * type (optionnel) - Type de manga: manga, novel, lightnovel, oneshot, doujin, manhwa, manhua
 * status (optionnel) - Statut: publishing, complete, hiatus, discontinued, upcoming
 * orderBy (optionnel) - Tri par: mal_id, title, start_date, end_date, chapters, volumes, score, scored_by, rank, popularity, members, favorites
 * sort (optionnel) - Ordre: asc, desc
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/manga", async (req, res) => {
  const query = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : JIKAN_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const type = req.query.type || null;
  const status = req.query.status || null;
  const orderBy = req.query.orderBy || null;
  const sort = req.query.sort || null;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  // Valider le type si fourni
  const validTypes = ['manga', 'novel', 'lightnovel', 'oneshot', 'doujin', 'manhwa', 'manhua'];
  if (type && !validTypes.includes(type.toLowerCase())) {
    return res.status(400).json({ 
      error: `Type invalide: ${type}`,
      validTypes
    });
  }

  // Valider le statut si fourni
  const validStatuses = ['publishing', 'complete', 'hiatus', 'discontinued', 'upcoming'];
  if (status && !validStatuses.includes(status.toLowerCase())) {
    return res.status(400).json({ 
      error: `Statut invalide: ${status}`,
      validStatuses
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchJikanMangaLib(query, { max, page, type, status, orderBy, sort });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/manga:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * D√©tails d'un anime sur Jikan (MyAnimeList)
 * GET /jikan/anime/:id
 * 
 * :id - ID MyAnimeList de l'anime (ex: 20 pour Naruto)
 * 
 * Retourne les d√©tails complets incluant: synopsis, studios, genres, relations, streaming, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/anime/:id", async (req, res) => {
  let animeId = req.params.id;
  
  if (!animeId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  animeId = cleanSourceId(animeId, 'jikan');
  
  // Valider que l'ID est un nombre
  if (!/^\d+$/.test(animeId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 20 pour Naruto)"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getJikanAnimeByIdLib(parseInt(animeId, 10));
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/anime/:id:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un manga sur Jikan (MyAnimeList)
 * GET /jikan/manga/:id
 * 
 * :id - ID MyAnimeList du manga (ex: 11 pour Naruto)
 * 
 * Retourne les d√©tails complets incluant: synopsis, auteurs, genres, relations, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/manga/:id", async (req, res) => {
  let mangaId = req.params.id;
  
  if (!mangaId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  mangaId = cleanSourceId(mangaId, 'jikan');
  
  // Valider que l'ID est un nombre
  if (!/^\d+$/.test(mangaId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 11 pour Naruto)"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getJikanMangaByIdLib(parseInt(mangaId, 10));
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/manga/:id:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Comic Vine (Comics US)
// -----------------------------

/**
 * GET /comicvine/search
 * Recherche de comics/volumes sur Comic Vine
 * 
 * Param√®tres:
 * - q: terme de recherche (obligatoire)
 * - type: type de ressource (volume, issue, character, person) - d√©faut: volume
 * - max: nombre maximum de r√©sultats (1-100, d√©faut: 20)
 * 
 * N√©cessite une cl√© API Comic Vine (configur√©e c√¥t√© serveur)
 */
app.get("/comicvine/search", async (req, res) => {
  const q = req.query.q;
  const type = req.query.type || 'volume';
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), COMICVINE_MAX_LIMIT) : COMICVINE_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Valider le type de ressource
  const validTypes = ['volume', 'issue', 'character', 'person'];
  if (!validTypes.includes(type)) {
    return res.status(400).json({ 
      error: "Type de ressource invalide",
      validTypes,
      hint: "Utilisez 'volume' pour les s√©ries de comics, 'issue' pour les num√©ros individuels"
    });
  }
  
  try {
    const result = await searchComicVineLib(q, { type, max });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /comicvine/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /comicvine/volume/:id
 * R√©cup√®re les d√©tails d'un volume (s√©rie) Comic Vine
 * 
 * :id - ID Comic Vine du volume (ex: 796 pour Batman)
 * 
 * Retourne les d√©tails complets incluant: issues, personnages, cr√©ateurs, etc.
 */
app.get("/comicvine/volume/:id", async (req, res) => {
  let volumeId = req.params.id;
  
  if (!volumeId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  volumeId = cleanSourceId(volumeId, 'comicvine');
  
  if (!/^\d+$/.test(volumeId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 796 pour Batman)"
    });
  }
  
  try {
    const result = await getComicVineVolumeLib(parseInt(volumeId, 10));
    if (!result) {
      return res.status(404).json({ error: `Volume ${volumeId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /comicvine/volume/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /comicvine/issue/:id
 * R√©cup√®re les d√©tails d'un issue (num√©ro) Comic Vine
 * 
 * :id - ID Comic Vine de l'issue
 * 
 * Retourne les d√©tails complets incluant: personnages, √©quipes, cr√©ateurs, etc.
 */
app.get("/comicvine/issue/:id", async (req, res) => {
  let issueId = req.params.id;
  
  if (!issueId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  issueId = cleanSourceId(issueId, 'comicvine');
  
  if (!/^\d+$/.test(issueId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier"
    });
  }
  
  try {
    const result = await getComicVineIssueLib(parseInt(issueId, 10));
    if (!result) {
      return res.status(404).json({ error: `Issue ${issueId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /comicvine/issue/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints MangaDex (Manga)
// -----------------------------

/**
 * GET /mangadex/search
 * Recherche de manga sur MangaDex
 * 
 * Param√®tres:
 * - q: terme de recherche (obligatoire)
 * - lang: filtrer par langue disponible (ex: fr, en, ja)
 * - max: nombre maximum de r√©sultats (1-100, d√©faut: 20)
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/mangadex/search", async (req, res) => {
  const q = req.query.q;
  const lang = req.query.lang || null;
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), MANGADEX_MAX_LIMIT) : MANGADEX_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchMangaDexLib(q, { lang, max });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /mangadex/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /mangadex/manga/:id
 * R√©cup√®re les d√©tails d'un manga MangaDex par UUID
 * 
 * :id - UUID MangaDex du manga (ex: a1c7c817-4e59-43b7-9365-09675a149a6f pour One Piece)
 * 
 * Retourne les d√©tails complets incluant: description multilangue, auteurs, tags, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/mangadex/manga/:id", async (req, res) => {
  let mangaId = req.params.id;
  
  if (!mangaId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  mangaId = cleanSourceId(mangaId, 'mangadex');
  
  // Valider le format UUID
  if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(mangaId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un UUID (ex: a1c7c817-4e59-43b7-9365-09675a149a6f)"
    });
  }
  
  try {
    const result = await getMangaDexByIdLib(mangaId);
    if (!result) {
      return res.status(404).json({ error: `Manga ${mangaId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /mangadex/manga/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Bedetheque (BD Franco-Belge)
// -----------------------------

/**
 * GET /bedetheque/search
 * Recherche de s√©ries BD sur Bedetheque (scraping via FlareSolverr)
 * 
 * Param√®tres:
 * - q: terme de recherche (obligatoire)
 * - max: nombre maximum de r√©sultats (1-50, d√©faut: 20)
 * 
 * Note: Cette API utilise du scraping, les r√©sultats peuvent varier.
 * PAS DE CL√â API REQUISE !
 */
app.get("/bedetheque/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), 50) : BEDETHEQUE_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchBedethequeLib(q, { max });
    addCacheHeaders(res, 600); // Cache 10 min car scraping
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /bedetheque/search/albums
 * Recherche d'albums BD sur Bedetheque
 * 
 * Param√®tres:
 * - q: terme de recherche (recherche dans les s√©ries puis liste leurs albums)
 * - serieId: ID de s√©rie Bedetheque pour lister directement ses albums (optionnel)
 * - max: nombre maximum de r√©sultats (1-50, d√©faut: 20)
 * 
 * Note: Cette API recherche d'abord les s√©ries correspondantes, puis r√©cup√®re leurs albums.
 * Pour cibler une s√©rie sp√©cifique, utilisez le param√®tre serieId.
 */
app.get("/bedetheque/search/albums", async (req, res) => {
  const q = req.query.q || '';
  const serieId = req.query.serieId || req.query.serie_id || '';
  const serieName = req.query.serieName || req.query.serie_name || '';
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), 50) : BEDETHEQUE_DEFAULT_MAX;
  
  // Au moins un crit√®re de recherche requis
  if (!q && !serieId) {
    return res.status(400).json({ 
      error: "Au moins un param√®tre de recherche requis",
      hint: "Utilisez q (recherche) ou serieId + serieName. Utilisez /bedetheque/search pour trouver l'ID d'une s√©rie."
    });
  }
  
  try {
    const result = await searchBedethequeAlbumsLib(q, { max, serieId: serieId || null, serieName: serieName || null });
    addCacheHeaders(res, 600); // Cache 10 min car scraping
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/search/albums:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /bedetheque/serie/:id
 * R√©cup√®re les d√©tails d'une s√©rie Bedetheque par ID
 * 
 * :id - ID Bedetheque de la s√©rie (ex: 91 pour Ast√©rix)
 * 
 * Retourne les d√©tails incluant: synopsis, albums, auteurs, etc.
 * Note: Cette API utilise du scraping, certaines donn√©es peuvent √™tre incompl√®tes.
 */
app.get("/bedetheque/serie/:id", async (req, res) => {
  const serieId = req.params.id;
  
  if (!serieId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  if (!/^\d+$/.test(serieId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 91 pour Ast√©rix)"
    });
  }
  
  try {
    const result = await getBedethequeSerieByIdLib(parseInt(serieId, 10));
    if (!result || !result.name) {
      return res.status(404).json({ error: `S√©rie ${serieId} non trouv√©e` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/serie/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /bedetheque/album/:id
 * R√©cup√®re les d√©tails d'un album Bedetheque par ID
 * 
 * :id - ID Bedetheque de l'album
 * 
 * Retourne les d√©tails incluant: synopsis, ISBN, auteurs, √©diteur, etc.
 * Note: Cette API utilise du scraping, certaines donn√©es peuvent √™tre incompl√®tes.
 */
app.get("/bedetheque/album/:id", async (req, res) => {
  let albumId = req.params.id;
  
  if (!albumId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  albumId = cleanSourceId(albumId, 'bedetheque');
  
  if (!/^\d+$/.test(albumId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier"
    });
  }
  
  try {
    const result = await getBedethequeAlbumByIdLib(parseInt(albumId, 10));
    if (!result || !result.title) {
      return res.status(404).json({ error: `Album ${albumId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/album/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints JeuxVideo.com (JVC)
// -----------------------------

/**
 * @route GET /jvc/search
 * @description Recherche de jeux sur JeuxVideo.com (fran√ßais)
 * @param {string} q - Terme de recherche (obligatoire)
 * @param {number} max - Nombre max de r√©sultats (optionnel, d√©faut 20)
 */
app.get("/jvc/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : JVC_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchJVCLib(q, { max });
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jvc/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * @route GET /jvc/game/:id
 * @description D√©tails d'un jeu sur JeuxVideo.com
 * @param {string} id - ID du jeu JVC (obligatoire)
 */
app.get("/jvc/game/:id", async (req, res) => {
  const gameId = req.params.id;
  
  if (!gameId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  if (!/^\d+$/.test(gameId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 77113)"
    });
  }
  
  try {
    const result = await getJVCGameByIdLib(parseInt(gameId, 10));
    if (!result || !result.title) {
      return res.status(404).json({ error: `Jeu ${gameId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jvc/game/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Mega Construx
// -----------------------------

/**
 * Recherche de produits Mega Construx
 * @route GET /mega/search
 * @queryparam q - Terme de recherche (requis)
 * @queryparam max - Nombre max de r√©sultats (d√©faut: 20, max: 100)
 * @queryparam page - Page de r√©sultats (d√©faut: 1)
 * @queryparam lang - Langue (fr-FR, en-US, de-DE, es-ES, it-IT, nl-NL, en-GB, etc.)
 */
app.get("/mega/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : MEGA_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const lang = req.query.lang || MEGA_DEFAULT_LANG;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    const result = await searchMegaLib(q, { max, page, lang });
    addCacheHeaders(res, 1800); // Cache 30 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * R√©cup√®re les d√©tails d'un produit Mega Construx par ID ou SKU
 * @route GET /mega/product/:id
 * @param id - ID Shopify ou SKU du produit
 * @queryparam lang - Langue (fr-FR, en-US, de-DE, es-ES, it-IT, nl-NL, en-GB, etc.)
 */
app.get("/mega/product/:id", async (req, res) => {
  const productId = req.params.id;
  const lang = req.query.lang || MEGA_DEFAULT_LANG;
  
  if (!productId) return res.status(400).json({ error: "ID ou SKU manquant" });
  
  try {
    const result = await getMegaProductByIdLib(productId, { lang });
    if (!result || !result.title) {
      return res.status(404).json({ error: `Produit ${productId} non trouv√©` });
    }
    
    // R√©cup√©rer automatiquement les manuels de construction
    // Utiliser le SKU du produit s'il existe, sinon le productId original
    // Les instructions sont uniquement sur le site US, donc on ignore la langue
    const skuForInstructions = result.sku || productId;
    if (skuForInstructions) {
      try {
        const instructionsResult = await getMegaInstructions(skuForInstructions);
        // getMegaInstructions retourne un objet unique avec instructionsUrl, on le convertit en tableau
        if (instructionsResult && instructionsResult.instructionsUrl) {
          result.instructions = [{
            url: instructionsResult.instructionsUrl,
            format: instructionsResult.format || 'PDF',
            productName: instructionsResult.productName
          }];
        } else {
          result.instructions = [];
        }
      } catch (instrErr) {
        // Si √©chec avec le SKU du produit, essayer avec le productId original si diff√©rent
        if (result.sku && result.sku.toUpperCase() !== productId.toUpperCase()) {
          try {
            const instructionsResult2 = await getMegaInstructions(productId);
            if (instructionsResult2 && instructionsResult2.instructionsUrl) {
              result.instructions = [{
                url: instructionsResult2.instructionsUrl,
                format: instructionsResult2.format || 'PDF',
                productName: instructionsResult2.productName
              }];
            } else {
              result.instructions = [];
            }
          } catch (instrErr2) {
            console.log(`Manuels non trouv√©s pour Mega ${productId}:`, instrErr2.message);
            result.instructions = [];
          }
        } else {
          console.log(`Manuels non trouv√©s pour Mega ${skuForInstructions}:`, instrErr.message);
          result.instructions = [];
        }
      }
    } else {
      result.instructions = [];
    }
    
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/product/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * Liste les produits Mega par franchise/th√®me
 * @route GET /mega/franchise/:franchise
 * @param franchise - Nom de la franchise (pokemon, halo, barbie, hotwheels)
 * @queryparam max - Nombre max de r√©sultats (d√©faut: 20)
 * @queryparam page - Page de r√©sultats (d√©faut: 1)
 * @queryparam lang - Langue (fr-FR, en-US, de-DE, es-ES, it-IT, nl-NL, en-GB, etc.)
 */
app.get("/mega/franchise/:franchise", async (req, res) => {
  const franchise = req.params.franchise;
  const max = req.query.max ? parseInt(req.query.max, 10) : MEGA_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const lang = req.query.lang || MEGA_DEFAULT_LANG;
  
  // Mapping des franchises populaires
  const franchiseMap = {
    'pokemon': 'mega pokemon',
    'halo': 'mega halo',
    'barbie': 'mega barbie',
    'hotwheels': 'mega hot wheels',
    'hot-wheels': 'mega hot wheels',
    'bloks': 'mega bloks',
    'construx': 'mega construx'
  };
  
  const searchQuery = franchiseMap[franchise.toLowerCase()] || `mega ${franchise}`;
  
  try {
    const result = await searchMegaLib(searchQuery, { max, page, lang });
    result.franchise = franchise;
    addCacheHeaders(res, 1800);
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/franchise/:franchise:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * Liste les langues support√©es pour Mega Construx
 * @route GET /mega/languages
 */
app.get("/mega/languages", (req, res) => {
  const languages = {
    US: {
      region: 'Am√©rique',
      baseUrl: MEGA_BASE_URL_US,
      currency: 'USD',
      languages: ['en-US', 'es-MX', 'fr-CA', 'pt-BR', 'en-CA']
    },
    EU: {
      region: 'Europe',
      baseUrl: MEGA_BASE_URL_EU,
      currency: 'EUR',
      languages: ['fr-FR', 'de-DE', 'es-ES', 'it-IT', 'nl-NL', 'en-GB', 'pl-PL', 'tr-TR', 'el-GR', 'ru-RU']
    }
  };
  
  addCacheHeaders(res, 86400); // Cache 24h
  res.json({
    default: MEGA_DEFAULT_LANG,
    regions: languages,
    source: 'mega'
  });
});

/**
 * R√©cup√®re les instructions de montage pour un produit Mega par SKU
 * @route GET /mega/instructions/:sku
 * @param sku - SKU du produit (ex: HMW05, HTH96)
 */
app.get("/mega/instructions/:sku", async (req, res) => {
  const sku = req.params.sku;
  
  if (!sku) return res.status(400).json({ error: "SKU manquant" });
  
  try {
    const result = await getMegaInstructions(sku);
    addCacheHeaders(res, 86400); // Cache 24h
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/instructions/:sku:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©es')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * Liste toutes les instructions disponibles pour une cat√©gorie
 * @route GET /mega/instructions
 * @queryparam category - Cat√©gorie (pokemon, halo, barbie, hot-wheels, tesla, etc.)
 */
app.get("/mega/instructions", async (req, res) => {
  const category = req.query.category || '';
  
  try {
    const result = await listMegaInstructions(category);
    addCacheHeaders(res, 21600); // Cache 6h
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/instructions:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// ============================================================================
// BARCODE - Identification par code-barres (UPC, EAN, ISBN)
// ============================================================================

/**
 * D√©tecte le type de code-barres
 * @param {string} code - Code-barres
 * @returns {object} - Type et informations
 */
function detectBarcodeType(code) {
  // Nettoyer le code (retirer espaces et tirets)
  const cleanCode = code.replace(/[-\s]/g, '');
  
  // ISBN-10: 10 chiffres (ou 9 + X)
  if (/^(\d{9}[\dX])$/.test(cleanCode)) {
    return { type: 'ISBN-10', code: cleanCode, category: 'book' };
  }
  
  // ISBN-13: 13 chiffres commen√ßant par 978 ou 979
  if (/^(978|979)\d{10}$/.test(cleanCode)) {
    return { type: 'ISBN-13', code: cleanCode, category: 'book' };
  }
  
  // EAN-13: 13 chiffres
  if (/^\d{13}$/.test(cleanCode)) {
    // Pr√©fixes connus pour jeux vid√©o
    const prefix = cleanCode.substring(0, 3);
    // 500 = UK, 300-379 = France, 400-440 = Allemagne, 840-849 = Espagne, 800-839 = Italie
    // Certains pr√©fixes sont souvent utilis√©s pour les jeux vid√©o
    return { type: 'EAN-13', code: cleanCode, category: 'general' };
  }
  
  // UPC-A: 12 chiffres
  if (/^\d{12}$/.test(cleanCode)) {
    return { type: 'UPC-A', code: cleanCode, category: 'general' };
  }
  
  // EAN-8: 8 chiffres
  if (/^\d{8}$/.test(cleanCode)) {
    return { type: 'EAN-8', code: cleanCode, category: 'general' };
  }
  
  // Code inconnu
  return { type: 'unknown', code: cleanCode, category: 'unknown' };
}

/**
 * Convertit ISBN-10 en ISBN-13
 * @param {string} isbn10 - ISBN-10
 * @returns {string} - ISBN-13
 */
function isbn10ToIsbn13(isbn10) {
  const cleanIsbn = isbn10.replace(/[-\s]/g, '');
  if (cleanIsbn.length !== 10) return null;
  
  const isbn13Base = '978' + cleanIsbn.substring(0, 9);
  
  // Calculer le chiffre de contr√¥le ISBN-13
  let sum = 0;
  for (let i = 0; i < 12; i++) {
    sum += parseInt(isbn13Base[i]) * (i % 2 === 0 ? 1 : 3);
  }
  const checkDigit = (10 - (sum % 10)) % 10;
  
  return isbn13Base + checkDigit;
}

/**
 * Recherche un produit par UPC/EAN sur UPC Item DB
 * @param {string} code - Code UPC ou EAN
 * @returns {Promise<object>} - Informations produit
 */
async function searchUpcItemDb(code) {
  const url = `${UPCITEMDB_BASE_URL}?upc=${encodeURIComponent(code)}`;
  
  console.log(`[Barcode] UPC Item DB: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('Limite quotidienne UPC Item DB atteinte (100 req/jour)');
    }
    throw new Error(`Erreur UPC Item DB: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (data.code === 'OK' && data.items && data.items.length > 0) {
    const item = data.items[0];
    return {
      found: true,
      source: 'upcitemdb',
      barcode: code,
      title: item.title || null,
      description: item.description || null,
      brand: item.brand || null,
      category: item.category || null,
      images: item.images || [],
      offers: (item.offers || []).map(o => ({
        merchant: o.merchant,
        price: o.price,
        currency: o.currency || 'USD',
        link: o.link
      })),
      raw: item
    };
  }
  
  return { found: false, source: 'upcitemdb', barcode: code };
}

/**
 * Recherche un produit par UPC/EAN sur Open Food Facts
 * @param {string} code - Code UPC ou EAN
 * @returns {Promise<object>} - Informations produit
 */
async function searchOpenFoodFacts(code) {
  const url = `${OPENFOODFACTS_BASE_URL}/${encodeURIComponent(code)}.json`;
  
  console.log(`[Barcode] Open Food Facts: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': `ToysAPI/1.0 - Educational Project`
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Open Food Facts: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (data.status === 1 && data.product) {
    const p = data.product;
    return {
      found: true,
      source: 'openfoodfacts',
      barcode: code,
      title: p.product_name || p.product_name_fr || null,
      brand: p.brands || null,
      category: p.categories || null,
      image: p.image_url || p.image_front_url || null,
      quantity: p.quantity || null,
      ingredients: p.ingredients_text_fr || p.ingredients_text || null,
      nutriscore: p.nutriscore_grade || null,
      raw: p
    };
  }
  
  return { found: false, source: 'openfoodfacts', barcode: code };
}

/**
 * Recherche un livre par ISBN
 * @param {string} isbn - ISBN-10 ou ISBN-13
 * @param {string} googleBooksApiKey - Cl√© API Google Books (optionnelle)
 * @returns {Promise<object>} - Informations livre
 */
async function searchBookByIsbn(isbn, googleBooksApiKey = null, lang = null) {
  const results = {
    isbn: isbn,
    found: false,
    sources: [],
    lang: lang
  };
  
  // 1. OpenLibrary (gratuit, priorit√©)
  try {
    const olResult = await searchOpenLibraryByIsbn(isbn);
    if (olResult.books && olResult.books.length > 0) {
      const book = olResult.books[0];
      results.found = true;
      results.title = book.title;
      results.authors = book.authors;
      results.publisher = book.publisher;
      results.publishedDate = book.publishedDate;
      results.pageCount = book.pageCount;
      results.cover = book.thumbnail || book.cover;
      results.description = book.description;
      results.subjects = book.subjects;
      results.sources.push({
        name: 'openlibrary',
        data: book
      });
    }
  } catch (err) {
    console.error('[Barcode] OpenLibrary error:', err.message);
  }
  
  // 2. Google Books (si cl√© fournie)
  if (googleBooksApiKey) {
    try {
      let gbUrl = `${GOOGLE_BOOKS_BASE_URL}/volumes?q=isbn:${isbn}&key=${googleBooksApiKey}`;
      // Ajouter restriction de langue si sp√©cifi√©e (fr, en, de, etc.)
      if (lang) {
        const langCode = lang.substring(0, 2).toLowerCase();
        gbUrl += `&langRestrict=${langCode}`;
      }
      const gbResponse = await fetch(gbUrl);
      
      if (gbResponse.ok) {
        const gbData = await gbResponse.json();
        if (gbData.items && gbData.items.length > 0) {
          const vol = gbData.items[0].volumeInfo;
          results.found = true;
          if (!results.title) results.title = vol.title;
          if (!results.authors) results.authors = vol.authors;
          if (!results.publisher) results.publisher = vol.publisher;
          if (!results.publishedDate) results.publishedDate = vol.publishedDate;
          if (!results.pageCount) results.pageCount = vol.pageCount;
          if (!results.cover && vol.imageLinks) {
            results.cover = vol.imageLinks.thumbnail || vol.imageLinks.smallThumbnail;
          }
          if (!results.description) results.description = vol.description;
          
          results.sources.push({
            name: 'googlebooks',
            data: {
              id: gbData.items[0].id,
              title: vol.title,
              subtitle: vol.subtitle,
              authors: vol.authors,
              publisher: vol.publisher,
              publishedDate: vol.publishedDate,
              description: vol.description,
              pageCount: vol.pageCount,
              categories: vol.categories,
              averageRating: vol.averageRating,
              ratingsCount: vol.ratingsCount,
              imageLinks: vol.imageLinks,
              language: vol.language,
              previewLink: vol.previewLink,
              infoLink: vol.infoLink
            }
          });
        }
      }
    } catch (err) {
      console.error('[Barcode] Google Books error:', err.message);
    }
  }
  
  // 3. BNF (Biblioth√®que Nationale de France) pour livres fran√ßais
  try {
    const bnfResult = await searchBnfByIsbn(isbn);
    if (bnfResult.found) {
      results.found = true;
      if (!results.title) results.title = bnfResult.title;
      if (!results.authors) results.authors = bnfResult.authors;
      if (!results.publisher) results.publisher = bnfResult.publisher;
      if (!results.publishedDate) results.publishedDate = bnfResult.date;
      
      results.sources.push({
        name: 'bnf',
        data: bnfResult
      });
    }
  } catch (err) {
    console.error('[Barcode] BNF error:', err.message);
  }
  
  return results;
}

/**
 * Recherche un livre sur la BNF par ISBN
 * @param {string} isbn - ISBN
 * @returns {Promise<object>} - R√©sultat BNF
 */
async function searchBnfByIsbn(isbn) {
  // API SRU de la BNF
  const cleanIsbn = isbn.replace(/[-\s]/g, '');
  const url = `https://catalogue.bnf.fr/api/SRU?version=1.2&operation=searchRetrieve&query=bib.isbn%20adj%20%22${encodeURIComponent(cleanIsbn)}%22&recordSchema=dublincore&maximumRecords=1`;
  
  console.log(`[Barcode] BNF: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/xml',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur BNF: ${response.status}`);
  }
  
  const xml = await response.text();
  
  // Parser le XML simple (Dublin Core)
  const titleMatch = xml.match(/<dc:title>([^<]+)<\/dc:title>/);
  const creatorMatch = xml.match(/<dc:creator>([^<]+)<\/dc:creator>/g);
  const publisherMatch = xml.match(/<dc:publisher>([^<]+)<\/dc:publisher>/);
  const dateMatch = xml.match(/<dc:date>([^<]+)<\/dc:date>/);
  const descMatch = xml.match(/<dc:description>([^<]+)<\/dc:description>/);
  const subjectMatch = xml.match(/<dc:subject>([^<]+)<\/dc:subject>/g);
  
  if (titleMatch) {
    return {
      found: true,
      source: 'bnf',
      isbn: cleanIsbn,
      title: decodeHtmlEntities(titleMatch[1]),
      authors: creatorMatch ? creatorMatch.map(m => {
        const match = m.match(/<dc:creator>([^<]+)<\/dc:creator>/);
        return match ? decodeHtmlEntities(match[1]) : null;
      }).filter(Boolean) : [],
      publisher: publisherMatch ? decodeHtmlEntities(publisherMatch[1]) : null,
      date: dateMatch ? dateMatch[1] : null,
      description: descMatch ? decodeHtmlEntities(descMatch[1]) : null,
      subjects: subjectMatch ? subjectMatch.map(m => {
        const match = m.match(/<dc:subject>([^<]+)<\/dc:subject>/);
        return match ? decodeHtmlEntities(match[1]) : null;
      }).filter(Boolean) : []
    };
  }
  
  return { found: false, source: 'bnf', isbn: cleanIsbn };
}

/**
 * Tente d'identifier un jeu vid√©o √† partir des infos produit
 * @param {object} productInfo - Infos du produit (title, category, brand)
 * @param {object} apiKeys - Cl√©s API optionnelles
 * @returns {Promise<object|null>} - Infos jeu vid√©o ou null
 */
async function tryIdentifyVideoGame(productInfo, apiKeys = {}) {
  if (!productInfo.title) return null;
  
  const title = productInfo.title;
  const category = (productInfo.category || '').toLowerCase();
  const brand = (productInfo.brand || '').toLowerCase();
  
  // Mots-cl√©s sugg√©rant un jeu vid√©o
  const gameKeywords = ['game', 'jeu', 'video', 'nintendo', 'playstation', 'xbox', 'ps4', 'ps5', 'switch', 'steam', 'pc game', 'console'];
  const isLikelyGame = gameKeywords.some(kw => 
    title.toLowerCase().includes(kw) || category.includes(kw) || brand.includes(kw)
  );
  
  if (!isLikelyGame) return null;
  
  // Extraire le nom du jeu (retirer plateforme, √©dition, etc.)
  let gameName = title
    .replace(/\b(ps[345]|xbox|switch|nintendo|pc|steam|playstation|edition|day one|collector|goty|game of the year)\b/gi, '')
    .replace(/\s{2,}/g, ' ')
    .trim();
  
  // Essayer RAWG si cl√© disponible
  if (apiKeys.rawg) {
    try {
      const rawgUrl = `${RAWG_BASE_URL}/games?key=${apiKeys.rawg}&search=${encodeURIComponent(gameName)}&page_size=1`;
      const response = await fetch(rawgUrl);
      if (response.ok) {
        const data = await response.json();
        if (data.results && data.results.length > 0) {
          const game = data.results[0];
          return {
            identified: true,
            source: 'rawg',
            game: {
              id: game.id,
              name: game.name,
              slug: game.slug,
              released: game.released,
              rating: game.rating,
              platforms: game.platforms?.map(p => p.platform.name) || [],
              genres: game.genres?.map(g => g.name) || [],
              background_image: game.background_image
            }
          };
        }
      }
    } catch (err) {
      console.error('[Barcode] RAWG identification error:', err.message);
    }
  }
  
  // Essayer JVC (scraping) pour les jeux fran√ßais
  try {
    const jvcResult = await searchJVC(gameName, { maxResults: 1 });
    if (jvcResult.results && jvcResult.results.length > 0) {
      const game = jvcResult.results[0];
      return {
        identified: true,
        source: 'jvc',
        game: {
          id: game.id,
          name: game.title,
          url: game.url,
          platforms: game.platforms || [],
          releaseDate: game.releaseDate,
          image: game.image
        }
      };
    }
  } catch (err) {
    console.error('[Barcode] JVC identification error:', err.message);
  }
  
  return null;
}

/**
 * Recherche compl√®te par code-barres
 * @param {string} code - Code-barres (UPC, EAN, ISBN)
 * @param {object} options - Options (apiKeys, enrichGameData)
 * @returns {Promise<object>} - R√©sultat complet
 */
async function searchByBarcode(code, options = {}) {
  const { apiKeys = {}, enrichGameData = true, enrichMusicData = true } = options;
  
  const barcodeInfo = detectBarcodeType(code);
  
  const result = {
    barcode: barcodeInfo.code,
    barcodeType: barcodeInfo.type,
    category: barcodeInfo.category,
    product: null,
    book: null,
    videoGame: null,
    music: null,
    sources: [],
    searchedAt: new Date().toISOString()
  };
  
  // === Traitement ISBN (Livres) ===
  if (barcodeInfo.category === 'book' || barcodeInfo.type === 'ISBN-10' || barcodeInfo.type === 'ISBN-13') {
    let isbn = barcodeInfo.code;
    if (barcodeInfo.type === 'ISBN-10') {
      // Convertir en ISBN-13 pour plus de compatibilit√©
      const isbn13 = isbn10ToIsbn13(isbn);
      result.isbn10 = isbn;
      result.isbn13 = isbn13;
      isbn = isbn13 || isbn;
    } else {
      result.isbn13 = isbn;
    }
    
    const bookResult = await searchBookByIsbn(isbn, apiKeys.googleBooks);
    
    if (bookResult.found) {
      result.category = 'book';
      result.book = {
        title: bookResult.title,
        authors: bookResult.authors,
        publisher: bookResult.publisher,
        publishedDate: bookResult.publishedDate,
        pageCount: bookResult.pageCount,
        cover: bookResult.cover,
        description: bookResult.description,
        subjects: bookResult.subjects
      };
      result.sources = bookResult.sources.map(s => s.name);
    }
    
    return result;
  }
  
  // === Traitement UPC/EAN (Produits g√©n√©raux) ===
  
  // 1. UPC Item DB (base g√©n√©raliste)
  try {
    const upcResult = await searchUpcItemDb(barcodeInfo.code);
    if (upcResult.found) {
      result.product = {
        title: upcResult.title,
        description: upcResult.description,
        brand: upcResult.brand,
        category: upcResult.category,
        images: upcResult.images,
        offers: upcResult.offers
      };
      result.sources.push('upcitemdb');
      
      // Tenter d'identifier comme jeu vid√©o
      if (enrichGameData) {
        const gameInfo = await tryIdentifyVideoGame(upcResult, apiKeys);
        if (gameInfo) {
          result.category = 'videogame';
          result.videoGame = gameInfo;
        }
      }
      
      // Tenter d'identifier comme musique (CD, vinyle)
      if (enrichMusicData && !result.videoGame) {
        const musicInfo = await tryIdentifyMusic(upcResult, barcodeInfo.code);
        if (musicInfo) {
          result.category = 'music';
          result.music = musicInfo;
        }
      }
    }
  } catch (err) {
    console.error('[Barcode] UPC Item DB error:', err.message);
    // Continue avec d'autres sources
  }
  
  // 2. Open Food Facts (pour produits alimentaires)
  if (!result.product) {
    try {
      const offResult = await searchOpenFoodFacts(barcodeInfo.code);
      if (offResult.found) {
        result.product = {
          title: offResult.title,
          brand: offResult.brand,
          category: offResult.category,
          images: offResult.image ? [offResult.image] : [],
          quantity: offResult.quantity,
          nutriscore: offResult.nutriscore
        };
        result.category = 'food';
        result.sources.push('openfoodfacts');
      }
    } catch (err) {
      console.error('[Barcode] Open Food Facts error:', err.message);
    }
  }
  
  // 3. Fallback Musique: Si rien trouv√©, tenter directement sur MusicBrainz/Discogs
  if (!result.product && !result.book && enrichMusicData) {
    try {
      const musicResult = await searchMusicByBarcode(barcodeInfo.code, apiKeys.discogs);
      if (musicResult.found) {
        result.category = 'music';
        result.music = musicResult;
        result.sources.push(...musicResult.sources);
      }
    } catch (err) {
      console.error('[Barcode] Music fallback error:', err.message);
    }
  }
  
  // D√©terminer si produit trouv√©
  result.found = !!(result.product || result.book || result.videoGame || result.music);
  
  return result;
}

/**
 * Tente d'identifier un album de musique √† partir des infos produit
 * @param {object} productInfo - Infos du produit (title, category, brand)
 * @param {string} barcode - Code-barres original
 * @returns {Promise<object|null>} - Infos musique ou null
 */
async function tryIdentifyMusic(productInfo, barcode) {
  if (!productInfo.title) return null;
  
  const title = productInfo.title.toLowerCase();
  const category = (productInfo.category || '').toLowerCase();
  const brand = (productInfo.brand || '').toLowerCase();
  
  // Mots-cl√©s sugg√©rant un CD/vinyle/musique
  const musicKeywords = [
    'cd', 'vinyl', 'vinyle', 'album', 'lp', 'ep', 'record', 'disque',
    'music', 'musique', 'audio', 'soundtrack', 'ost', 'compilation',
    'sony music', 'universal music', 'warner music', 'emi', 'bmg',
    'atlantic', 'columbia', 'rca', 'decca', 'polydor', 'virgin',
    'parlophone', 'capitol', 'interscope', 'def jam', 'island'
  ];
  
  const isLikelyMusic = musicKeywords.some(kw => 
    title.includes(kw) || category.includes(kw) || brand.includes(kw)
  );
  
  if (!isLikelyMusic) return null;
  
  // Rechercher sur MusicBrainz par code-barres
  try {
    const mbResult = await searchMusicBrainzByBarcode(barcode);
    if (mbResult.found) {
      return {
        identified: true,
        source: 'musicbrainz',
        title: mbResult.title,
        artist: mbResult.artist,
        releaseDate: mbResult.date,
        label: mbResult.label,
        coverUrl: mbResult.coverUrl,
        mbId: mbResult.id,
        releaseGroupId: mbResult.releaseGroupId,
        mbUrl: mbResult.mbUrl,
        sources: ['musicbrainz']
      };
    }
  } catch (err) {
    console.error('[Barcode] MusicBrainz identification error:', err.message);
  }
  
  return null;
}

/**
 * Recherche directe de musique par code-barres (MusicBrainz + Discogs)
 * @param {string} barcode - Code-barres
 * @param {string} discogsToken - Token Discogs (optionnel)
 * @returns {Promise<object>} - R√©sultat musique
 */
async function searchMusicByBarcode(barcode, discogsToken = null) {
  const result = {
    found: false,
    barcode,
    sources: []
  };
  
  // 1. MusicBrainz
  try {
    metrics.sources.musicbrainz.requests++;
    const mbResult = await searchMusicBrainzByBarcode(barcode);
    if (mbResult.found) {
      result.found = true;
      result.title = mbResult.title;
      result.artist = mbResult.artist;
      result.releaseDate = mbResult.date;
      result.country = mbResult.country;
      result.label = mbResult.label;
      result.catalogNumber = mbResult.catalogNumber;
      result.coverUrl = mbResult.coverUrl;
      result.mbId = mbResult.id;
      result.releaseGroupId = mbResult.releaseGroupId;
      result.mbUrl = mbResult.mbUrl;
      result.sources.push('musicbrainz');
    }
  } catch (err) {
    console.error('[Barcode] MusicBrainz error:', err.message);
  }
  
  // 2. Discogs (compl√©ment ou fallback)
  try {
    metrics.sources.discogs.requests++;
    const discogsResult = await searchDiscogsByBarcode(barcode, discogsToken);
    if (discogsResult.found) {
      result.found = true;
      result.sources.push('discogs');
      
      // Compl√©ter les donn√©es manquantes
      if (!result.title) result.title = discogsResult.albumTitle;
      if (!result.artist) result.artist = discogsResult.artist;
      if (!result.coverUrl) result.coverUrl = discogsResult.coverUrl;
      if (!result.releaseDate && discogsResult.year) result.releaseDate = discogsResult.year.toString();
      
      // Donn√©es sp√©cifiques Discogs
      result.discogs = {
        id: discogsResult.id,
        format: discogsResult.format,
        label: discogsResult.label,
        genre: discogsResult.genre,
        country: discogsResult.country,
        url: discogsResult.discogsUrl
      };
    }
  } catch (err) {
    console.error('[Barcode] Discogs error:', err.message);
  }
  
  return result;
}

// === Endpoint principal code-barres ===
/**
 * Recherche par code-barres (livres, jeux vid√©o, musique, produits)
 * @route GET /barcode/:code
 * @param code - Code-barres (UPC, EAN, ISBN)
 * @queryparam googleBooksKey - Cl√© API Google Books (optionnel, header: X-GoogleBooks-Key)
 * @queryparam rawgKey - Cl√© API RAWG (optionnel, header: X-RAWG-Key)
 * @queryparam discogsToken - Token Discogs (optionnel, header: X-Discogs-Token)
 * @queryparam enrichGames - Enrichir avec donn√©es jeux vid√©o (true/false, d√©faut: true)
 * @queryparam enrichMusic - Enrichir avec donn√©es musique (true/false, d√©faut: true)
 */
app.get("/barcode/:code", async (req, res) => {
  const { code } = req.params;
  const googleBooksKey = req.query.googleBooksKey || req.headers['x-googlebooks-key'];
  const rawgKey = req.query.rawgKey || req.headers['x-rawg-key'];
  const discogsToken = req.query.discogsToken || req.headers['x-discogs-token'];
  // Support ancien param√®tre 'enrich' + nouveaux param√®tres sp√©cifiques
  const enrichGames = req.query.enrichGames !== 'false' && req.query.enrich !== 'false';
  const enrichMusic = req.query.enrichMusic !== 'false' && req.query.enrich !== 'false';
  
  if (!code || code.length < 8) {
    return res.status(400).json({ error: "Code-barres invalide (minimum 8 caract√®res)" });
  }
  
  // Cache key
  const cacheKey = `barcode:${code}:g${enrichGames}:m${enrichMusic}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.barcode.requests++;
    
    const result = await searchByBarcode(code, {
      apiKeys: {
        googleBooks: googleBooksKey,
        rawg: rawgKey,
        discogs: discogsToken
      },
      enrichGameData: enrichGames,
      enrichMusicData: enrichMusic
    });
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /barcode:", err);
    metrics.requests.errors++;
    metrics.sources.barcode.errors++;
    res.status(500).json({ error: err.message });
  }
});

// === Endpoint d√©tection type code-barres ===
/**
 * D√©tecte le type d'un code-barres
 * @route GET /barcode/detect/:code
 */
app.get("/barcode/detect/:code", (req, res) => {
  const { code } = req.params;
  
  if (!code || code.length < 8) {
    return res.status(400).json({ error: "Code-barres invalide" });
  }
  
  const info = detectBarcodeType(code);
  res.json(info);
});

// === Endpoint ISBN sp√©cifique (BNF + OpenLibrary + Google Books) ===
/**
 * Recherche un livre par ISBN
 * @route GET /barcode/isbn/:isbn
 * @param isbn - ISBN-10 ou ISBN-13
 * @queryparam googleBooksKey - Cl√© API Google Books (optionnel)
 * @queryparam lang - Langue pr√©f√©r√©e pour les r√©sultats (fr, en, de, etc.)
 */
app.get("/barcode/isbn/:isbn", async (req, res) => {
  const { isbn } = req.params;
  const googleBooksKey = req.query.googleBooksKey || req.headers['x-googlebooks-key'];
  const lang = req.query.lang || null;
  
  if (!isbn || isbn.replace(/[-\s]/g, '').length < 10) {
    return res.status(400).json({ error: "ISBN invalide" });
  }
  
  const cacheKey = `barcode:isbn:${isbn}:${lang || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.barcode.requests++;
    const result = await searchBookByIsbn(isbn, googleBooksKey, lang);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /barcode/isbn:", err);
    metrics.requests.errors++;
    metrics.sources.barcode.errors++;
    res.status(500).json({ error: err.message });
  }
});

// === Endpoint BNF (Biblioth√®que Nationale de France) ===
/**
 * Recherche un livre sur la BNF
 * @route GET /barcode/bnf/:isbn
 * @param isbn - ISBN du livre
 */
app.get("/barcode/bnf/:isbn", async (req, res) => {
  const { isbn } = req.params;
  
  if (!isbn || isbn.replace(/[-\s]/g, '').length < 10) {
    return res.status(400).json({ error: "ISBN invalide" });
  }
  
  const cacheKey = `barcode:bnf:${isbn}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.barcode.requests++;
    const result = await searchBnfByIsbn(isbn);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 86400); // Cache 24h (donn√©es BNF stables)
    res.json(result);
  } catch (err) {
    console.error("Erreur /barcode/bnf:", err);
    metrics.requests.errors++;
    metrics.sources.barcode.errors++;
    res.status(500).json({ error: err.message });
  }
});

// ============================================================================
// MUSIC - APIs pour albums de musique (MusicBrainz, Discogs, Deezer)
// ============================================================================

/**
 * Recherche sur MusicBrainz (release-group = album)
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, artist, type)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchMusicBrainz(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, artist = null, type = 'release-group' } = options;
  
  // Construire la requ√™te Lucene
  let luceneQuery = query;
  if (artist) {
    luceneQuery = `"${query}" AND artist:"${artist}"`;
  }
  
  const url = `${MUSICBRAINZ_BASE_URL}/${type}?query=${encodeURIComponent(luceneQuery)}&limit=${limit}&fmt=json`;
  
  console.log(`[MusicBrainz] Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)' // MusicBrainz exige un User-Agent identifiable
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const data = await response.json();
  const groups = data['release-groups'] || [];
  
  const results = groups.map(rg => ({
    id: rg.id,
    type: 'album',
    title: rg.title,
    artist: rg['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    artistId: rg['artist-credit']?.[0]?.artist?.id || null,
    releaseDate: rg['first-release-date'] || null,
    year: rg['first-release-date']?.substring(0, 4) || null,
    primaryType: rg['primary-type'] || null,
    secondaryTypes: rg['secondary-types'] || [],
    score: rg.score || null,
    // Cover art sera r√©cup√©r√© s√©par√©ment si besoin
    coverUrl: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-250`,
    coverUrlLarge: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-500`,
    mbUrl: `https://musicbrainz.org/release-group/${rg.id}`,
    source: 'musicbrainz'
  }));
  
  return {
    query,
    totalResults: data.count || results.length,
    count: results.length,
    results,
    source: 'musicbrainz'
  };
}

/**
 * R√©cup√®re les d√©tails d'un album MusicBrainz
 * @param {string} mbid - MusicBrainz ID (release-group)
 * @returns {Promise<object>} - D√©tails album
 */
async function getMusicBrainzAlbum(mbid) {
  const url = `${MUSICBRAINZ_BASE_URL}/release-group/${mbid}?inc=artists+releases+tags+ratings&fmt=json`;
  
  console.log(`[MusicBrainz] Album: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Album non trouv√©: ${mbid}`);
    }
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const rg = await response.json();
  
  // R√©cup√©rer la liste des pistes du premier release
  let tracks = [];
  if (rg.releases && rg.releases.length > 0) {
    try {
      const releaseId = rg.releases[0].id;
      const releaseUrl = `${MUSICBRAINZ_BASE_URL}/release/${releaseId}?inc=recordings&fmt=json`;
      const releaseResp = await fetch(releaseUrl, {
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
        }
      });
      if (releaseResp.ok) {
        const releaseData = await releaseResp.json();
        if (releaseData.media) {
          tracks = releaseData.media.flatMap((medium, mediumIdx) =>
            (medium.tracks || []).map((track, trackIdx) => ({
              position: track.position || trackIdx + 1,
              disc: mediumIdx + 1,
              title: track.title,
              duration: track.length ? Math.round(track.length / 1000) : null, // ms -> sec
              durationFormatted: track.length ? formatDuration(track.length) : null
            }))
          );
        }
      }
    } catch (err) {
      console.error('[MusicBrainz] Error fetching tracks:', err.message);
    }
  }
  
  return {
    id: rg.id,
    type: 'album',
    title: rg.title,
    artist: rg['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    artists: rg['artist-credit']?.map(ac => ({
      id: ac.artist?.id,
      name: ac.name || ac.artist?.name,
      joinPhrase: ac.joinphrase
    })) || [],
    releaseDate: rg['first-release-date'] || null,
    year: rg['first-release-date']?.substring(0, 4) || null,
    primaryType: rg['primary-type'] || null,
    secondaryTypes: rg['secondary-types'] || [],
    tags: (rg.tags || []).map(t => ({ name: t.name, count: t.count })).sort((a, b) => b.count - a.count),
    rating: rg.rating ? { value: rg.rating.value, votes: rg.rating['votes-count'] } : null,
    releases: (rg.releases || []).slice(0, 10).map(r => ({
      id: r.id,
      title: r.title,
      status: r.status,
      date: r.date,
      country: r.country,
      barcode: r.barcode
    })),
    tracks,
    trackCount: tracks.length,
    coverUrl: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-250`,
    coverUrlLarge: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-500`,
    mbUrl: `https://musicbrainz.org/release-group/${rg.id}`,
    source: 'musicbrainz'
  };
}

/**
 * Recherche un album par code-barres sur MusicBrainz
 * @param {string} barcode - Code-barres (UPC/EAN)
 * @returns {Promise<object>} - Album trouv√©
 */
async function searchMusicBrainzByBarcode(barcode) {
  const url = `${MUSICBRAINZ_BASE_URL}/release?query=barcode:${encodeURIComponent(barcode)}&fmt=json`;
  
  console.log(`[MusicBrainz] Barcode: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.releases || data.releases.length === 0) {
    return { found: false, barcode, source: 'musicbrainz' };
  }
  
  const release = data.releases[0];
  
  return {
    found: true,
    barcode,
    id: release.id,
    releaseGroupId: release['release-group']?.id,
    title: release.title,
    artist: release['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    date: release.date,
    country: release.country,
    status: release.status,
    label: release['label-info']?.[0]?.label?.name || null,
    catalogNumber: release['label-info']?.[0]?.['catalog-number'] || null,
    coverUrl: release['release-group']?.id 
      ? `${MUSICBRAINZ_COVER_URL}/release-group/${release['release-group'].id}/front-250` 
      : null,
    mbUrl: `https://musicbrainz.org/release/${release.id}`,
    source: 'musicbrainz'
  };
}

/**
 * Formate une dur√©e en ms vers "mm:ss"
 */
function formatDuration(ms) {
  const totalSeconds = Math.round(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

/**
 * Recherche sur Deezer
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, type: album|artist|track)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchDeezer(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, type = 'album' } = options;
  
  const url = `${DEEZER_BASE_URL}/search/${type}?q=${encodeURIComponent(query)}&limit=${limit}`;
  
  console.log(`[Deezer] Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Deezer: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (data.error) {
    throw new Error(`Deezer: ${data.error.message}`);
  }
  
  const results = (data.data || []).map(item => {
    if (type === 'album') {
      return {
        id: item.id,
        type: 'album',
        title: item.title,
        artist: item.artist?.name || null,
        artistId: item.artist?.id || null,
        coverUrl: item.cover_medium || item.cover,
        coverUrlLarge: item.cover_xl || item.cover_big,
        releaseDate: null, // Non disponible dans la recherche
        trackCount: item.nb_tracks || null,
        explicit: item.explicit_lyrics || false,
        genre: item.genre_id || null,
        deezerUrl: item.link,
        source: 'deezer'
      };
    } else if (type === 'artist') {
      return {
        id: item.id,
        type: 'artist',
        name: item.name,
        picture: item.picture_medium,
        pictureXl: item.picture_xl,
        nbAlbums: item.nb_album,
        nbFans: item.nb_fan,
        deezerUrl: item.link,
        source: 'deezer'
      };
    } else {
      // track
      return {
        id: item.id,
        type: 'track',
        title: item.title,
        artist: item.artist?.name,
        album: item.album?.title,
        albumId: item.album?.id,
        duration: item.duration,
        durationFormatted: formatDuration(item.duration * 1000),
        preview: item.preview, // URL MP3 30sec
        explicit: item.explicit_lyrics,
        deezerUrl: item.link,
        source: 'deezer'
      };
    }
  });
  
  return {
    query,
    type,
    totalResults: data.total || results.length,
    count: results.length,
    results,
    source: 'deezer'
  };
}

/**
 * R√©cup√®re les d√©tails d'un album Deezer
 * @param {number|string} albumId - ID album Deezer
 * @returns {Promise<object>} - D√©tails album
 */
async function getDeezerAlbum(albumId) {
  // Nettoyer l'ID (supprimer pr√©fixe music_ si pr√©sent)
  const cleanId = String(albumId).replace(/^music_/i, '');
  const url = `${DEEZER_BASE_URL}/album/${cleanId}`;
  
  console.log(`[Deezer] Album: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Album non trouv√©: ${albumId}`);
    }
    throw new Error(`Erreur Deezer: ${response.status}`);
  }
  
  const album = await response.json();
  
  if (album.error) {
    throw new Error(`Deezer: ${album.error.message || album.error.type || 'no data'}`);
  }
  
  if (!album.id) {
    throw new Error(`Deezer: Album non trouv√© (ID: ${cleanId})`);
  }
  
  return {
    id: album.id,
    type: 'album',
    title: album.title,
    upc: album.upc || null,
    artist: album.artist?.name || null,
    artistId: album.artist?.id || null,
    artistPicture: album.artist?.picture_medium || null,
    coverUrl: album.cover_medium || album.cover,
    coverUrlLarge: album.cover_xl || album.cover_big,
    releaseDate: album.release_date || null,
    year: album.release_date?.substring(0, 4) || null,
    duration: album.duration || null,
    durationFormatted: album.duration ? formatDuration(album.duration * 1000) : null,
    trackCount: album.nb_tracks || 0,
    fans: album.fans || 0,
    explicit: album.explicit_lyrics || false,
    genres: (album.genres?.data || []).map(g => g.name),
    label: album.label || null,
    tracks: (album.tracks?.data || []).map((t, idx) => ({
      position: idx + 1,
      id: t.id,
      title: t.title,
      duration: t.duration,
      durationFormatted: formatDuration(t.duration * 1000),
      preview: t.preview,
      explicit: t.explicit_lyrics
    })),
    contributors: (album.contributors || []).map(c => ({
      id: c.id,
      name: c.name,
      role: c.role,
      picture: c.picture_medium
    })),
    deezerUrl: album.link,
    source: 'deezer'
  };
}

/**
 * R√©cup√®re les d√©tails d'un artiste Deezer
 * @param {number|string} artistId - ID artiste Deezer
 * @returns {Promise<object>} - D√©tails artiste
 */
async function getDeezerArtist(artistId) {
  // Nettoyer l'ID (supprimer pr√©fixe music_ si pr√©sent)
  const cleanId = String(artistId).replace(/^music_/i, '');
  
  // R√©cup√©rer info artiste + top tracks + albums
  const [artistResp, topResp, albumsResp] = await Promise.all([
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}`),
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}/top?limit=10`),
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}/albums?limit=50`)
  ]);
  
  if (!artistResp.ok) {
    if (artistResp.status === 404) {
      throw new Error(`Artiste non trouv√©: ${artistId}`);
    }
    throw new Error(`Erreur Deezer: ${artistResp.status}`);
  }
  
  const artist = await artistResp.json();
  const topTracks = topResp.ok ? await topResp.json() : { data: [] };
  const albums = albumsResp.ok ? await albumsResp.json() : { data: [] };
  
  return {
    id: artist.id,
    type: 'artist',
    name: artist.name,
    picture: artist.picture_medium,
    pictureXl: artist.picture_xl,
    nbAlbums: artist.nb_album,
    nbFans: artist.nb_fan,
    topTracks: (topTracks.data || []).map(t => ({
      id: t.id,
      title: t.title,
      duration: t.duration,
      durationFormatted: formatDuration(t.duration * 1000),
      album: t.album?.title,
      albumCover: t.album?.cover_medium,
      preview: t.preview,
      rank: t.rank
    })),
    albums: (albums.data || []).map(a => ({
      id: a.id,
      title: a.title,
      coverUrl: a.cover_medium,
      releaseDate: a.release_date,
      type: a.record_type // album, single, ep, etc.
    })),
    deezerUrl: artist.link,
    source: 'deezer'
  };
}

/**
 * Recherche sur Discogs
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, type, token)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchDiscogs(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, type = 'release', token = null } = options;
  
  let url = `${DISCOGS_BASE_URL}/database/search?q=${encodeURIComponent(query)}&type=${type}&per_page=${limit}`;
  
  // Ajouter token si fourni (augmente la limite de requ√™tes)
  if (token) {
    url += `&token=${token}`;
  }
  
  console.log(`[Discogs] Search: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('Limite Discogs atteinte (60 req/min avec token, 25 sans)');
    }
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const data = await response.json();
  
  const results = (data.results || []).map(item => ({
    id: item.id,
    type: item.type,
    title: item.title,
    artist: item.title?.split(' - ')[0] || null,
    albumTitle: item.title?.split(' - ')[1] || item.title,
    year: item.year || null,
    country: item.country || null,
    format: item.format || [],
    label: item.label || [],
    genre: item.genre || [],
    style: item.style || [],
    coverUrl: item.cover_image || item.thumb,
    masterId: item.master_id || null,
    resourceUrl: item.resource_url,
    discogsUrl: item.uri ? `https://www.discogs.com${item.uri}` : null,
    source: 'discogs'
  }));
  
  return {
    query,
    type,
    totalResults: data.pagination?.items || results.length,
    count: results.length,
    page: data.pagination?.page || 1,
    totalPages: data.pagination?.pages || 1,
    results,
    source: 'discogs'
  };
}

/**
 * R√©cup√®re les d√©tails d'un release Discogs
 * @param {number|string} releaseId - ID release Discogs
 * @param {string} token - Token Discogs (optionnel)
 * @returns {Promise<object>} - D√©tails release
 */
async function getDiscogsRelease(releaseId, token = null) {
  let url = `${DISCOGS_BASE_URL}/releases/${releaseId}`;
  if (token) {
    url += `?token=${token}`;
  }
  
  console.log(`[Discogs] Release: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Release non trouv√©e: ${releaseId}`);
    }
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const release = await response.json();
  
  return {
    id: release.id,
    type: 'release',
    title: release.title,
    artists: (release.artists || []).map(a => ({
      id: a.id,
      name: a.name,
      role: a.role
    })),
    artist: (release.artists || []).map(a => a.name).join(', '),
    year: release.year || null,
    releaseDate: release.released || null,
    country: release.country || null,
    genres: release.genres || [],
    styles: release.styles || [],
    formats: (release.formats || []).map(f => ({
      name: f.name,
      qty: f.qty,
      descriptions: f.descriptions
    })),
    labels: (release.labels || []).map(l => ({
      id: l.id,
      name: l.name,
      catno: l.catno
    })),
    tracklist: (release.tracklist || []).map(t => ({
      position: t.position,
      title: t.title,
      duration: t.duration,
      artists: t.artists?.map(a => a.name)
    })),
    trackCount: release.tracklist?.length || 0,
    notes: release.notes || null,
    images: (release.images || []).map(img => ({
      type: img.type,
      uri: img.uri,
      uri150: img.uri150
    })),
    coverUrl: release.images?.[0]?.uri150 || release.thumb,
    coverUrlLarge: release.images?.[0]?.uri || null,
    masterId: release.master_id || null,
    masterUrl: release.master_url || null,
    // Prix du march√© (si disponible)
    lowestPrice: release.lowest_price || null,
    numForSale: release.num_for_sale || 0,
    community: release.community ? {
      have: release.community.have,
      want: release.community.want,
      rating: release.community.rating?.average,
      ratingCount: release.community.rating?.count
    } : null,
    discogsUrl: release.uri,
    source: 'discogs'
  };
}

/**
 * Recherche par code-barres sur Discogs
 * @param {string} barcode - Code-barres
 * @param {string} token - Token Discogs (optionnel)
 * @returns {Promise<object>} - Release trouv√©e
 */
async function searchDiscogsByBarcode(barcode, token = null) {
  let url = `${DISCOGS_BASE_URL}/database/search?barcode=${encodeURIComponent(barcode)}&type=release`;
  if (token) {
    url += `&token=${token}`;
  }
  
  console.log(`[Discogs] Barcode: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.results || data.results.length === 0) {
    return { found: false, barcode, source: 'discogs' };
  }
  
  const item = data.results[0];
  
  return {
    found: true,
    barcode,
    id: item.id,
    title: item.title,
    artist: item.title?.split(' - ')[0] || null,
    albumTitle: item.title?.split(' - ')[1] || item.title,
    year: item.year,
    country: item.country,
    format: item.format,
    label: item.label,
    genre: item.genre,
    coverUrl: item.cover_image || item.thumb,
    discogsUrl: item.uri ? `https://www.discogs.com${item.uri}` : null,
    source: 'discogs'
  };
}

/**
 * Recherche sur iTunes
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, entity, country)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchItunes(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, entity = 'album', country = 'FR' } = options;
  
  const url = `${ITUNES_BASE_URL}/search?term=${encodeURIComponent(query)}&entity=${entity}&country=${country}&limit=${limit}`;
  
  console.log(`[iTunes] Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur iTunes: ${response.status}`);
  }
  
  const data = await response.json();
  
  const results = (data.results || []).map(item => {
    if (entity === 'album') {
      return {
        id: item.collectionId,
        type: 'album',
        title: item.collectionName,
        artist: item.artistName,
        artistId: item.artistId,
        coverUrl: item.artworkUrl100,
        coverUrlLarge: item.artworkUrl100?.replace('100x100', '600x600'),
        releaseDate: item.releaseDate,
        year: item.releaseDate?.substring(0, 4),
        trackCount: item.trackCount,
        genre: item.primaryGenreName,
        price: item.collectionPrice,
        currency: item.currency,
        explicit: item.collectionExplicitness === 'explicit',
        itunesUrl: item.collectionViewUrl,
        source: 'itunes'
      };
    } else if (entity === 'musicArtist') {
      return {
        id: item.artistId,
        type: 'artist',
        name: item.artistName,
        genre: item.primaryGenreName,
        itunesUrl: item.artistLinkUrl,
        source: 'itunes'
      };
    } else {
      // song
      return {
        id: item.trackId,
        type: 'track',
        title: item.trackName,
        artist: item.artistName,
        album: item.collectionName,
        albumId: item.collectionId,
        duration: item.trackTimeMillis ? Math.round(item.trackTimeMillis / 1000) : null,
        durationFormatted: item.trackTimeMillis ? formatDuration(item.trackTimeMillis) : null,
        preview: item.previewUrl,
        coverUrl: item.artworkUrl100,
        explicit: item.trackExplicitness === 'explicit',
        price: item.trackPrice,
        itunesUrl: item.trackViewUrl,
        source: 'itunes'
      };
    }
  });
  
  return {
    query,
    entity,
    country,
    totalResults: data.resultCount || results.length,
    count: results.length,
    results,
    source: 'itunes'
  };
}

// === ENDPOINTS MUSIQUE ===

/**
 * Recherche d'albums de musique (multi-sources)
 * @route GET /music/search
 * @queryparam q - Recherche (requis)
 * @queryparam source - Source: musicbrainz, deezer, discogs, itunes, all (d√©faut: deezer)
 * @queryparam type - Type: album, artist, track (d√©faut: album)
 * @queryparam limit - Nombre de r√©sultats (d√©faut: 20, max: 100)
 * @queryparam lang - Langue/Pays (fr, en, de, us, gb, etc.) - utilis√© pour iTunes
 * @queryparam country - Alias pour lang (r√©trocompatibilit√©)
 * @queryparam discogsToken - Token Discogs (optionnel, via header X-Discogs-Token)
 */
app.get("/music/search", async (req, res) => {
  const { q, source = 'deezer', type = 'album' } = req.query;
  // Limite: valeur par d√©faut 20, max 100
  const limit = Math.min(Math.max(parseInt(req.query.limit) || MUSIC_DEFAULT_MAX, 1), 100);
  // Lang/Country: accepter les deux param√®tres, lang a priorit√©
  const langParam = req.query.lang || req.query.country || 'FR';
  // Normaliser: "fr-FR" -> "FR", "fr" -> "FR"
  const country = langParam.includes('-') ? langParam.split('-')[1].toUpperCase() : langParam.toUpperCase();
  const discogsToken = req.query.discogsToken || req.headers['x-discogs-token'];
  
  if (!q) {
    return res.status(400).json({ error: "param√®tre 'q' manquant" });
  }
  
  const cacheKey = `music:search:${source}:${type}:${q}:${limit}:${country}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    let result;
    
    switch (source.toLowerCase()) {
      case 'musicbrainz':
      case 'mb':
        metrics.sources.musicbrainz.requests++;
        result = await searchMusicBrainz(q, { limit, type: type === 'album' ? 'release-group' : type });
        break;
        
      case 'discogs':
        metrics.sources.discogs.requests++;
        const discogsType = type === 'album' ? 'release' : type;
        result = await searchDiscogs(q, { limit, type: discogsType, token: discogsToken });
        break;
        
      case 'itunes':
        const itunesEntity = type === 'album' ? 'album' : type === 'artist' ? 'musicArtist' : 'song';
        result = await searchItunes(q, { limit, entity: itunesEntity, country });
        break;
        
      case 'all':
        // Recherche sur toutes les sources en parall√®le (limite √† 10 par source pour perf)
        const limitPerSource = Math.min(limit, 10);
        const [deezerRes, mbRes, itunesRes] = await Promise.allSettled([
          searchDeezer(q, { limit: limitPerSource, type }),
          searchMusicBrainz(q, { limit: limitPerSource }),
          searchItunes(q, { limit: limitPerSource, entity: type === 'album' ? 'album' : 'song', country })
        ]);
        
        metrics.sources.deezer.requests++;
        metrics.sources.musicbrainz.requests++;
        
        result = {
          query: q,
          type,
          lang: country,
          sources: {
            deezer: deezerRes.status === 'fulfilled' ? deezerRes.value : { error: deezerRes.reason?.message },
            musicbrainz: mbRes.status === 'fulfilled' ? mbRes.value : { error: mbRes.reason?.message },
            itunes: itunesRes.status === 'fulfilled' ? itunesRes.value : { error: itunesRes.reason?.message }
          }
        };
        break;
        
      case 'deezer':
      default:
        metrics.sources.deezer.requests++;
        result = await searchDeezer(q, { limit, type });
        break;
    }
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * D√©tails d'un album (Deezer)
 * @route GET /music/album/:id
 * @param id - ID album Deezer
 */
app.get("/music/album/:id", async (req, res) => {
  const { id } = req.params;
  const source = req.query.source || 'deezer';
  
  const cacheKey = `music:album:${source}:${id}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    let result;
    
    if (source === 'musicbrainz' || source === 'mb') {
      metrics.sources.musicbrainz.requests++;
      result = await getMusicBrainzAlbum(id);
    } else {
      metrics.sources.deezer.requests++;
      result = await getDeezerAlbum(id);
    }
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/album:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un artiste (Deezer)
 * @route GET /music/artist/:id
 * @param id - ID artiste Deezer
 */
app.get("/music/artist/:id", async (req, res) => {
  const { id } = req.params;
  
  const cacheKey = `music:artist:${id}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.deezer.requests++;
    const result = await getDeezerArtist(id);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/artist:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un release Discogs
 * @route GET /music/discogs/:id
 * @param id - ID release Discogs
 * @queryparam token - Token Discogs (optionnel, via header X-Discogs-Token)
 */
app.get("/music/discogs/:id", async (req, res) => {
  const { id } = req.params;
  const token = req.query.token || req.headers['x-discogs-token'];
  
  const cacheKey = `music:discogs:${id}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.discogs.requests++;
    const result = await getDiscogsRelease(id, token);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/discogs:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * Recherche d'album par code-barres
 * @route GET /music/barcode/:code
 * @param code - Code-barres UPC/EAN
 * @queryparam source - Source: musicbrainz, discogs, all (d√©faut: all)
 * @queryparam discogsToken - Token Discogs (optionnel)
 */
app.get("/music/barcode/:code", async (req, res) => {
  const { code } = req.params;
  const source = req.query.source || 'all';
  const discogsToken = req.query.discogsToken || req.headers['x-discogs-token'];
  
  if (!code || code.length < 8) {
    return res.status(400).json({ error: "Code-barres invalide" });
  }
  
  const cacheKey = `music:barcode:${code}:${source}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    let result = { barcode: code, found: false, sources: [] };
    
    if (source === 'all' || source === 'musicbrainz' || source === 'mb') {
      try {
        metrics.sources.musicbrainz.requests++;
        const mbResult = await searchMusicBrainzByBarcode(code);
        if (mbResult.found) {
          result.found = true;
          result.musicbrainz = mbResult;
          result.sources.push('musicbrainz');
          // Utiliser les donn√©es MB comme principales
          result.title = mbResult.title;
          result.artist = mbResult.artist;
          result.date = mbResult.date;
          result.coverUrl = mbResult.coverUrl;
        }
      } catch (err) {
        console.error('[Music] MusicBrainz barcode error:', err.message);
      }
    }
    
    if (source === 'all' || source === 'discogs') {
      try {
        metrics.sources.discogs.requests++;
        const discogsResult = await searchDiscogsByBarcode(code, discogsToken);
        if (discogsResult.found) {
          result.found = true;
          result.discogs = discogsResult;
          result.sources.push('discogs');
          // Remplir les donn√©es manquantes
          if (!result.title) result.title = discogsResult.albumTitle;
          if (!result.artist) result.artist = discogsResult.artist;
          if (!result.coverUrl) result.coverUrl = discogsResult.coverUrl;
        }
      } catch (err) {
        console.error('[Music] Discogs barcode error:', err.message);
      }
    }
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/barcode:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Endpoint utilitaire pour chiffrer une cl√© API (aide au d√©veloppement)
// Accessible uniquement si API_ENCRYPTION_KEY est configur√©e
app.post("/crypto/encrypt", express.json(), (req, res) => {
  if (!API_ENCRYPTION_KEY) {
    return res.status(400).json({ 
      error: "Chiffrement non activ√©",
      hint: "D√©finissez la variable d'environnement API_ENCRYPTION_KEY"
    });
  }
  
  const { key } = req.body;
  if (!key) {
    return res.status(400).json({ error: "param√®tre 'key' manquant dans le body JSON" });
  }
  
  const encrypted = encryptApiKey(key);
  if (!encrypted) {
    return res.status(500).json({ error: "√âchec du chiffrement" });
  }
  
  res.json({
    encrypted: encrypted,
    usage: "Utilisez cette valeur dans le header X-Encrypted-Key"
  });
});

// Endpoint de sant√© avec m√©triques avanc√©es
app.get("/health", (req, res) => {
  const uptime = Math.floor((Date.now() - metrics.startTime) / 1000);
  const avgResponseTime = metrics.responseTimeCount > 0 
    ? Math.round(metrics.responseTimeSum / metrics.responseTimeCount) 
    : 0;
  const cacheHitRate = metrics.requests.total > 0 
    ? Math.round((metrics.requests.cached / metrics.requests.total) * 100) 
    : 0;
  
  res.json({ 
    status: "ok", 
    fsr: FSR_BASE,
    uptime: `${uptime}s`,
    cache: {
      size: cache.size,
      maxSize: CACHE_MAX_SIZE,
      ttl: CACHE_TTL / 1000,
      hitRate: `${cacheHitRate}%`
    },
    metrics: {
      requests: {
        total: metrics.requests.total,
        cached: metrics.requests.cached,
        errors: metrics.requests.errors
      },
      avgResponseTime: `${avgResponseTime}ms`,
      sources: metrics.sources
    },
    compression: "gzip enabled"
  });
});

// Endpoint version de l'API
app.get("/version", (req, res) => {
  res.json({
    name: "Toys API",
    version: API_VERSION,
    features: [
      "LEGO search & product details",
      "Rebrickable API integration (sets, parts, minifigs, themes, colors)",
      "LEGO ‚Üî Rebrickable cross-enrichment",
      "Google Books search & details (ISBN/text)",
      "OpenLibrary search & details (ISBN/text)",
      "RAWG video games database (search/details)",
      "IGDB video games database (search/details via Twitch)",
      "TVDB TV series & movies database (search/details)",
      "TMDB movies & TV shows database (search/details)",
      "IMDB movies & TV database (search/details/browse - NO API KEY)",
      "Jikan anime & manga database (search/details - NO API KEY)",
      "Comic Vine comics database (search/volumes/issues)",
      "MangaDex manga database (search/details - NO API KEY)",
      "Bedetheque BD franco-belge (search/series/albums - scraping)",
      "JeuxVideo.com jeux vid√©o FR (search/details - scraping)",
      "ConsoleVariations consoles & accessories database (search/browse/details - scraping)",
      "Smart search (ID vs text detection)",
      "Coleka collectibles database",
      "Lulu-Berlu vintage toys",
      "Transformerland vintage Transformers",
      "Paninimania sticker albums (FR)",
      "Mega Construx search (multi-language: fr-FR, en-US, de-DE, etc.)",
      "Barcode identification (UPC, EAN, ISBN detection)",
      "Music search (MusicBrainz, Deezer, iTunes, Discogs)",
      "Encrypted API key support (AES-256-GCM)",
      "In-memory caching with TTL",
      "Gzip compression",
      "CORS enabled",
      "Metrics & monitoring"
    ],
    endpoints: {
      lego: ["/lego/search", "/lego/product/:id", "/lego/instructions/:id"],
      rebrickable: [
        "/rebrickable/search",
        "/rebrickable/set/:setNum",
        "/rebrickable/set/:setNum/parts",
        "/rebrickable/set/:setNum/minifigs",
        "/rebrickable/themes",
        "/rebrickable/colors"
      ],
      googlebooks: [
        "/googlebooks/search",
        "/googlebooks/book/:volumeId",
        "/googlebooks/isbn/:isbn"
      ],
      openlibrary: [
        "/openlibrary/search",
        "/openlibrary/book/:olId",
        "/openlibrary/isbn/:isbn"
      ],
      rawg: [
        "/rawg/search",
        "/rawg/game/:id"
      ],
      igdb: [
        "/igdb/search",
        "/igdb/game/:id"
      ],
      tvdb: [
        "/tvdb/search",
        "/tvdb/series/:id",
        "/tvdb/movie/:id"
      ],
      tmdb: [
        "/tmdb/search",
        "/tmdb/movie/:id",
        "/tmdb/tv/:id"
      ],
      imdb: [
        "/imdb/search (NO API KEY)",
        "/imdb/title/:id (NO API KEY)",
        "/imdb/browse (NO API KEY)"
      ],
      jikan: [
        "/jikan/anime (NO API KEY)",
        "/jikan/anime/:id (NO API KEY)",
        "/jikan/manga (NO API KEY)",
        "/jikan/manga/:id (NO API KEY)"
      ],
      comicvine: [
        "/comicvine/search",
        "/comicvine/volume/:id",
        "/comicvine/issue/:id"
      ],
      mangadex: [
        "/mangadex/search (NO API KEY)",
        "/mangadex/manga/:id (NO API KEY)"
      ],
      bedetheque: [
        "/bedetheque/search (scraping)",
        "/bedetheque/serie/:id (scraping)",
        "/bedetheque/album/:id (scraping)"
      ],
      jvc: [
        "/jvc/search (scraping)",
        "/jvc/game/:id (scraping)"
      ],
      consolevariations: [
        "/consolevariations/search?type=all|consoles|controllers|accessories (scraping)",
        "/consolevariations/item/:slug (scraping)",
        "/consolevariations/platforms (scraping)",
        "/consolevariations/browse/:platform (scraping)"
      ],
      coleka: ["/coleka/search", "/coleka/item"],
      luluberlu: ["/luluberlu/search", "/luluberlu/item/:id"],
      transformerland: ["/transformerland/search", "/transformerland/item"],
      paninimania: ["/paninimania/search", "/paninimania/album/:id", "/paninimania/album"],
      mega: [
        "/mega/search",
        "/mega/product/:id",
        "/mega/franchise/:franchise",
        "/mega/instructions",
        "/mega/instructions/:sku",
        "/mega/languages"
      ],
      barcode: [
        "/barcode/:code (auto-detect UPC/EAN/ISBN)",
        "/barcode/detect/:code",
        "/barcode/isbn/:isbn",
        "/barcode/bnf/:isbn"
      ],
      music: [
        "/music/search",
        "/music/album/:id",
        "/music/artist/:id",
        "/music/discogs/:id",
        "/music/barcode/:code"
      ],
      crypto: ["/crypto/encrypt (POST)", "/crypto/verify (POST)"],
      system: ["/health", "/version", "/cache (DELETE)", "/metrics (DELETE)"]
    },
    security: {
      encryption: API_ENCRYPTION_KEY ? "enabled" : "disabled",
      algorithm: "AES-256-GCM",
      headers: {
        encrypted: "X-Encrypted-Key",
        plain: "X-Api-Key (only if encryption disabled)"
      }
    }
  });
});

// Endpoint pour vider le cache
app.delete("/cache", (req, res) => {
  const size = cache.size;
  cache.clear();
  console.log(`[Cache] Vid√© (${size} entr√©es supprim√©es)`);
  res.json({ status: "ok", cleared: size });
});

// Endpoint pour r√©initialiser les m√©triques
app.delete("/metrics", (req, res) => {
  metrics.requests = { total: 0, cached: 0, errors: 0 };
  metrics.responseTimeSum = 0;
  metrics.responseTimeCount = 0;
  Object.keys(metrics.sources).forEach(key => {
    metrics.sources[key] = { requests: 0, errors: 0 };
  });
  console.log("[Metrics] R√©initialis√©es");
  res.json({ status: "ok", message: "Metrics reset" });
});

// Endpoint pour r√©cup√©rer les d√©tails d'un produit par son ID
// Avec option d'enrichissement Rebrickable (minifigs, pi√®ces)
// Les manuels d'instructions LEGO sont toujours inclus
app.get("/lego/product/:id", async (req, res) => {
  const productId = req.params.id;
  const lang = (req.query.lang || DEFAULT_LOCALE);
  const enrichRebrickable = req.query.enrich_rebrickable === 'true'; // D√©sactiv√© par d√©faut (requiert cl√© API)
  const maxParts = req.query.parts_limit ? parseInt(req.query.parts_limit, 10) : 500;

  if (!productId) return res.status(400).json({ error: "ID produit manquant" });

  try {
    metrics.sources.lego.requests++;
    let result = await getProductDetails(productId, lang);
    
    // Toujours r√©cup√©rer les manuels d'instructions LEGO
    try {
      const instructions = await getBuildingInstructions(productId, lang);
      if (instructions && instructions.manuals && instructions.manuals.length > 0) {
        result.instructions = {
          count: instructions.manuals.length,
          manuals: instructions.manuals
        };
        console.log(`[LEGO] ${instructions.manuals.length} manuels trouv√©s pour ${productId}`);
      } else {
        result.instructions = { count: 0, manuals: [] };
      }
    } catch (instructionsErr) {
      console.warn(`[LEGO] Impossible de r√©cup√©rer les instructions pour ${productId}: ${instructionsErr.message}`);
      result.instructions = { count: 0, manuals: [], error: instructionsErr.message };
    }
    
    // Enrichir avec Rebrickable si demand√© et si une cl√© API est fournie
    if (enrichRebrickable) {
      const apiKey = extractApiKey(req);
      if (apiKey) {
        try {
          result = await enrichLegoWithRebrickable(result, apiKey, { maxParts });
          console.log(`[LEGO] Produit ${productId} enrichi avec Rebrickable`);
        } catch (enrichErr) {
          console.warn(`[LEGO] √âchec enrichissement Rebrickable pour ${productId}: ${enrichErr.message}`);
          // On continue sans enrichissement en cas d'erreur
          result.rebrickable_error = enrichErr.message;
        }
      } else {
        result.rebrickable_hint = "Fournissez une cl√© API Rebrickable via X-Api-Key ou X-Encrypted-Key pour enrichir avec minifigs/pi√®ces";
      }
    }
    
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /lego/product:", err);
    metrics.requests.errors++;
    metrics.sources.lego.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Endpoint pour r√©cup√©rer les manuels d'instructions d'un produit
app.get("/lego/instructions/:id", async (req, res) => {
  const productId = req.params.id;
  const lang = (req.query.lang || DEFAULT_LOCALE);

  if (!productId) return res.status(400).json({ error: "ID produit manquant" });

  try {
    metrics.sources.lego.requests++;
    const result = await getBuildingInstructions(productId, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /lego/instructions:", err);
    metrics.requests.errors++;
    metrics.sources.lego.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Coleka
// -----------------------------

// Endpoint de recherche Coleka
app.get("/coleka/search", async (req, res) => {
  const q = req.query.q;
  const nbpp = req.query.nbpp ? parseInt(req.query.nbpp, 10) : COLEKA_DEFAULT_NBPP;
  const lang = req.query.lang || "fr";

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.sources.coleka.requests++;
    const result = await searchColekaLib(q, nbpp, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /coleka/search:", err);
    metrics.requests.errors++;
    metrics.sources.coleka.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Endpoint pour r√©cup√©rer les d√©tails d'un item Coleka
// Usage: /coleka/item/fr/lego/star-wars/millennium-falcon
// Ou: /coleka/item?path=/fr/lego/star-wars/millennium-falcon
app.get("/coleka/item", async (req, res) => {
  const itemPath = req.query.path;
  const lang = req.query.lang || "fr";

  if (!itemPath) return res.status(400).json({ error: "param√®tre 'path' manquant" });

  try {
    metrics.sources.coleka.requests++;
    const result = await getColekaItemDetails(itemPath, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /coleka/item:", err);
    metrics.requests.errors++;
    metrics.sources.coleka.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Endpoint alternatif avec path dans l'URL
app.get("/coleka/item/*", async (req, res) => {
  // R√©cup√©rer le chemin complet apr√®s /coleka/item/
  const itemPath = '/' + req.params[0];
  const lang = req.query.lang || "fr";

  try {
    metrics.sources.coleka.requests++;
    const result = await getColekaItemDetails(itemPath, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /coleka/item/*:", err);
    metrics.requests.errors++;
    metrics.sources.coleka.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Lulu-Berlu
// -----------------------------

// Endpoint de recherche Lulu-Berlu
app.get("/luluberlu/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : LULUBERLU_DEFAULT_MAX;
  // Le param√®tre lang est ignor√© mais accept√© pour compatibilit√©
  // const lang = req.query.lang; // ignor√©

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.sources.luluberlu.requests++;
    const result = await searchLuluBerluLib(q, max);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /luluberlu/search:", err);
    metrics.requests.errors++;
    metrics.sources.luluberlu.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Endpoint pour r√©cup√©rer les d√©tails d'un item Lulu-Berlu par son ID
app.get("/luluberlu/item/:id", async (req, res) => {
  const itemId = req.params.id;
  // Le param√®tre lang est ignor√© mais accept√© pour compatibilit√©
  // const lang = req.query.lang; // ignor√©

  if (!itemId) return res.status(400).json({ error: "ID item manquant" });

  try {
    metrics.sources.luluberlu.requests++;
    const result = await getLuluBerluItemDetails(itemId);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /luluberlu/item:", err);
    metrics.requests.errors++;
    metrics.sources.luluberlu.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Endpoint alternatif pour Lulu-Berlu avec URL compl√®te en query param
app.get("/luluberlu/item", async (req, res) => {
  const url = req.query.url;
  // Le param√®tre lang est ignor√© mais accept√© pour compatibilit√©

  if (!url) return res.status(400).json({ error: "param√®tre 'url' manquant" });

  try {
    metrics.sources.luluberlu.requests++;
    const result = await getLuluBerluItemDetails(url);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /luluberlu/item?url=:", err);
    metrics.requests.errors++;
    metrics.sources.luluberlu.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// ============================================================================
// PANINIMANIA - Fonctions et Endpoints
// ============================================================================

/**
 * Formate un terme de recherche pour Paninimania
 * - lowercase
 * - espaces remplac√©s par _
 * - caract√®res sp√©ciaux normalis√©s
 */
function formatPaninimaniaTerm(term) {
  return term
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Supprimer les accents
    .replace(/[^a-z0-9\s]/g, '') // Garder uniquement lettres, chiffres, espaces
    .trim()
    .replace(/\s+/g, '_'); // Espaces -> underscores
}

/**
 * Parse une cha√Æne de checklist en tableau de num√©ros
 * Supporte les formats: "1 √† 128", "1-128", "A1 √† A50", "H1 √† H6", "1, 2, 3", "1 √† 128 et H1 √† H6"
 * @param {string} checklistStr - Cha√Æne de checklist brute
 * @returns {Array<string>} - Tableau de num√©ros/codes
 */
function parseChecklistToArray(checklistStr) {
  if (!checklistStr) return [];
  
  const result = [];
  
  // S√©parer par "et" ou "," pour les groupes multiples
  const groups = checklistStr.split(/\s+et\s+|,\s*/i);
  
  for (const group of groups) {
    const trimmed = group.trim();
    if (!trimmed) continue;
    
    // V√©rifier si c'est une plage ("X √† Y" ou "X-Y")
    const rangeMatch = trimmed.match(/^([A-Za-z]*)?(\d+)\s*(?:√†|-|to)\s*([A-Za-z]*)?(\d+)$/i);
    
    if (rangeMatch) {
      const prefix1 = (rangeMatch[1] || '').toUpperCase();
      const start = parseInt(rangeMatch[2]);
      const prefix2 = (rangeMatch[3] || '').toUpperCase();
      const end = parseInt(rangeMatch[4]);
      
      // Utiliser le pr√©fixe s'il y en a un
      const prefix = prefix1 || prefix2 || '';
      
      if (start <= end && (end - start) <= 1000) { // Limite de s√©curit√©
        for (let i = start; i <= end; i++) {
          result.push(prefix + i.toString());
        }
      } else {
        // Si la plage est invalide, garder la cha√Æne originale
        result.push(trimmed);
      }
    } else {
      // C'est un num√©ro unique ou un code sp√©cial
      result.push(trimmed);
    }
  }
  
  return result;
}

/**
 * Recherche sur Paninimania.com
 * @param {string} term - Terme de recherche
 * @param {number} maxResults - Nombre max de r√©sultats
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<Object>} - R√©sultats de recherche
 */
async function searchPaninimania(term, maxResults = PANINIMANIA_DEFAULT_MAX, retries = MAX_RETRIES) {
  // Formater le terme de recherche
  const formattedTerm = formatPaninimaniaTerm(term);
  
  // V√©rifier le cache
  const cacheKey = `paninimania:search:${formattedTerm}:${maxResults}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[Paninimania] Tentative ${attempt}/${retries} pour recherche: "${term}" -> "${formattedTerm}" (max: ${maxResults})`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      const allResults = [];
      let currentPage = 1;
      let totalPages = 1;
      
      // Boucle de pagination
      while (allResults.length < maxResults) {
        // Construire l'URL de recherche
        // Format: /?pag=cid508&idf=15&idd=all&ids=111_{keyword}&npa={page}
        let searchUrl = `${PANINIMANIA_BASE_URL}/?pag=cid508&idf=15&idd=all&ids=111_${formattedTerm}`;
        if (currentPage > 1) {
          searchUrl += `&npa=${currentPage}`;
        }
        
        console.log(`[Paninimania] Page ${currentPage}: ${searchUrl}`);

        const pageSolution = await fsrRequest("request.get", searchUrl, fsrSessionId, {
          waitInSeconds: 2
        }, 45000);
        
        const html = pageSolution.response || "";
        console.log(`[Paninimania] Page re√ßue, taille: ${html.length}`);
        
        // V√©rifier si on a des r√©sultats
        if (html.includes("Aucun album") || html.includes("aucun r") || html.length < 5000) {
          console.log("[Paninimania] Aucun r√©sultat trouv√©");
          break;
        }
        
        // Extraire la pagination (format: "Page X/Y")
        const pageMatch = html.match(/Page\s+(\d+)\/(\d+)/i);
        if (pageMatch) {
          currentPage = parseInt(pageMatch[1]);
          totalPages = parseInt(pageMatch[2]);
          console.log(`[Paninimania] Pagination: page ${currentPage}/${totalPages}`);
        }
        
        // Parser les albums
        // Structure: <div class="d2">...<a href="./?pag=cid508_alb&idf=15&idm={id}">...
        // Image: <img src="files/15/{folder}/?n={id}s.jpg">
        // Titre: <b><a href="...">TITRE</a></b>
        // Ann√©e: <b> 2020</b>
        // Editeur/Checklist: Texte libre
        
        // Pattern pour trouver les blocs d'albums (entre <div class="d2"> avec structure y0)
        const albumBlockRegex = /<div\s+class="d2">\s*<div\s+class="y0"[^>]*style="gap:\s*10px\s+10px[^"]*"[^>]*>([\s\S]*?)<\/div>\s*<\/div>\s*<\/div>/gi;
        
        let albumMatch;
        let pageResults = 0;
        
        while ((albumMatch = albumBlockRegex.exec(html)) !== null) {
          if (allResults.length >= maxResults) break;
          
          const albumHtml = albumMatch[1];
          
          try {
            // Extraire l'ID depuis le lien
            const idMatch = albumHtml.match(/href="[^"]*pag=cid508_alb[^"]*idm=(\d+)"/i);
            if (!idMatch) continue;
            const albumId = idMatch[1];
            
            // Extraire le titre
            const titleMatch = albumHtml.match(/<b><a\s+href="[^"]*"[^>]*>([^<]+)<\/a><\/b>/i);
            const title = titleMatch ? decodeHtmlEntities(titleMatch[1].trim()) : null;
            
            if (!title) continue;
            
            // Extraire l'image thumbnail
            const imgMatch = albumHtml.match(/src="(files\/[^"]+\?n=\d+s\.jpg)"/i);
            const thumbnail = imgMatch ? `${PANINIMANIA_BASE_URL}/${imgMatch[1]}` : null;
            
            // Extraire l'ann√©e
            const yearMatch = albumHtml.match(/<b>\s*(\d{4}|[a-z]+\s+\d{4})\s*<\/b>/i);
            const year = yearMatch ? yearMatch[1].trim() : null;
            
            // Extraire l'√©diteur/checklist (texte apr√®s l'ann√©e, avant </div>)
            const editorMatch = albumHtml.match(/<\/b><br>\s*([^<]+)<br>/i);
            let editor = null;
            let checklistRaw = null;
            
            if (editorMatch) {
              const editorText = decodeHtmlEntities(editorMatch[1].trim());
              // S√©parer √©diteur et checklist si format "Editeur : checklist"
              const colonIdx = editorText.indexOf(':');
              if (colonIdx > 0) {
                editor = editorText.substring(0, colonIdx).trim();
                checklistRaw = editorText.substring(colonIdx + 1).trim();
              } else {
                editor = editorText;
              }
            }
            
            // Extraire le code-barres s'il est pr√©sent dans le bloc
            const barcodeMatch = albumHtml.match(/(?:Code-?barres?|EAN|UPC)\s*:?\s*(\d{8,14})/i);
            const barcode = barcodeMatch ? barcodeMatch[1].trim() : null;
            
            // Construire l'URL de l'album
            const albumUrl = `${PANINIMANIA_BASE_URL}/?pag=cid508_alb&idf=15&idm=${albumId}`;
            
            allResults.push({
              id: albumId,
              title: title,
              url: albumUrl,
              image: thumbnail,     // Alias standard
              thumbnail: thumbnail,
              year: year,
              editor: editor,
              checklist: checklistRaw,
              barcode: barcode
            });
            
            pageResults++;
          } catch (e) {
            console.warn("[Paninimania] Erreur parsing album:", e.message);
          }
        }
        
        console.log(`[Paninimania] Page ${currentPage}: ${pageResults} albums trouv√©s`);
        
        // Passer √† la page suivante si n√©cessaire
        if (currentPage >= totalPages || pageResults === 0) {
          break;
        }
        
        currentPage++;
        
        // Petit d√©lai entre les pages
        await new Promise(r => setTimeout(r, 500));
      }
      
      const result = {
        source: "paninimania",
        query: term,
        formattedQuery: formattedTerm,
        total: allResults.length,
        results: allResults
      };
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, result);
      
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[Paninimania] Erreur tentative ${attempt}:`, err.message);
      
      // D√©truire la session en cas d'erreur
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

/**
 * R√©cup√®re les d√©tails d'un album Paninimania
 * @param {string} albumId - ID de l'album ou URL compl√®te
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<Object>} - D√©tails de l'album
 */
async function getPaninimanialbumDetails(albumId, retries = MAX_RETRIES) {
  // Si c'est une URL compl√®te, extraire l'ID
  let id = albumId;
  if (albumId.includes("paninimania.com")) {
    const match = albumId.match(/idm=(\d+)/i);
    if (match) {
      id = match[1];
    }
  }
  
  // V√©rifier le cache
  const cacheKey = `paninimania:album:${id}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      const albumUrl = `${PANINIMANIA_BASE_URL}/?pag=cid508_alb&idf=15&idm=${id}`;
      console.log(`[Paninimania] Tentative ${attempt}/${retries} pour album: ${id}`);
      console.log(`[Paninimania] URL: ${albumUrl}`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }

      const pageSolution = await fsrRequest("request.get", albumUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 45000);
      
      const html = pageSolution.response || "";
      console.log(`[Paninimania] Page album re√ßue, taille: ${html.length}`);
      
      // V√©rifier si l'album existe
      if (html.includes("page introuvable") || html.includes("n'existe pas") || html.length < 3000) {
        throw new Error(`Album ${id} non trouv√©`);
      }
      
      // Extraire le titre depuis <h1>
      const titleMatch = html.match(/<h1>\s*([^<]+)\s*<\/h1>/i);
      const title = titleMatch ? decodeHtmlEntities(titleMatch[1].trim()) : null;
      
      // Extraire la description depuis meta description
      const descMatch = html.match(/<meta\s+name="description"\s+content="([^"]+)"/i);
      const description = descMatch ? decodeHtmlEntities(descMatch[1].trim()) : null;
      
      // Extraire l'image principale (format: files/15/{folder}/?n={id}b.jpg)
      const mainImgMatch = html.match(/src="(files\/[^"]+\?n=\d+b\.jpg)"/i);
      const mainImage = mainImgMatch ? `${PANINIMANIA_BASE_URL}/${mainImgMatch[1]}` : null;
      
      // Extraire le copyright
      const copyrightMatch = html.match(/Copyright\s*:\s*<\/b>([^<]+)/i);
      const copyright = copyrightMatch ? decodeHtmlEntities(copyrightMatch[1].trim()) : null;
      
      // Extraire le code-barres (EAN/UPC)
      const barcodeMatch = html.match(/Code-barres\s*:\s*<\/b>(\d+)/i);
      const barcode = barcodeMatch ? barcodeMatch[1].trim() : null;
      
      // Extraire la date de parution
      const dateMatch = html.match(/Premi[√®e]re\s+parution\s*:\s*<\/b>([^<]+)/i);
      const releaseDate = dateMatch ? decodeHtmlEntities(dateMatch[1].trim()) : null;
      
      // Extraire la checklist (texte apr√®s le titre, format "Editeur : X √† Y")
      const checklistMatch = html.match(/<b>[^<]+<\/b><br>\s*([^<:]+:\s*[^<]+)<br>/i);
      let editor = null;
      let checklistRaw = null;
      let checklistParsed = [];
      
      if (checklistMatch) {
        const checklistText = decodeHtmlEntities(checklistMatch[1].trim());
        const colonIdx = checklistText.indexOf(':');
        if (colonIdx > 0) {
          editor = checklistText.substring(0, colonIdx).trim();
          checklistRaw = checklistText.substring(colonIdx + 1).trim();
        } else {
          checklistRaw = checklistText;
        }
        // Parser la checklist en tableau de num√©ros
        checklistParsed = parseChecklistToArray(checklistRaw);
      }
      
      // Construire l'objet checklist structur√©
      const checklist = checklistRaw ? {
        raw: checklistRaw,
        total: checklistParsed.length,
        items: checklistParsed
      } : null;
      
      // Extraire les cat√©gories depuis le fil d'Ariane
      const categories = [];
      const breadcrumbMatch = html.match(/<H2>([\s\S]*?)<\/H2>/i);
      if (breadcrumbMatch) {
        const catRegex = /<a\s+href="[^"]*"[^>]*>([^<]+)<\/a>/gi;
        let catMatch;
        while ((catMatch = catRegex.exec(breadcrumbMatch[1])) !== null) {
          const cat = decodeHtmlEntities(catMatch[1].trim());
          if (cat && cat !== "Menu" && cat !== "Tous les albums" && !categories.includes(cat)) {
            categories.push(cat);
          }
        }
      }
      
      // Extraire les images suppl√©mentaires (exemples d'images, checklist, etc.)
      const additionalImages = [];
      const addImgRegex = /<a\s+href="(files\/[^"]+\.jpg)"\s+target="_blank"[^>]*title="([^"]+)"/gi;
      let addImgMatch;
      while ((addImgMatch = addImgRegex.exec(html)) !== null) {
        additionalImages.push({
          url: `${PANINIMANIA_BASE_URL}/${addImgMatch[1]}`,
          caption: decodeHtmlEntities(addImgMatch[2])
        });
      }
      
      // Extraire les articles divers
      const articles = [];
      const articleMatch = html.match(/Articles\s+divers\s*:<\/b><br>([\s\S]*?)(?:<\/div>|<br>\s*<br>)/i);
      if (articleMatch) {
        const articleLines = articleMatch[1].split(/<br\s*\/?>/i);
        for (const line of articleLines) {
          const clean = line.replace(/<[^>]+>/g, '').trim();
          if (clean && clean.startsWith('-')) {
            articles.push(clean.substring(1).trim());
          }
        }
      }
      
      // Extraire les images sp√©ciales (Fluorescentes, Brillantes, Hologrammes, etc.)
      const specialStickers = {};
      // Pattern pour les diff√©rents types d'images sp√©ciales
      const specialPatternsRegex = /<b>Images?\s+(Fluorescentes?|Brillantes?|Hologrammes?|M√©tallis√©es?|Paillet√©es?|Transparentes?|Puzzle|Relief|Autocollantes?|Tatouages?|Phosphorescentes?|3D|Lenticulaires?|Dor√©es?|Argent√©es?)\s*<\/b>\s*(?:<em>[^<]*<\/em>)?\s*(?:<b>)?\s*:\s*<\/b>?\s*([^<]+)/gi;
      let specialMatch;
      while ((specialMatch = specialPatternsRegex.exec(html)) !== null) {
        const type = decodeHtmlEntities(specialMatch[1].trim().toLowerCase());
        const rawNumbers = specialMatch[2].trim();
        // Parser la liste de num√©ros (supporte "1, 2, 3" ou "1 √† 10")
        const parsedList = parseChecklistToArray(rawNumbers);
        if (parsedList.length > 0) {
          specialStickers[type] = {
            raw: rawNumbers,
            total: parsedList.length,
            items: parsedList
          };
        }
      }
      
      // Fallback: chercher tout type "Images X : ..." qui pourrait exister
      const genericSpecialRegex = /<b>Images?\s+([^<:]+)\s*<\/b>\s*(?:<em>[^<]*<\/em>)?\s*(?:<b>)?\s*:\s*<\/b>?\s*([^<]+)/gi;
      while ((specialMatch = genericSpecialRegex.exec(html)) !== null) {
        const type = decodeHtmlEntities(specialMatch[1].trim().toLowerCase());
        // √âviter les doublons et les types d√©j√† captur√©s
        if (!specialStickers[type] && type !== 'divers' && !type.includes('article')) {
          const rawNumbers = specialMatch[2].trim();
          const parsedList = parseChecklistToArray(rawNumbers);
          if (parsedList.length > 0) {
            specialStickers[type] = {
              raw: rawNumbers,
              total: parsedList.length,
              items: parsedList
            };
          }
        }
      }
      
      if (!title) {
        throw new Error(`Impossible d'extraire les informations de l'album: ${albumUrl}`);
      }
      
      const result = {
        id: id,
        title: title,
        url: albumUrl,
        description: description,
        mainImage: mainImage,
        barcode: barcode,
        copyright: copyright,
        releaseDate: releaseDate,
        editor: editor,
        checklist: checklist,
        categories: categories,
        additionalImages: additionalImages,
        articles: articles,
        specialStickers: Object.keys(specialStickers).length > 0 ? specialStickers : null
      };
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, result);
      
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[Paninimania] Erreur tentative ${attempt}:`, err.message);
      
      // D√©truire la session en cas d'erreur
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// === Endpoint recherche Paninimania ===
app.get("/paninimania/search", async (req, res) => {
  const { q, term, max } = req.query;
  // Le param√®tre lang est ignor√© (site fran√ßais uniquement)
  const searchTerm = q || term;
  const maxResults = max ? parseInt(max) : PANINIMANIA_DEFAULT_MAX;
  
  if (!searchTerm) {
    return res.status(400).json({ error: "param√®tre 'q' ou 'term' manquant" });
  }
  
  try {
    metrics.sources.paninimania.requests++;
    const result = await searchPaninimanaLib(searchTerm, maxResults);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /paninimania/search:", err);
    metrics.requests.errors++;
    metrics.sources.paninimania.errors++;
    res.status(500).json({ error: err.message });
  }
});

// === Endpoint d√©tails album Paninimania ===
app.get("/paninimania/album/:id", async (req, res) => {
  const albumId = req.params.id;
  // Le param√®tre lang est ignor√© (site fran√ßais uniquement)
  
  if (!albumId) {
    return res.status(400).json({ error: "param√®tre 'id' manquant" });
  }
  
  try {
    metrics.sources.paninimania.requests++;
    const result = await getPaninimanialbumDetails(albumId);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /paninimania/album:", err);
    metrics.requests.errors++;
    metrics.sources.paninimania.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// === Endpoint alternatif pour Paninimania avec URL ===
app.get("/paninimania/album", async (req, res) => {
  const { url, id } = req.query;
  // Le param√®tre lang est ignor√© (site fran√ßais uniquement)
  
  const albumId = id || url;
  
  if (!albumId) {
    return res.status(400).json({ error: "param√®tre 'id' ou 'url' manquant" });
  }
  
  try {
    metrics.sources.paninimania.requests++;
    const result = await getPaninimanialbumDetails(albumId);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /paninimania/album?url=:", err);
    metrics.requests.errors++;
    metrics.sources.paninimania.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// ============================================================================
// TRANSFORMERLAND - Fonctions et Endpoints
// ============================================================================

/**
 * Recherche sur Transformerland.com
 * @param {string} term - Terme de recherche
 * @param {number} maxResults - Nombre max de r√©sultats
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<Object>} - R√©sultats de recherche
 */
async function searchTransformerland(term, maxResults = TRANSFORMERLAND_DEFAULT_MAX, retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `transformerland:search:${term}:${maxResults}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[Transformerland] Tentative ${attempt}/${retries} pour recherche: "${term}" (max: ${maxResults})`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      const searchUrl = `${TRANSFORMERLAND_SEARCH_URL}?term=${encodeURIComponent(term)}`;
      console.log(`[Transformerland] URL: ${searchUrl}`);

      const pageSolution = await fsrRequest("request.get", searchUrl, fsrSessionId, {
        waitInSeconds: 1  // Transformerland n'a pas de protection forte, 1s suffit
      }, 45000);  // Timeout r√©duit √† 45s
      
      const html = pageSolution.response || "";
      console.log(`[Transformerland] Page re√ßue, taille: ${html.length}`);
      
      const results = [];

      // Parse les items avec la classe "store-item"
      // Structure: <div class="store-item">...</div>
      const storeItemRegex = /<div\s+class="store-item"[^>]*>([\s\S]*?)(?=<div\s+class="store-item"|<div\s+class="store-pagination"|$)/gi;
      let itemMatch;
  
  while ((itemMatch = storeItemRegex.exec(html)) !== null && results.length < maxResults) {
    const itemHtml = itemMatch[1];
    
    try {
      // Extraire le SKU (ID produit) depuis meta itemprop="sku"
      const skuMatch = itemHtml.match(/<meta\s+itemprop="sku"\s+content="([^"]+)"/i);
      const sku = skuMatch ? skuMatch[1] : null;
      
      // Extraire le nom depuis meta itemprop="name"
      const nameMatch = itemHtml.match(/<meta\s+itemprop="name"\s+content="([^"]+)"/i);
      const name = nameMatch ? decodeHtmlEntities(nameMatch[1]) : null;
      
      // Extraire l'URL depuis le lien - plusieurs patterns possibles
      let itemUrl = null;
      const urlMatch = itemHtml.match(/<a\s+[^>]*href="([^"]*\/store\/item\/[^"]+)"/i) ||
                       itemHtml.match(/<a\s+href="(https?:\/\/[^"]*transformerland[^"]*\/store\/item\/[^"]+)"/i) ||
                       itemHtml.match(/href="([^"]+)"[^>]*itemprop="url"/i);
      if (urlMatch) {
        itemUrl = urlMatch[1].startsWith('http') ? urlMatch[1] : `${TRANSFORMERLAND_BASE_URL}${urlMatch[1]}`;
      }
      
      // Extraire l'image depuis la balise img - plusieurs patterns
      let image = null;
      const imgMatch = itemHtml.match(/<img[^>]+src="([^"]*\/image\/inventory\/[^"]+)"/i) ||
                       itemHtml.match(/<img[^>]+data-src="([^"]*\/image\/inventory\/[^"]+)"/i) ||
                       itemHtml.match(/itemprop="image"[^>]*content="([^"]+)"/i);
      if (imgMatch) {
        image = imgMatch[1].startsWith('http') ? imgMatch[1] : `${TRANSFORMERLAND_BASE_URL}${imgMatch[1]}`;
        // Convertir en image haute r√©solution
        image = image.replace('/thumbnails/', '/hires/');
      }
      
      // Extraire le prix depuis meta itemprop="price"
      const priceMatch = itemHtml.match(/<meta\s+itemprop="price"\s+content="([^"]+)"/i);
      const price = priceMatch ? parseFloat(priceMatch[1]) : null;
      
      // Extraire la devise depuis meta itemprop="priceCurrency"
      const currencyMatch = itemHtml.match(/<meta\s+itemprop="priceCurrency"\s+content="([^"]+)"/i);
      const currency = currencyMatch ? currencyMatch[1] : "USD";
      
      // Extraire la disponibilit√© depuis link itemprop="availability"
      const availMatch = itemHtml.match(/<link\s+itemprop="availability"\s+href="([^"]+)"/i);
      let availability = "unknown";
      if (availMatch) {
        if (availMatch[1].includes("InStock")) availability = "in_stock";
        else if (availMatch[1].includes("OutOfStock")) availability = "out_of_stock";
      }
      
      // Extraire la s√©rie depuis desc-subgroup (ligne 1)
      const subgroupMatch = itemHtml.match(/<div\s+class="desc-subgroup"[^>]*>([^<]+)/i);
      const series = subgroupMatch ? decodeHtmlEntities(subgroupMatch[1].trim()) : null;
      
      // Extraire la ligne/subline depuis la 2√®me partie de desc-subgroup
      const sublineMatch = itemHtml.match(/<div\s+class="desc-subgroup"[^>]*>[^<]*<br\s*\/?>\s*([^<]+)/i);
      const subline = sublineMatch ? decodeHtmlEntities(sublineMatch[1].trim()) : null;
      
      // Extraire la condition depuis desc-cond
      const condMatch = itemHtml.match(/<div\s+class="desc-cond"[^>]*>([^<]+)/i);
      const condition = condMatch ? decodeHtmlEntities(condMatch[1].trim()) : null;
      
      if (sku && name) {
        results.push({
          id: sku,
          name: name,
          url: itemUrl,
          image: image,
          price: price,
          currency: currency,
          availability: availability,
          series: series,
          subline: subline,
          condition: condition
        });
      }
    } catch (parseErr) {
      console.warn(`[Transformerland] Erreur parsing item:`, parseErr.message);
    }
  }
  
  console.log(`[Transformerland] ${results.length} r√©sultats trouv√©s`);
  
  const result = {
    query: term,
    count: results.length,
    results: results
  };
  
  // Mettre en cache le r√©sultat
  setCache(cacheKey, result);
  
  return result;
  
    } catch (err) {
      lastError = err;
      console.error(`[Transformerland] Erreur tentative ${attempt}:`, err.message);
      
      // D√©truire la session en cas d'erreur
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

/**
 * R√©cup√®re les d√©tails d'un article Transformerland
 * @param {string} urlOrSku - URL compl√®te ou SKU de l'article
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<Object>} - D√©tails de l'article
 */
async function getTransformerlandItemDetails(urlOrSku, retries = MAX_RETRIES) {
  let itemUrl;
  
  // Si c'est un SKU num√©rique, on doit d'abord trouver l'URL
  if (/^\d+$/.test(urlOrSku)) {
    throw new Error("La recherche par SKU seul n'est pas support√©e. Utilisez l'URL compl√®te.");
  } else if (urlOrSku.startsWith('http')) {
    itemUrl = urlOrSku;
  } else if (urlOrSku.startsWith('/')) {
    itemUrl = `${TRANSFORMERLAND_BASE_URL}${urlOrSku}`;
  } else {
    throw new Error("Format d'URL invalide. Utilisez l'URL compl√®te de l'article.");
  }
  
  // V√©rifier le cache
  const cacheKey = `transformerland:item:${itemUrl}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[Transformerland] Tentative ${attempt}/${retries} pour d√©tails: ${itemUrl}`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      const pageSolution = await fsrRequest("request.get", itemUrl, fsrSessionId, {
        waitInSeconds: 1  // Transformerland n'a pas de protection forte, 1s suffit
      }, 45000);  // Timeout r√©duit √† 45s
      
      const html = pageSolution.response || "";
      console.log(`[Transformerland] Page re√ßue, taille: ${html.length}`);
  
  // V√©rifier si l'article existe
  if (html.includes("Item not found") || html.includes("Page not found")) {
    throw new Error(`Article non trouv√©: ${itemUrl}`);
  }
  
  // Extraire le SKU - essayer plusieurs patterns
  let skuMatch = html.match(/<meta\s+itemprop="sku"\s+content="([^"]+)"/i);
  if (!skuMatch) skuMatch = html.match(/itemprop="sku"[^>]*content="([^"]+)"/i);
  if (!skuMatch) skuMatch = html.match(/SKU[:\s]*(\d+)/i);
  if (!skuMatch) skuMatch = html.match(/\/(\d+)\/?$/);
  const sku = skuMatch ? skuMatch[1] : null;
  
  // Extraire le nom - essayer plusieurs patterns
  let nameMatch = html.match(/<meta\s+itemprop="name"\s+content="([^"]+)"/i);
  if (!nameMatch) nameMatch = html.match(/itemprop="name"[^>]*content="([^"]+)"/i);
  if (!nameMatch) nameMatch = html.match(/<h1[^>]*class="[^"]*store-item-name[^"]*"[^>]*>([^<]+)/i);
  if (!nameMatch) nameMatch = html.match(/<title>([^<|]+)/i);
  const name = nameMatch ? decodeHtmlEntities(nameMatch[1].trim()) : null;
  
  // Extraire le prix - format: <span itemprop="price">8.00 </span>
  let priceMatch = html.match(/<span\s+itemprop="price"[^>]*>([\d.]+)/i);
  if (!priceMatch) priceMatch = html.match(/itemprop="price"[^>]*>([\d.]+)/i);
  if (!priceMatch) priceMatch = html.match(/class="[^"]*priceLarge[^"]*"[^>]*>\s*\$([\d.]+)/i);
  if (!priceMatch) priceMatch = html.match(/class="[^"]*Price[^"]*"[^>]*>[\s\S]*?\$([\d.]+)/i);
  const price = priceMatch ? parseFloat(priceMatch[1]) : null;
  
  // Extraire la devise
  let currencyMatch = html.match(/<meta\s+itemprop="priceCurrency"\s+content="([^"]+)"/i);
  if (!currencyMatch) currencyMatch = html.match(/itemprop="priceCurrency"[^>]*content="([^"]+)"/i);
  const currency = currencyMatch ? currencyMatch[1] : "USD";
  
  // Extraire la disponibilit√©
  const availMatch = html.match(/<link\s+itemprop="availability"\s+href="([^"]+)"/i);
  let availability = "unknown";
  if (availMatch) {
    if (availMatch[1].includes("InStock")) availability = "in_stock";
    else if (availMatch[1].includes("OutOfStock")) availability = "out_of_stock";
  }
  
  // Extraire la description
  const descMatch = html.match(/<div\s+itemprop="description"[^>]*>([\s\S]*?)<\/div>/i);
  let description = null;
  if (descMatch) {
    description = descMatch[1]
      .replace(/<br\s*\/?>/gi, '\n')
      .replace(/<[^>]+>/g, '')
      .trim();
    description = decodeHtmlEntities(description);
  }
  
  // Extraire toutes les images haute r√©solution
  const images = [];
  const imgRegex = /src="([^"]*\/image\/inventory\/(?:thumbnails|hires)\/[^"]+)"/gi;
  let imgMatch;
  const seenImages = new Set();
  
  while ((imgMatch = imgRegex.exec(html)) !== null) {
    let imgUrl = imgMatch[1];
    if (!imgUrl.startsWith('http')) {
      imgUrl = `${TRANSFORMERLAND_BASE_URL}${imgUrl}`;
    }
    // Convertir en haute r√©solution
    imgUrl = imgUrl.replace('/thumbnails/', '/hires/');
    
    // √âviter les doublons
    if (!seenImages.has(imgUrl)) {
      seenImages.add(imgUrl);
      images.push(imgUrl);
    }
  }
  
  // Extraire les thumbnails depuis la galerie d'images
  const galleryRegex = /<a[^>]+href="([^"]*\/image\/inventory\/hires\/[^"]+)"/gi;
  while ((imgMatch = galleryRegex.exec(html)) !== null) {
    let imgUrl = imgMatch[1];
    if (!imgUrl.startsWith('http')) {
      imgUrl = `${TRANSFORMERLAND_BASE_URL}${imgUrl}`;
    }
    if (!seenImages.has(imgUrl)) {
      seenImages.add(imgUrl);
      images.push(imgUrl);
    }
  }
  
  // Extraire la s√©rie - format: <span class="ItemDisplay Line"> Series: Construct-Bots</span>
  let seriesMatch = html.match(/class="[^"]*Line[^"]*"[^>]*>\s*Series:\s*([^<]+)/i);
  if (!seriesMatch) seriesMatch = html.match(/<div\s+class="desc-subgroup"[^>]*>([^<]+)/i);
  const series = seriesMatch ? decodeHtmlEntities(seriesMatch[1].trim()) : null;
  
  // Extraire la subline (sous-s√©rie)
  let sublineMatch = html.match(/class="[^"]*Subline[^"]*"[^>]*>\s*(?:Subline|Sub-line):\s*([^<]+)/i);
  if (!sublineMatch) sublineMatch = html.match(/<div\s+class="desc-subgroup"[^>]*>[^<]*<br\s*\/?>\s*([^<]+)/i);
  const subline = sublineMatch ? decodeHtmlEntities(sublineMatch[1].trim()) : null;
  
  // Extraire la condition
  const condMatch = html.match(/<div\s+class="desc-cond"[^>]*>([^<]+)/i);
  const condition = condMatch ? decodeHtmlEntities(condMatch[1].trim()) : null;
  
  // Extraire l'ann√©e - format: <span class="ItemDisplay Year">Year: 2014</span>
  let yearMatch = html.match(/class="[^"]*Year[^"]*"[^>]*>\s*Year:\s*(\d{4})/i);
  if (!yearMatch) yearMatch = html.match(/<div\s+class="desc-year"[^>]*>(\d{4})/i);
  if (!yearMatch) yearMatch = html.match(/Year:\s*(\d{4})/i);
  const year = yearMatch ? parseInt(yearMatch[1]) : null;
  
  // Extraire le poids depuis les specs
  const weightMatch = html.match(/Weight[:\s]*<[^>]*>?\s*([\d.]+)\s*(oz|lb|g|kg)/i);
  let weight = null;
  if (weightMatch) {
    weight = {
      value: parseFloat(weightMatch[1]),
      unit: weightMatch[2].toLowerCase()
    };
  }
  
  // Extraire les dimensions depuis les specs (format WxHxD)
  const dimsMatch = html.match(/Dimensions?[:\s]*<[^>]*>?\s*([\d.]+)\s*x\s*([\d.]+)\s*x\s*([\d.]+)\s*(in|cm|mm)?/i);
  let dimensions = null;
  if (dimsMatch) {
    dimensions = {
      width: parseFloat(dimsMatch[1]),
      height: parseFloat(dimsMatch[2]),
      depth: parseFloat(dimsMatch[3]),
      unit: dimsMatch[4] ? dimsMatch[4].toLowerCase() : "in"
    };
  }
  
  // Extraire les cat√©gories/tags
  const categories = [];
  const catRegex = /<a\s+href="\/store\/category\/[^"]+"\s*>([^<]+)<\/a>/gi;
  let catMatch;
  while ((catMatch = catRegex.exec(html)) !== null) {
    const cat = decodeHtmlEntities(catMatch[1].trim());
    if (cat && !categories.includes(cat)) {
      categories.push(cat);
    }
  }
  
  if (!sku && !name) {
    throw new Error(`Impossible d'extraire les informations de l'article: ${itemUrl}`);
  }
  
  const result = {
    id: sku,
    name: name,
    url: itemUrl,
    price: price,
    currency: currency,
    availability: availability,
    description: description,
    images: images,
    series: series,
    subline: subline,
    condition: condition,
    year: year,
    weight: weight,
    dimensions: dimensions,
    categories: categories
  };
  
  // Mettre en cache le r√©sultat
  setCache(cacheKey, result);
  
  return result;
  
    } catch (err) {
      lastError = err;
      console.error(`[Transformerland] Erreur tentative ${attempt}:`, err.message);
      
      // D√©truire la session en cas d'erreur
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// ============================================================================
// ConsoleVariations - Fonctions de scraping (Consoles & Accessoires)
// Site: https://consolevariations.com
// Types de filtres:
//   - type=1 : Consoles uniquement
//   - type=3 : Manettes uniquement
//   - type=4 : Accessoires uniquement
//   - (aucun filtre) : Tout
// ============================================================================

/**
 * Recherche sur ConsoleVariations via scraping
 * @param {string} query - Terme de recherche
 * @param {number} maxResults - Nombre max de r√©sultats
 * @param {string} type - Type de recherche: 'all', 'consoles', 'controllers', 'accessories'
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchConsoleVariations(query, maxResults = CONSOLEVARIATIONS_DEFAULT_MAX, type = 'all', retries = MAX_RETRIES) {
  const cacheKey = `consolevariations:search:${query}:${maxResults}:${type}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    console.log(`[ConsoleVariations] Recherche "${query}" type=${type} (tentative ${attempt}/${retries})`);
    
    try {
      // Cr√©er une session FlareSolverr si n√©cessaire
      if (!fsrSessionId) {
        await createFsrSession();
      }
      
      // Construire l'URL de recherche avec le param√®tre search et le filtre type
      // type=1 : Consoles, type=3 : Controllers, type=4 : Accessoires
      let searchUrl = `${CONSOLEVARIATIONS_BASE_URL}/database?search=${encodeURIComponent(query)}`;
      if (type === 'consoles') {
        searchUrl += '&filters[type][0]=1';
      } else if (type === 'controllers') {
        searchUrl += '&filters[type][0]=3';
      } else if (type === 'accessories') {
        searchUrl += '&filters[type][0]=4';
      }
      
      console.log(`[ConsoleVariations] Acc√®s √† ${searchUrl}`);
      const response = await fsrRequest("request.get", searchUrl, fsrSessionId, {
        waitInSeconds: 3
      }, 60000);
      
      if (!response || !response.response) {
        throw new Error("Pas de r√©ponse FlareSolverr");
      }
      
      const html = response.response;
      const results = [];
      const seenNames = new Set(); // Pour d√©dupliquer par nom
      
      // Strat√©gie: Extraire les blocs contenant image CDN avec alt + lien vers collectibles
      // Format typique: <img ... alt="Nom du produit" src="https://cdn.consolevariations.com/...">
      // Suivi d'un lien <a href=".../collectibles/slug">
      
      // Pattern pour extraire: alt text + image URL
      // Les vrais r√©sultats ont des images CDN avec des alt text descriptifs
      const imgPattern = /alt="([^"]{10,})" src="(https:\/\/cdn\.consolevariations\.com\/\d+\/[^"]+)"/gi;
      const itemCandidates = [];
      let imgMatch;
      
      while ((imgMatch = imgPattern.exec(html)) !== null) {
        const name = decodeHtmlEntities(imgMatch[1].trim());
        const thumbnail = imgMatch[2];
        
        // Ignorer les images g√©n√©riques du site
        if (name.toLowerCase().includes('consolevariations') || 
            name.toLowerCase() === 'image' ||
            name.length < 10) {
          continue;
        }
        
        // Chercher le slug dans un lien proche (¬±2000 caract√®res autour de l'image)
        const imgPos = imgMatch.index;
        const contextStart = Math.max(0, imgPos - 1500);
        const contextEnd = Math.min(html.length, imgPos + 1500);
        const context = html.substring(contextStart, contextEnd);
        
        // Chercher un lien vers /collectibles/ qui contient un slug
        const slugPattern = /href="(?:https?:\/\/consolevariations\.com)?\/collectibles\/([a-z0-9][a-z0-9-]+[a-z0-9])"/gi;
        let slugMatch;
        let foundSlug = null;
        
        while ((slugMatch = slugPattern.exec(context)) !== null) {
          const candidateSlug = slugMatch[1];
          // Ignorer les slugs g√©n√©riques
          if (candidateSlug !== 'compare' && candidateSlug.length > 5) {
            foundSlug = candidateSlug;
            break;
          }
        }
        
        if (foundSlug && !seenNames.has(name)) {
          seenNames.add(name);
          itemCandidates.push({
            name,
            thumbnail,
            slug: foundSlug
          });
        }
      }
      
      // D√©dupliquer et limiter les r√©sultats
      const seenSlugs = new Set();
      for (const item of itemCandidates) {
        if (results.length >= maxResults) break;
        
        // √âviter les doublons de slug
        if (seenSlugs.has(item.slug)) continue;
        seenSlugs.add(item.slug);
        
        results.push({
          slug: item.slug,
          name: item.name,
          url: `${CONSOLEVARIATIONS_BASE_URL}/collectibles/${item.slug}`,
          image: item.thumbnail,      // Pour coh√©rence avec autres endpoints
          thumbnail: item.thumbnail   // R√©tro-compatibilit√©
        });
      }
      
      const result = {
        source: "consolevariations",
        query,
        type,
        total: results.length,
        items: results
      };
      
      setCache(cacheKey, result);
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[ConsoleVariations] Erreur tentative ${attempt}:`, err.message);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

/**
 * R√©cup√®re les d√©tails d'un item ConsoleVariations par son slug
 * @param {string} slug - Slug de l'item (ex: "nes-mattel-super-mario-bros-bundle-uk")
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<object>} - D√©tails de l'item
 */
async function getConsoleVariationsItem(slug, retries = MAX_RETRIES) {
  const cacheKey = `consolevariations:item:${slug}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    console.log(`[ConsoleVariations] D√©tails item "${slug}" (tentative ${attempt}/${retries})`);
    
    try {
      if (!fsrSessionId) {
        await createFsrSession();
      }
      
      const itemUrl = `${CONSOLEVARIATIONS_BASE_URL}/collectibles/${slug}`;
      console.log(`[ConsoleVariations] Acc√®s √† ${itemUrl}`);
      
      const response = await fsrRequest("request.get", itemUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      if (!response || !response.response) {
        throw new Error("Pas de r√©ponse FlareSolverr");
      }
      
      const html = response.response;
      
      // V√©rifier si c'est une page 404 (title sp√©cifique ou structure de page erreur)
      if (/<title>Not Found<\/title>/i.test(html) || /<h1[^>]*>Not Found<\/h1>/i.test(html)) {
        throw new Error(`Item non trouv√©: ${slug}`);
      }
      
      // Extraire le titre
      const titleMatch = html.match(/<h1[^>]*class="[^"]*text-2xl[^"]*"[^>]*>\s*([^<]+)\s*<\/h1>/i);
      const name = titleMatch ? decodeHtmlEntities(titleMatch[1].trim()) : slug.replace(/-/g, ' ');
      
      // Extraire les images depuis le JSON Alpine.js (x-data)
      // Format: images: JSON.parse('[{...}]')
      const images = [];
      const imagesMatch = html.match(/images:\s*JSON\.parse\('(\[[\s\S]*?\])'\)/);
      
      if (imagesMatch) {
        try {
          // D√©coder les unicode escapes
          const jsonStr = imagesMatch[1]
            .replace(/\\u0022/g, '"')
            .replace(/\\\//g, '/')
            .replace(/\\\\"/g, '\\"');
          
          const imagesData = JSON.parse(jsonStr);
          
          for (const img of imagesData) {
            images.push({
              id: img.id,
              url: img.original_url || img.preview_url,
              thumbnail: img.preview_url,
              alt: img.alt_text || '',
              mimeType: img.mime_type,
              size: img.size,
              contributor: img.user ? {
                id: img.user.id,
                username: img.user.username,
                avatar: img.user.profile_photo_url
              } : null
            });
          }
        } catch (e) {
          console.log(`[ConsoleVariations] Erreur parsing images JSON:`, e.message);
          
          // Fallback: extraire les URLs d'images directement
          const imgRegex = /src="(https:\/\/cdn\.consolevariations\.com\/[^"]+)"/gi;
          let imgMatch;
          const seenUrls = new Set();
          while ((imgMatch = imgRegex.exec(html)) !== null) {
            if (!seenUrls.has(imgMatch[1]) && !imgMatch[1].includes('profile-photos') && !imgMatch[1].includes('avatar')) {
              seenUrls.add(imgMatch[1]);
              images.push({
                url: imgMatch[1],
                thumbnail: imgMatch[1]
              });
            }
          }
        }
      }
      
      // Extraire les informations du tableau de d√©tails
      const details = {};
      
      // Pattern pour les lignes du tableau
      const tableRowRegex = /<tr>\s*<td[^>]*>\s*([^<]+)\s*<\/td>\s*<td[^>]*>\s*([\s\S]*?)\s*<\/td>\s*<\/tr>/gi;
      let rowMatch;
      
      while ((rowMatch = tableRowRegex.exec(html)) !== null) {
        const label = decodeHtmlEntities(rowMatch[1].trim().replace(/\s+/g, ' '));
        let value = rowMatch[2].trim();
        
        // Nettoyer le HTML de la valeur
        value = value.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
        value = decodeHtmlEntities(value);
        
        // Parser les valeurs sp√©cifiques
        switch (label.toLowerCase()) {
          case 'releases':
            // Extraire pays et ann√©e
            const releaseMatch = value.match(/([A-Za-z\s]+)\s*-?\s*(\d{4})?/);
            if (releaseMatch) {
              details.releaseCountry = releaseMatch[1].trim();
              details.releaseYear = releaseMatch[2] ? parseInt(releaseMatch[2]) : null;
            }
            break;
          case 'release type':
            details.releaseType = value;
            break;
          case 'amount produced estimate':
            details.amountProduced = value;
            break;
          case 'region code':
            details.regionCode = value;
            break;
          case 'limited edition':
            details.limitedEdition = value === 'Yes' ? true : (value === 'No' ? false : null);
            break;
          case 'color':
            details.color = value || null;
            break;
          case 'is bundle':
            details.isBundle = value === 'Yes';
            break;
          default:
            // Stocker les autres valeurs telles quelles
            const key = label.toLowerCase().replace(/\s+/g, '_');
            details[key] = value;
        }
      }
      
      // Extraire le score de raret√©
      const rarityMatch = html.match(/(\d+)\s*Rarity\s*Score/i);
      const rarityScore = rarityMatch ? parseInt(rarityMatch[1]) : null;
      
      // Extraire le score utilisateur
      const userScoreMatch = html.match(/(\w+)\s*(\d+)?\s*User\s*Score/i);
      const userScore = userScoreMatch ? userScoreMatch[1] : null;
      
      // Extraire le nombre de personnes qui veulent/poss√®dent
      const wantMatch = html.match(/(\d+)\s*people\s*want\s*this/i);
      const ownMatch = html.match(/(\d+)\s*people\s*own\s*this/i);
      const wantCount = wantMatch ? parseInt(wantMatch[1]) : 0;
      const ownCount = ownMatch ? parseInt(ownMatch[1]) : 0;
      
      // Extraire la description/info additionnelle
      const additionalInfoMatch = html.match(/Additional\s*Info[\s\S]*?<[^>]+>\s*([\s\S]*?)\s*<\/[^>]+>\s*Read\s*More/i);
      const additionalInfo = additionalInfoMatch ? decodeHtmlEntities(additionalInfoMatch[1].replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim()) : null;
      
      // Extraire la plateforme/console parente
      const platformMatch = html.match(/href="\/database\/([^"]+)"[^>]*>[\s\S]*?<span[^>]*>([^<]+)<\/span>/i);
      const platform = platformMatch ? {
        slug: platformMatch[1],
        name: decodeHtmlEntities(platformMatch[2].trim())
      } : null;
      
      // Extraire la marque
      const brandMatch = html.match(/href="\/browse\/brand\/([^"\/]+)"/i);
      const brand = brandMatch ? brandMatch[1].charAt(0).toUpperCase() + brandMatch[1].slice(1) : null;
      
      // Extraire le barcode si pr√©sent
      const barcodeMatch = html.match(/Barcode:\s*(\d+)/i);
      const barcode = barcodeMatch ? barcodeMatch[1] : null;
      
      const result = {
        source: "consolevariations",
        slug,
        name,
        url: itemUrl,
        brand,
        platform,
        images,
        details: {
          releaseCountry: details.releaseCountry || null,
          releaseYear: details.releaseYear || null,
          releaseType: details.releaseType || null,
          regionCode: details.regionCode || null,
          amountProduced: details.amountProduced || null,
          limitedEdition: details.limitedEdition,
          isBundle: details.isBundle || false,
          color: details.color || null,
          barcode
        },
        stats: {
          rarityScore,
          userScore,
          wantCount,
          ownCount
        },
        additionalInfo
      };
      
      setCache(cacheKey, result);
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[ConsoleVariations] Erreur tentative ${attempt}:`, err.message);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

/**
 * Liste les plateformes disponibles sur ConsoleVariations
 * @param {string} brand - Marque optionnelle (nintendo, sony, microsoft, sega...)
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<object>} - Liste des plateformes
 */
async function listConsoleVariationsPlatforms(brand = null, retries = MAX_RETRIES) {
  const cacheKey = `consolevariations:platforms:${brand || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    console.log(`[ConsoleVariations] Liste plateformes${brand ? ` (${brand})` : ''} (tentative ${attempt}/${retries})`);
    
    try {
      if (!fsrSessionId) {
        await createFsrSession();
      }
      
      const url = brand 
        ? `${CONSOLEVARIATIONS_BASE_URL}/browse/brand/${brand.toLowerCase()}/platforms`
        : `${CONSOLEVARIATIONS_BASE_URL}/browse/brand`;
      
      console.log(`[ConsoleVariations] Acc√®s √† ${url}`);
      
      const response = await fsrRequest("request.get", url, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      if (!response || !response.response) {
        throw new Error("Pas de r√©ponse FlareSolverr");
      }
      
      const html = response.response;
      const platforms = [];
      
      if (brand) {
        // Extraire les plateformes de la marque
        // Pattern: href="/database/slug" avec nom
        const platformRegex = /href="\/database\/([^"]+)"[^>]*>[\s\S]*?(?:<img[^>]*src="([^"]*)")?[\s\S]*?([A-Za-z0-9\s]+(?:PSP|PlayStation|Xbox|Switch|Game\s*Boy|NES|SNES|Genesis|Saturn|Dreamcast|Wii|DS|3DS)[A-Za-z0-9\s]*)/gi;
        
        // Plus simple: chercher tous les liens /database/
        const simpleRegex = /href="\/database\/([^"]+)"[^>]*>[^<]*<[^>]*>[^<]*([^<]+)/gi;
        let match;
        const seen = new Set();
        
        while ((match = simpleRegex.exec(html)) !== null) {
          const slug = match[1];
          if (!seen.has(slug) && !slug.includes('?')) {
            seen.add(slug);
            const name = decodeHtmlEntities(match[2].trim());
            if (name && name.length > 1) {
              platforms.push({
                slug,
                name,
                url: `${CONSOLEVARIATIONS_BASE_URL}/database/${slug}`
              });
            }
          }
        }
      } else {
        // Extraire les marques
        const brandRegex = /href="\/browse\/brand\/([^"\/]+)(?:\/platforms)?"[^>]*>[\s\S]*?(?:<img[^>]*>)?[\s\S]*?([A-Za-z0-9\s]+)<\/a>/gi;
        let match;
        const seen = new Set();
        
        while ((match = brandRegex.exec(html)) !== null) {
          const slug = match[1];
          if (!seen.has(slug)) {
            seen.add(slug);
            platforms.push({
              slug,
              name: decodeHtmlEntities(match[2].trim()) || slug.charAt(0).toUpperCase() + slug.slice(1),
              url: `${CONSOLEVARIATIONS_BASE_URL}/browse/brand/${slug}/platforms`
            });
          }
        }
      }
      
      const result = {
        source: "consolevariations",
        type: brand ? "platforms" : "brands",
        brand: brand || null,
        total: platforms.length,
        items: platforms
      };
      
      setCache(cacheKey, result, 3600000); // Cache 1 heure pour les listes statiques
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[ConsoleVariations] Erreur tentative ${attempt}:`, err.message);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

/**
 * Browse les items d'une plateforme sp√©cifique
 * @param {string} platformSlug - Slug de la plateforme (ex: "nes", "sony-playstation")
 * @param {number} maxResults - Nombre max de r√©sultats
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<object>} - Items de la plateforme
 */
async function browseConsoleVariationsPlatform(platformSlug, maxResults = CONSOLEVARIATIONS_DEFAULT_MAX, retries = MAX_RETRIES) {
  const cacheKey = `consolevariations:browse:${platformSlug}:${maxResults}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    console.log(`[ConsoleVariations] Browse plateforme "${platformSlug}" (tentative ${attempt}/${retries})`);
    
    try {
      if (!fsrSessionId) {
        await createFsrSession();
      }
      
      const url = `${CONSOLEVARIATIONS_BASE_URL}/database/${platformSlug}`;
      console.log(`[ConsoleVariations] Acc√®s √† ${url}`);
      
      const response = await fsrRequest("request.get", url, fsrSessionId, {
        waitInSeconds: 3
      }, 60000);
      
      if (!response || !response.response) {
        throw new Error("Pas de r√©ponse FlareSolverr");
      }
      
      const html = response.response;
      
      // V√©rifier si c'est une page 404 (title sp√©cifique ou structure de page erreur)
      if (/<title>Not Found<\/title>/i.test(html) || /<h1[^>]*>Not Found<\/h1>/i.test(html)) {
        throw new Error(`Plateforme non trouv√©e: ${platformSlug}`);
      }
      
      const items = [];
      const seen = new Set();
      
      // Approche 1: Extraire les liens complets vers collectibles avec leur contexte
      // Les URLs compl√®tes (avec domaine) sont dans le corps principal
      const fullLinkRegex = /href="https?:\/\/consolevariations\.com\/collectibles\/([^"]+)"[^>]*>\s*([^<]*)</gi;
      let match;
      
      while ((match = fullLinkRegex.exec(html)) !== null && items.length < maxResults) {
        const slug = match[1];
        let name = match[2] ? match[2].trim() : null;
        
        // Ignorer les noms vides ou tr√®s courts
        if (slug && !seen.has(slug) && name && name.length > 2) {
          seen.add(slug);
          
          // Chercher l'image CDN la plus proche pour ce slug (avec ID num√©rique dans l'URL)
          const imgPattern = new RegExp(`src="(https://cdn\\.consolevariations\\.com/\\d+/[^"]+)"[^>]*alt="[^"]*${slug.replace(/-/g, '.*?')}`, 'i');
          let imgMatch = html.match(imgPattern);
          
          // Si pas trouv√©, chercher une image CDN avec num√©ro dans les 2000 caract√®res avant ce match
          if (!imgMatch) {
            const startIdx = Math.max(0, match.index - 2000);
            const context = html.substring(startIdx, match.index);
            const imgInContext = context.match(/src="(https:\/\/cdn\.consolevariations\.com\/\d+\/[^"]+)"/gi);
            if (imgInContext && imgInContext.length > 0) {
              // Prendre la derni√®re image (la plus proche du lien)
              const lastImg = imgInContext[imgInContext.length - 1];
              imgMatch = [null, lastImg.match(/src="([^"]+)"/)[1]];
            }
          }
          
          items.push({
            slug,
            name: decodeHtmlEntities(name),
            url: `${CONSOLEVARIATIONS_BASE_URL}/collectibles/${slug}`,
            thumbnail: imgMatch ? imgMatch[1] : null
          });
        }
      }
      
      // Si pas assez de r√©sultats, essayer un pattern alternatif avec URLs relatives
      if (items.length < maxResults) {
        const altRegex = /href="\/collectibles\/([^"]+)"/gi;
        while ((match = altRegex.exec(html)) !== null && items.length < maxResults) {
          const slug = match[1];
          if (!seen.has(slug)) {
            seen.add(slug);
            items.push({
              slug,
              name: slug.replace(/-/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
              url: `${CONSOLEVARIATIONS_BASE_URL}/collectibles/${slug}`,
              thumbnail: null
            });
          }
        }
      }
      
      const result = {
        source: "consolevariations",
        platform: platformSlug,
        total: items.length,
        items: items.slice(0, maxResults)
      };
      
      setCache(cacheKey, result);
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[ConsoleVariations] Erreur tentative ${attempt}:`, err.message);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// === Endpoints ConsoleVariations ===

// Recherche de consoles/accessoires/controllers
// type: 'all' (d√©faut), 'consoles', 'controllers', 'accessories'
app.get("/consolevariations/search", async (req, res) => {
  const { q, query, max, type } = req.query;
  const searchTerm = q || query;
  const maxResults = max ? parseInt(max) : CONSOLEVARIATIONS_DEFAULT_MAX;
  const searchType = type || 'all'; // all, consoles, controllers, accessories
  
  if (!searchTerm) {
    return res.status(400).json({ error: "Param√®tre 'q' ou 'query' manquant" });
  }
  
  // Valider le type
  if (!['all', 'consoles', 'controllers', 'accessories'].includes(searchType)) {
    return res.status(400).json({ 
      error: "Param√®tre 'type' invalide", 
      validValues: ['all', 'consoles', 'controllers', 'accessories'] 
    });
  }
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await searchConsoleVariationsLib(searchTerm, maxResults, searchType);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/search:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    res.status(500).json({ error: err.message });
  }
});

// D√©tails d'un item par slug
app.get("/consolevariations/item/:slug", async (req, res) => {
  const { slug } = req.params;
  
  if (!slug) {
    return res.status(400).json({ error: "Param√®tre 'slug' manquant" });
  }
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await getConsoleVariationsItem(slug);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/item:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Liste des marques ou plateformes d'une marque
app.get("/consolevariations/platforms", async (req, res) => {
  const { brand } = req.query;
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await listConsoleVariationsPlatforms(brand);
    addCacheHeaders(res, 3600); // Cache 1 heure
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/platforms:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Browse une plateforme sp√©cifique
app.get("/consolevariations/browse/:platform", async (req, res) => {
  const { platform } = req.params;
  const { max } = req.query;
  const maxResults = max ? parseInt(max) : CONSOLEVARIATIONS_DEFAULT_MAX;
  
  if (!platform) {
    return res.status(400).json({ error: "Param√®tre 'platform' manquant" });
  }
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await browseConsoleVariationsPlatform(platform, maxResults);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/browse:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// === Endpoint recherche Transformerland ===
app.get("/transformerland/search", async (req, res) => {
  const { q, term, max } = req.query;
  const searchTerm = q || term;
  const maxResults = max ? parseInt(max) : TRANSFORMERLAND_DEFAULT_MAX;
  
  if (!searchTerm) {
    return res.status(400).json({ error: "param√®tre 'q' ou 'term' manquant" });
  }
  
  try {
    metrics.sources.transformerland.requests++;
    const result = await searchTransformerlandLib(searchTerm, maxResults);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /transformerland/search:", err);
    metrics.requests.errors++;
    metrics.sources.transformerland.errors++;
    res.status(500).json({ error: err.message });
  }
});

// === Endpoint d√©tails article Transformerland par URL ===
app.get("/transformerland/item", async (req, res) => {
  const { url } = req.query;
  
  if (!url) {
    return res.status(400).json({ error: "param√®tre 'url' manquant" });
  }
  
  try {
    metrics.sources.transformerland.requests++;
    const result = await getTransformerlandItemDetails(url);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /transformerland/item:", err);
    metrics.requests.errors++;
    metrics.sources.transformerland.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// D√©marrer le serveur
const server = app.listen(PORT, "0.0.0.0", () => {
  console.log(`üöÄ Toys API running at http://0.0.0.0:${PORT}`);
  console.log(`   - LEGO: /lego/search, /lego/product/:id, /lego/instructions/:id`);
  console.log(`   - Coleka: /coleka/search, /coleka/item`);
  console.log(`   - Lulu-Berlu: /luluberlu/search, /luluberlu/item/:id`);
  console.log(`   - ConsoleVariations: /consolevariations/search, /consolevariations/item/:slug, /consolevariations/platforms, /consolevariations/browse/:platform`);
  console.log(`   - Transformerland: /transformerland/search, /transformerland/item`);
  console.log(`   - Paninimania: /paninimania/search, /paninimania/album/:id`);
  console.log(`   - Compression: gzip enabled`);
  console.log(`   - CORS: enabled`);
  console.log(`   - Metrics: /health, DELETE /metrics`);
});

// Graceful shutdown - fermeture propre lors de l'arr√™t
const gracefulShutdown = async (signal) => {
  console.log(`\n‚ö†Ô∏è  ${signal} re√ßu. Arr√™t gracieux en cours...`);
  
  // D√©truire la session FlareSolverr si elle existe
  if (fsrSessionId) {
    try {
      console.log("[FSR] Destruction de la session...");
      await destroyFsrSession(fsrSessionId);
      console.log("[FSR] Session d√©truite");
    } catch (err) {
      console.error("[FSR] Erreur destruction session:", err.message);
    }
  }
  
  // Fermer le serveur HTTP
  server.close(() => {
    console.log("‚úÖ Serveur HTTP ferm√©");
    console.log(`üìä Stats finales: ${metrics.requests.total} requ√™tes, ${metrics.requests.cached} en cache, ${metrics.requests.errors} erreurs`);
    process.exit(0);
  });
  
  // Forcer la fermeture apr√®s 10 secondes
  setTimeout(() => {
    console.error("‚ö†Ô∏è  For√ßage de l'arr√™t apr√®s timeout");
    process.exit(1);
  }, 10000);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

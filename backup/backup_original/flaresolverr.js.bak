/**
 * lib/flaresolverr.js - Module FlareSolverr pour bypass Cloudflare
 * toys_api v1.26.0
 * 
 * Gère les sessions FlareSolverr et les requêtes à travers Cloudflare
 * 
 * IMPORTANT: Ce module utilise l'état centralisé de state.js
 */

import { createLogger } from './utils/logger.js';
import {
  getFsrSessionId,
  setFsrSessionId,
  getLastLegoHomeVisit,
  setLastLegoHomeVisit,
  areLegoSessionCookiesValid,
  resetFsrSession,
  LEGO_SESSION_TTL
} from './state.js';

const log = createLogger('FSR');
const logColeka = createLogger('Coleka');

// ========================================
// Configuration
// ========================================
const FSR_BASE = process.env.FSR_URL || "http://flaresolverr:8191/v1";
const COLEKA_BASE_URL = "https://www.coleka.com";

// ========================================
// Fonctions de gestion de session
// ========================================

/**
 * Crée une session FlareSolverr persistante
 * @returns {Promise<string|null>} Session ID ou null si erreur
 */
async function createFsrSession() {
  const body = {
    cmd: "sessions.create"
  };

  try {
    const res = await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const json = await res.json();
    if (json.status === "ok" && json.session) {
      log.info("Session créée", { session: json.session });
      setFsrSessionId(json.session);
      return json.session;
    }
  } catch (err) {
    log.error("Erreur création session", { error: err.message });
  }
  return null;
}

/**
 * Détruit une session FlareSolverr
 * @param {string} sessionId - ID de session à détruire (optionnel, utilise la session courante si non fourni)
 */
async function destroyFsrSession(sessionId = null) {
  const session = sessionId || getFsrSessionId();
  if (!session) return;
  
  const body = {
    cmd: "sessions.destroy",
    session: session
  };

  try {
    await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    log.info("Session détruite", { session });
    // Réinitialiser l'état global
    resetFsrSession();
  } catch (err) {
    log.error("Erreur destruction session", { error: err.message });
  }
}

/**
 * Obtient ou crée une session FlareSolverr
 * @returns {Promise<string|null>} Session ID
 */
async function ensureFsrSession() {
  let sessionId = getFsrSessionId();
  if (!sessionId) {
    sessionId = await createFsrSession();
  }
  return sessionId;
}

/**
 * Exécute une requête via FlareSolverr
 * @param {string} cmd - Commande (request.get, request.post)
 * @param {string} url - URL à requêter
 * @param {string|null} session - Session ID optionnelle (utilise la session courante si non fourni)
 * @param {object} extraOptions - Options additionnelles (postData, headers, etc.)
 * @param {number} maxTimeout - Timeout max en ms
 * @returns {Promise<object>} Solution FlareSolverr
 */
async function fsrRequest(cmd, url, session = null, extraOptions = {}, maxTimeout = 60000) {
  const body = {
    cmd,
    url,
    maxTimeout,
    ...extraOptions
  };

  // Utiliser la session fournie ou la session courante
  const sessionId = session || getFsrSessionId();
  if (sessionId) {
    body.session = sessionId;
  }

  const res = await fetch(FSR_BASE, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const errorText = await res.text();
    log.error("HTTP error", { status: res.status, response: errorText });
    throw new Error(`FlareSolverr error ${res.status}`);
  }
  
  const json = await res.json();
  
  if (json.status !== "ok") {
    log.error("Status error", { status: json.status, message: json.message });
    throw new Error(`FlareSolverr status: ${json.status} - ${json.message || 'unknown error'}`);
  }
  
  if (!json.solution) throw new Error("FlareSolverr: pas de solution");
  
  return json.solution;
}

// ========================================
// Fonctions spécifiques par site
// ========================================

/**
 * Résout le challenge anti-bot Coleka
 * Le site demande de cliquer sur un bouton qui fait un POST à /verify/ajax.php
 * @param {string} session - Session FlareSolverr (optionnel)
 * @param {string} lang - Langue (fr, en, etc.)
 * @returns {Promise<boolean>} true si résolu
 */
async function solveColekaChallenge(session = null, lang = "fr") {
  logColeka.info("Résolution du challenge anti-bot...");
  
  const sessionId = session || getFsrSessionId();
  
  // Le bouton fait un POST à /verify/ajax.php avec lang et token
  const verifyUrl = `${COLEKA_BASE_URL}/verify/ajax.php`;
  const postData = `lang=${lang}&token=${Date.now()}`;
  
  try {
    const solution = await fsrRequest("request.post", verifyUrl, sessionId, {
      postData: postData,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "X-Requested-With": "XMLHttpRequest",
        "Referer": `${COLEKA_BASE_URL}/verify/?lang=${lang}`
      }
    }, 60000);
    
    const responseText = solution.response || "";
    logColeka.debug("Réponse verify", { response: responseText.substring(0, 200) });
    
    // Vérifier si la réponse contient success: true
    if (responseText.includes('"success"') && responseText.includes('true')) {
      logColeka.info("✅ Challenge résolu avec succès!");
      return true;
    }
    
    // Essayer de parser la réponse JSON
    try {
      const json = JSON.parse(responseText);
      if (json.success) {
        logColeka.info("✅ Challenge résolu avec succès!");
        return true;
      } else {
        logColeka.warn("❌ Challenge échoué", { error: json.error || "unknown" });
        return false;
      }
    } catch (e) {
      logColeka.debug("Réponse non-JSON, vérification par contenu...");
      // Si ce n'est pas du JSON, vérifier si on n'a pas d'erreur
      return !responseText.includes("error") && responseText.length > 0;
    }
  } catch (err) {
    logColeka.error("Erreur résolution challenge", { error: err.message });
    return false;
  }
}

// ========================================
// Exports (ES Modules)
// ========================================
export {
  // Configuration
  FSR_BASE,
  LEGO_SESSION_TTL,
  
  // Fonctions principales
  createFsrSession,
  destroyFsrSession,
  ensureFsrSession,
  fsrRequest,
  solveColekaChallenge,
  
  // Re-export depuis state.js pour compatibilité
  getFsrSessionId,
  setFsrSessionId,
  getLastLegoHomeVisit,
  setLastLegoHomeVisit,
  areLegoSessionCookiesValid,
  resetFsrSession
};

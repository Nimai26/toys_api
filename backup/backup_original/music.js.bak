/**
 * lib/music.js - Module Musique
 * toys_api v1.26.0
 * 
 * APIs: MusicBrainz, Deezer, Discogs, iTunes
 */

import fetch from 'node-fetch';
import { createLogger } from './utils/logger.js';
import {
  MUSICBRAINZ_BASE_URL,
  MUSICBRAINZ_COVER_URL,
  DEEZER_BASE_URL,
  DISCOGS_BASE_URL,
  ITUNES_BASE_URL,
  MUSIC_DEFAULT_MAX,
  USER_AGENT
} from './config.js';

const logMB = createLogger('MusicBrainz');
const logDeezer = createLogger('Deezer');
const logDiscogs = createLogger('Discogs');
const logItunes = createLogger('iTunes');

// ============================================================================
// UTILITAIRES
// ============================================================================

/**
 * Formate une durée en ms vers "mm:ss"
 */
export function formatDuration(ms) {
  const totalSeconds = Math.round(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

// ============================================================================
// MUSICBRAINZ
// ============================================================================

/**
 * Recherche sur MusicBrainz (release-group = album)
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, artist, type)
 * @returns {Promise<object>} - Résultats
 */
export async function searchMusicBrainz(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, artist = null, type = 'release-group' } = options;
  
  // Construire la requête Lucene
  let luceneQuery = query;
  if (artist) {
    luceneQuery = `"${query}" AND artist:"${artist}"`;
  }
  
  const url = `${MUSICBRAINZ_BASE_URL}/${type}?query=${encodeURIComponent(luceneQuery)}&limit=${limit}&fmt=json`;
  
  logMB.debug(`Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)' // MusicBrainz exige un User-Agent identifiable
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const data = await response.json();
  const groups = data['release-groups'] || [];
  
  const results = groups.map(rg => ({
    id: rg.id,
    type: 'album',
    title: rg.title,
    artist: rg['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    artistId: rg['artist-credit']?.[0]?.artist?.id || null,
    releaseDate: rg['first-release-date'] || null,
    year: rg['first-release-date']?.substring(0, 4) || null,
    primaryType: rg['primary-type'] || null,
    secondaryTypes: rg['secondary-types'] || [],
    score: rg.score || null,
    coverUrl: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-250`,
    coverUrlLarge: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-500`,
    mbUrl: `https://musicbrainz.org/release-group/${rg.id}`,
    source: 'musicbrainz'
  }));
  
  return {
    query,
    totalResults: data.count || results.length,
    count: results.length,
    results,
    source: 'musicbrainz'
  };
}

/**
 * Récupère les détails d'un album MusicBrainz
 * @param {string} mbid - MusicBrainz ID (release-group)
 * @returns {Promise<object>} - Détails album
 */
export async function getMusicBrainzAlbum(mbid) {
  const url = `${MUSICBRAINZ_BASE_URL}/release-group/${mbid}?inc=artists+releases+tags+ratings&fmt=json`;
  
  logMB.debug(`Album: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Album non trouvé: ${mbid}`);
    }
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const rg = await response.json();
  
  // Récupérer la liste des pistes du premier release
  let tracks = [];
  if (rg.releases && rg.releases.length > 0) {
    try {
      const releaseId = rg.releases[0].id;
      const releaseUrl = `${MUSICBRAINZ_BASE_URL}/release/${releaseId}?inc=recordings&fmt=json`;
      const releaseResp = await fetch(releaseUrl, {
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
        }
      });
      if (releaseResp.ok) {
        const releaseData = await releaseResp.json();
        if (releaseData.media) {
          tracks = releaseData.media.flatMap((medium, mediumIdx) =>
            (medium.tracks || []).map((track, trackIdx) => ({
              position: track.position || trackIdx + 1,
              disc: mediumIdx + 1,
              title: track.title,
              duration: track.length ? Math.round(track.length / 1000) : null,
              durationFormatted: track.length ? formatDuration(track.length) : null
            }))
          );
        }
      }
    } catch (err) {
      logMB.error('Error fetching tracks', { error: err.message });
    }
  }
  
  return {
    id: rg.id,
    type: 'album',
    title: rg.title,
    artist: rg['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    artists: rg['artist-credit']?.map(ac => ({
      id: ac.artist?.id,
      name: ac.name || ac.artist?.name,
      joinPhrase: ac.joinphrase
    })) || [],
    releaseDate: rg['first-release-date'] || null,
    year: rg['first-release-date']?.substring(0, 4) || null,
    primaryType: rg['primary-type'] || null,
    secondaryTypes: rg['secondary-types'] || [],
    tags: (rg.tags || []).map(t => ({ name: t.name, count: t.count })).sort((a, b) => b.count - a.count),
    rating: rg.rating ? { value: rg.rating.value, votes: rg.rating['votes-count'] } : null,
    releases: (rg.releases || []).slice(0, 10).map(r => ({
      id: r.id,
      title: r.title,
      status: r.status,
      date: r.date,
      country: r.country,
      barcode: r.barcode
    })),
    tracks,
    trackCount: tracks.length,
    coverUrl: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-250`,
    coverUrlLarge: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-500`,
    mbUrl: `https://musicbrainz.org/release-group/${rg.id}`,
    source: 'musicbrainz'
  };
}

/**
 * Recherche un album par code-barres sur MusicBrainz
 * @param {string} barcode - Code-barres (UPC/EAN)
 * @returns {Promise<object>} - Album trouvé
 */
export async function searchMusicBrainzByBarcode(barcode) {
  const url = `${MUSICBRAINZ_BASE_URL}/release?query=barcode:${encodeURIComponent(barcode)}&fmt=json`;
  
  logMB.debug(` Barcode: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.releases || data.releases.length === 0) {
    return { found: false, barcode, source: 'musicbrainz' };
  }
  
  const release = data.releases[0];
  
  return {
    found: true,
    barcode,
    id: release.id,
    releaseGroupId: release['release-group']?.id,
    title: release.title,
    artist: release['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    date: release.date,
    country: release.country,
    status: release.status,
    label: release['label-info']?.[0]?.label?.name || null,
    catalogNumber: release['label-info']?.[0]?.['catalog-number'] || null,
    coverUrl: release['release-group']?.id 
      ? `${MUSICBRAINZ_COVER_URL}/release-group/${release['release-group'].id}/front-250` 
      : null,
    mbUrl: `https://musicbrainz.org/release/${release.id}`,
    source: 'musicbrainz'
  };
}

// ============================================================================
// DEEZER
// ============================================================================

/**
 * Recherche sur Deezer
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, type: album|artist|track)
 * @returns {Promise<object>} - Résultats
 */
export async function searchDeezer(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, type = 'album' } = options;
  
  const url = `${DEEZER_BASE_URL}/search/${type}?q=${encodeURIComponent(query)}&limit=${limit}`;
  
  logDeezer.debug(` Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Deezer: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (data.error) {
    throw new Error(`Deezer: ${data.error.message}`);
  }
  
  const results = (data.data || []).map(item => {
    if (type === 'album') {
      return {
        id: item.id,
        type: 'album',
        title: item.title,
        artist: item.artist?.name || null,
        artistId: item.artist?.id || null,
        coverUrl: item.cover_medium || item.cover,
        coverUrlLarge: item.cover_xl || item.cover_big,
        releaseDate: null,
        trackCount: item.nb_tracks || null,
        explicit: item.explicit_lyrics || false,
        genre: item.genre_id || null,
        deezerUrl: item.link,
        source: 'deezer'
      };
    } else if (type === 'artist') {
      return {
        id: item.id,
        type: 'artist',
        name: item.name,
        picture: item.picture_medium,
        pictureXl: item.picture_xl,
        nbAlbums: item.nb_album,
        nbFans: item.nb_fan,
        deezerUrl: item.link,
        source: 'deezer'
      };
    } else {
      return {
        id: item.id,
        type: 'track',
        title: item.title,
        artist: item.artist?.name,
        album: item.album?.title,
        albumId: item.album?.id,
        duration: item.duration,
        durationFormatted: formatDuration(item.duration * 1000),
        preview: item.preview,
        explicit: item.explicit_lyrics,
        deezerUrl: item.link,
        source: 'deezer'
      };
    }
  });
  
  return {
    query,
    type,
    totalResults: data.total || results.length,
    count: results.length,
    results,
    source: 'deezer'
  };
}

/**
 * Récupère les détails d'un album Deezer
 * @param {number|string} albumId - ID album Deezer
 * @returns {Promise<object>} - Détails album
 */
export async function getDeezerAlbum(albumId) {
  const cleanId = String(albumId).replace(/^music_/i, '');
  const url = `${DEEZER_BASE_URL}/album/${cleanId}`;
  
  logDeezer.debug(` Album: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Album non trouvé: ${albumId}`);
    }
    throw new Error(`Erreur Deezer: ${response.status}`);
  }
  
  const album = await response.json();
  
  if (album.error) {
    throw new Error(`Deezer: ${album.error.message || album.error.type || 'no data'}`);
  }
  
  if (!album.id) {
    throw new Error(`Deezer: Album non trouvé (ID: ${cleanId})`);
  }
  
  return {
    id: album.id,
    type: 'album',
    title: album.title,
    upc: album.upc || null,
    artist: album.artist?.name || null,
    artistId: album.artist?.id || null,
    artistPicture: album.artist?.picture_medium || null,
    coverUrl: album.cover_medium || album.cover,
    coverUrlLarge: album.cover_xl || album.cover_big,
    releaseDate: album.release_date || null,
    year: album.release_date?.substring(0, 4) || null,
    duration: album.duration || null,
    durationFormatted: album.duration ? formatDuration(album.duration * 1000) : null,
    trackCount: album.nb_tracks || 0,
    fans: album.fans || 0,
    explicit: album.explicit_lyrics || false,
    genres: (album.genres?.data || []).map(g => g.name),
    label: album.label || null,
    tracks: (album.tracks?.data || []).map((t, idx) => ({
      position: idx + 1,
      id: t.id,
      title: t.title,
      duration: t.duration,
      durationFormatted: formatDuration(t.duration * 1000),
      preview: t.preview,
      explicit: t.explicit_lyrics
    })),
    contributors: (album.contributors || []).map(c => ({
      id: c.id,
      name: c.name,
      role: c.role,
      picture: c.picture_medium
    })),
    deezerUrl: album.link,
    source: 'deezer'
  };
}

/**
 * Récupère les détails d'un artiste Deezer
 * @param {number|string} artistId - ID artiste Deezer
 * @returns {Promise<object>} - Détails artiste
 */
export async function getDeezerArtist(artistId) {
  const cleanId = String(artistId).replace(/^music_/i, '');
  
  const [artistResp, topResp, albumsResp] = await Promise.all([
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}`),
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}/top?limit=10`),
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}/albums?limit=50`)
  ]);
  
  if (!artistResp.ok) {
    if (artistResp.status === 404) {
      throw new Error(`Artiste non trouvé: ${artistId}`);
    }
    throw new Error(`Erreur Deezer: ${artistResp.status}`);
  }
  
  const artist = await artistResp.json();
  const topTracks = topResp.ok ? await topResp.json() : { data: [] };
  const albums = albumsResp.ok ? await albumsResp.json() : { data: [] };
  
  return {
    id: artist.id,
    type: 'artist',
    name: artist.name,
    picture: artist.picture_medium,
    pictureXl: artist.picture_xl,
    nbAlbums: artist.nb_album,
    nbFans: artist.nb_fan,
    topTracks: (topTracks.data || []).map(t => ({
      id: t.id,
      title: t.title,
      duration: t.duration,
      durationFormatted: formatDuration(t.duration * 1000),
      album: t.album?.title,
      albumCover: t.album?.cover_medium,
      preview: t.preview,
      rank: t.rank
    })),
    albums: (albums.data || []).map(a => ({
      id: a.id,
      title: a.title,
      coverUrl: a.cover_medium,
      releaseDate: a.release_date,
      type: a.record_type
    })),
    deezerUrl: artist.link,
    source: 'deezer'
  };
}

// ============================================================================
// DISCOGS
// ============================================================================

/**
 * Recherche sur Discogs
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, type, token)
 * @returns {Promise<object>} - Résultats
 */
export async function searchDiscogs(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, type = 'release', token = null } = options;
  
  let url = `${DISCOGS_BASE_URL}/database/search?q=${encodeURIComponent(query)}&type=${type}&per_page=${limit}`;
  
  if (token) {
    url += `&token=${token}`;
  }
  
  logDiscogs.debug(` Search: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('Limite Discogs atteinte (60 req/min avec token, 25 sans)');
    }
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const data = await response.json();
  
  const results = (data.results || []).map(item => ({
    id: item.id,
    type: item.type,
    title: item.title,
    artist: item.title?.split(' - ')[0] || null,
    albumTitle: item.title?.split(' - ')[1] || item.title,
    year: item.year || null,
    country: item.country || null,
    format: item.format || [],
    label: item.label || [],
    genre: item.genre || [],
    style: item.style || [],
    coverUrl: item.cover_image || item.thumb,
    masterId: item.master_id || null,
    resourceUrl: item.resource_url,
    discogsUrl: item.uri ? `https://www.discogs.com${item.uri}` : null,
    source: 'discogs'
  }));
  
  return {
    query,
    type,
    totalResults: data.pagination?.items || results.length,
    count: results.length,
    page: data.pagination?.page || 1,
    totalPages: data.pagination?.pages || 1,
    results,
    source: 'discogs'
  };
}

/**
 * Récupère les détails d'un release Discogs
 * @param {number|string} releaseId - ID release Discogs
 * @param {string} token - Token Discogs (optionnel)
 * @returns {Promise<object>} - Détails release
 */
export async function getDiscogsRelease(releaseId, token = null) {
  let url = `${DISCOGS_BASE_URL}/releases/${releaseId}`;
  if (token) {
    url += `?token=${token}`;
  }
  
  logDiscogs.debug(` Release: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Release non trouvée: ${releaseId}`);
    }
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const release = await response.json();
  
  return {
    id: release.id,
    type: 'release',
    title: release.title,
    artists: (release.artists || []).map(a => ({
      id: a.id,
      name: a.name,
      role: a.role
    })),
    artist: (release.artists || []).map(a => a.name).join(', '),
    year: release.year || null,
    releaseDate: release.released || null,
    country: release.country || null,
    genres: release.genres || [],
    styles: release.styles || [],
    formats: (release.formats || []).map(f => ({
      name: f.name,
      qty: f.qty,
      descriptions: f.descriptions
    })),
    labels: (release.labels || []).map(l => ({
      id: l.id,
      name: l.name,
      catno: l.catno
    })),
    tracklist: (release.tracklist || []).map(t => ({
      position: t.position,
      title: t.title,
      duration: t.duration,
      artists: t.artists?.map(a => a.name)
    })),
    trackCount: release.tracklist?.length || 0,
    notes: release.notes || null,
    images: (release.images || []).map(img => ({
      type: img.type,
      uri: img.uri,
      uri150: img.uri150
    })),
    coverUrl: release.images?.[0]?.uri150 || release.thumb,
    coverUrlLarge: release.images?.[0]?.uri || null,
    masterId: release.master_id || null,
    masterUrl: release.master_url || null,
    lowestPrice: release.lowest_price || null,
    numForSale: release.num_for_sale || 0,
    community: release.community ? {
      have: release.community.have,
      want: release.community.want,
      rating: release.community.rating?.average,
      ratingCount: release.community.rating?.count
    } : null,
    discogsUrl: release.uri,
    source: 'discogs'
  };
}

/**
 * Recherche par code-barres sur Discogs
 * @param {string} barcode - Code-barres
 * @param {string} token - Token Discogs (optionnel)
 * @returns {Promise<object>} - Release trouvée
 */
export async function searchDiscogsByBarcode(barcode, token = null) {
  let url = `${DISCOGS_BASE_URL}/database/search?barcode=${encodeURIComponent(barcode)}&type=release`;
  if (token) {
    url += `&token=${token}`;
  }
  
  logDiscogs.debug(` Barcode: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.results || data.results.length === 0) {
    return { found: false, barcode, source: 'discogs' };
  }
  
  const item = data.results[0];
  
  return {
    found: true,
    barcode,
    id: item.id,
    title: item.title,
    artist: item.title?.split(' - ')[0] || null,
    albumTitle: item.title?.split(' - ')[1] || item.title,
    year: item.year,
    country: item.country,
    format: item.format,
    label: item.label,
    genre: item.genre,
    coverUrl: item.cover_image || item.thumb,
    discogsUrl: item.uri ? `https://www.discogs.com${item.uri}` : null,
    source: 'discogs'
  };
}

// ============================================================================
// ITUNES
// ============================================================================

/**
 * Recherche sur iTunes
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, entity, country)
 * @returns {Promise<object>} - Résultats
 */
export async function searchItunes(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, entity = 'album', country = 'FR' } = options;
  
  const url = `${ITUNES_BASE_URL}/search?term=${encodeURIComponent(query)}&entity=${entity}&country=${country}&limit=${limit}`;
  
  logItunes.debug(` Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur iTunes: ${response.status}`);
  }
  
  const data = await response.json();
  
  const results = (data.results || []).map(item => {
    if (entity === 'album') {
      return {
        id: item.collectionId,
        type: 'album',
        title: item.collectionName,
        artist: item.artistName,
        artistId: item.artistId,
        coverUrl: item.artworkUrl100,
        coverUrlLarge: item.artworkUrl100?.replace('100x100', '600x600'),
        releaseDate: item.releaseDate,
        year: item.releaseDate?.substring(0, 4),
        trackCount: item.trackCount,
        genre: item.primaryGenreName,
        price: item.collectionPrice,
        currency: item.currency,
        explicit: item.collectionExplicitness === 'explicit',
        itunesUrl: item.collectionViewUrl,
        source: 'itunes'
      };
    } else if (entity === 'musicArtist') {
      return {
        id: item.artistId,
        type: 'artist',
        name: item.artistName,
        genre: item.primaryGenreName,
        itunesUrl: item.artistLinkUrl,
        source: 'itunes'
      };
    } else {
      return {
        id: item.trackId,
        type: 'track',
        title: item.trackName,
        artist: item.artistName,
        album: item.collectionName,
        albumId: item.collectionId,
        duration: item.trackTimeMillis ? Math.round(item.trackTimeMillis / 1000) : null,
        durationFormatted: item.trackTimeMillis ? formatDuration(item.trackTimeMillis) : null,
        preview: item.previewUrl,
        coverUrl: item.artworkUrl100,
        explicit: item.trackExplicitness === 'explicit',
        price: item.trackPrice,
        itunesUrl: item.trackViewUrl,
        source: 'itunes'
      };
    }
  });
  
  return {
    query,
    entity,
    country,
    totalResults: data.resultCount || results.length,
    count: results.length,
    results,
    source: 'itunes'
  };
}

/**
 * lib/books.js - Module Livres (Google Books + OpenLibrary)
 * 
 * Fonctions de recherche et récupération de livres via:
 * - Google Books API (nécessite clé API)
 * - OpenLibrary API (gratuit, sans clé)
 * 
 * IMPORTANT: Utilise l'état centralisé de state.js
 * 
 * @module books
 */

import { getCached, setCache, metrics } from './state.js';
import { createLogger } from './utils/logger.js';

import {
  GOOGLE_BOOKS_BASE_URL,
  GOOGLE_BOOKS_DEFAULT_MAX,
  GOOGLE_BOOKS_MAX_LIMIT,
  OPENLIBRARY_BASE_URL,
  OPENLIBRARY_DEFAULT_MAX,
  OPENLIBRARY_MAX_LIMIT,
  USER_AGENT
} from './config.js';

const logGB = createLogger('GoogleBooks');
const logOL = createLogger('OpenLibrary');

// ============================================================================
// ISBN - Fonctions utilitaires
// ============================================================================

/**
 * Vérifie si une chaîne est un ISBN (format, pas checksum)
 * @param {string} query - La chaîne à vérifier
 * @returns {boolean} - true si c'est un ISBN valide (format)
 */
export function isIsbn(query) {
  if (!query) return false;
  const cleaned = String(query).replace(/[-\s]/g, '').toUpperCase();
  // ISBN-13: 13 chiffres
  if (/^\d{13}$/.test(cleaned)) return true;
  // ISBN-10: 9 chiffres + 1 chiffre ou X
  if (/^\d{9}[\dX]$/.test(cleaned)) return true;
  return false;
}

/**
 * Valide un ISBN (checksum)
 * @param {string} isbn - L'ISBN à valider
 * @returns {boolean} - true si valide
 */
export function validateIsbn(isbn) {
  if (!isbn) return false;
  const cleaned = String(isbn).replace(/[-\s]/g, '').toUpperCase();
  
  // ISBN-13
  if (/^\d{13}$/.test(cleaned)) {
    let sum = 0;
    for (let i = 0; i < 13; i++) {
      const digit = parseInt(cleaned[i], 10);
      sum += (i % 2 === 0) ? digit : digit * 3;
    }
    return sum % 10 === 0;
  }
  
  // ISBN-10
  if (/^\d{9}[\dX]$/.test(cleaned)) {
    let sum = 0;
    for (let i = 0; i < 9; i++) {
      sum += (i + 1) * parseInt(cleaned[i], 10);
    }
    const check = sum % 11;
    const last = cleaned[9];
    if (check === 10) return last === 'X';
    return parseInt(last, 10) === check;
  }
  
  return false;
}

/**
 * Convertit ISBN-10 en ISBN-13
 * @param {string} isbn10 - ISBN-10
 * @returns {string|null} - ISBN-13 ou null si invalide
 */
export function isbn10to13(isbn10) {
  const cleaned = String(isbn10).replace(/[-\s]/g, '').toUpperCase();
  if (!/^\d{9}[\dX]$/.test(cleaned)) return null;
  
  const core = '978' + cleaned.substring(0, 9);
  let sum = 0;
  for (let i = 0; i < 12; i++) {
    const digit = parseInt(core[i], 10);
    sum += (i % 2 === 0) ? digit : digit * 3;
  }
  const mod = sum % 10;
  const check = (mod === 0) ? 0 : (10 - mod);
  return core + check;
}

// ============================================================================
// GOOGLE BOOKS - Fonctions de recherche
// ============================================================================

/**
 * Recherche sur Google Books API
 * @param {string} query - Requête de recherche (texte ou ISBN)
 * @param {string} apiKey - Clé API Google
 * @param {object} options - Options (lang, maxResults)
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchGoogleBooks(query, apiKey, options = {}) {
  const {
    lang = null,
    maxResults = GOOGLE_BOOKS_DEFAULT_MAX
  } = options;
  
  if (!apiKey) {
    throw new Error("Clé API Google Books requise");
  }
  
  // Déterminer si c'est une recherche par ISBN
  const isIsbnQuery = isIsbn(query);
  const searchType = isIsbnQuery ? 'isbn' : 'text';
  
  // Normaliser maxResults
  const limit = Math.min(Math.max(1, maxResults), GOOGLE_BOOKS_MAX_LIMIT);
  
  // Construire la clé de cache
  const cacheKey = `googlebooks_search_${searchType}_${query}_${lang}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logGB.debug(` Cache hit pour: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logGB.debug(` Recherche ${searchType}: "${query}" (lang: ${lang || 'any'}, max: ${limit})`);
  metrics.sources.googlebooks.requests++;
  
  try {
    // Construire l'URL
    let url = `${GOOGLE_BOOKS_BASE_URL}/volumes?`;
    
    if (isIsbnQuery) {
      // Recherche par ISBN
      const cleanedIsbn = query.replace(/[-\s]/g, '');
      url += `q=isbn:${encodeURIComponent(cleanedIsbn)}`;
    } else {
      // Recherche par texte
      url += `q=${encodeURIComponent(query)}`;
    }
    
    url += `&key=${encodeURIComponent(apiKey)}`;
    url += `&maxResults=${limit}`;
    
    if (lang) {
      // langRestrict utilise les codes ISO 639-1 (fr, en, es, etc.)
      const langCode = lang.substring(0, 2).toLowerCase();
      url += `&langRestrict=${langCode}`;
    }
    
    logGB.debug(` URL: ${url.replace(apiKey, '***')}`);
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      logGB.error(` Erreur HTTP ${response.status}: ${errorText}`);
      
      if (response.status === 403) {
        throw new Error("Clé API Google Books invalide ou quota dépassé");
      } else if (response.status === 429) {
        throw new Error("Trop de requêtes - rate limit atteint");
      }
      throw new Error(`Erreur Google Books API: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Parser les résultats
    const items = data.items || [];
    const totalItems = data.totalItems || 0;
    
    const books = items.map(item => {
      const vol = item.volumeInfo || {};
      const saleInfo = item.saleInfo || {};
      
      // Extraire les identifiants (ISBN-10, ISBN-13)
      const identifiers = {};
      if (vol.industryIdentifiers) {
        for (const id of vol.industryIdentifiers) {
          if (id.type === 'ISBN_10') identifiers.isbn_10 = id.identifier;
          else if (id.type === 'ISBN_13') identifiers.isbn_13 = id.identifier;
          else if (id.type === 'OTHER') identifiers.other = id.identifier;
        }
      }
      
      // Construire l'URL de la couverture en haute résolution
      let coverUrl = null;
      if (vol.imageLinks) {
        // Préférer: extraLarge > large > medium > small > thumbnail
        coverUrl = vol.imageLinks.extraLarge || 
                   vol.imageLinks.large || 
                   vol.imageLinks.medium || 
                   vol.imageLinks.small || 
                   vol.imageLinks.thumbnail;
        // Supprimer le zoom et forcer HTTPS
        if (coverUrl) {
          coverUrl = coverUrl.replace(/&edge=curl/g, '')
                            .replace(/zoom=\d+/g, 'zoom=1')
                            .replace('http://', 'https://');
        }
      }
      
      return {
        id: item.id,
        title: vol.title || null,
        originalTitle: null,
        authors: vol.authors || [],
        editors: vol.publisher ? [vol.publisher] : [],
        releaseDate: vol.publishedDate || null,
        genres: vol.categories || [],
        pages: vol.pageCount || null,
        serie: null,
        synopsis: vol.description || null,
        language: vol.language || null,
        tome: null,
        image: coverUrl ? [coverUrl] : [],
        isbn: identifiers.isbn_13 || identifiers.isbn_10 || null,
        price: null,
        previewLink: vol.previewLink || null,
        source: 'google_books'
      };
    });
    
    const result = {
      query: query,
      type: searchType,
      totalItems: totalItems,
      count: books.length,
      books: books,
      source: "google_books"
    };
    
    logGB.debug(` ✅ ${totalItems} résultats trouvés, ${books.length} retournés`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.googlebooks.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'un livre par son ID Google Books
 * @param {string} volumeId - ID du volume Google Books
 * @param {string} apiKey - Clé API Google
 * @returns {Promise<object>} - Détails du livre
 */
export async function getGoogleBookById(volumeId, apiKey) {
  if (!apiKey) {
    throw new Error("Clé API Google Books requise");
  }
  
  const cacheKey = `googlebooks_volume_${volumeId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logGB.debug(` Cache hit pour volume: ${volumeId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logGB.debug(` Récupération volume: ${volumeId}`);
  metrics.sources.googlebooks.requests++;
  
  try {
    const url = `${GOOGLE_BOOKS_BASE_URL}/volumes/${encodeURIComponent(volumeId)}?key=${encodeURIComponent(apiKey)}`;
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Volume ${volumeId} non trouvé`);
      } else if (response.status === 403) {
        throw new Error("Clé API Google Books invalide ou quota dépassé");
      }
      throw new Error(`Erreur Google Books API: ${response.status}`);
    }
    
    const item = await response.json();
    const vol = item.volumeInfo || {};
    const saleInfo = item.saleInfo || {};
    const accessInfo = item.accessInfo || {};
    
    // Extraire les identifiants
    const identifiers = {};
    if (vol.industryIdentifiers) {
      for (const id of vol.industryIdentifiers) {
        if (id.type === 'ISBN_10') identifiers.isbn_10 = id.identifier;
        else if (id.type === 'ISBN_13') identifiers.isbn_13 = id.identifier;
        else identifiers[id.type.toLowerCase()] = id.identifier;
      }
    }
    
    // Couvertures en différentes tailles
    const covers = {};
    if (vol.imageLinks) {
      for (const [size, url] of Object.entries(vol.imageLinks)) {
        covers[size] = url.replace('http://', 'https://').replace(/&edge=curl/g, '');
      }
    }
    
    // Construire le tableau d'images (différentes tailles disponibles)
    const imageArray = [];
    if (covers.extraLarge) imageArray.push(covers.extraLarge);
    if (covers.large) imageArray.push(covers.large);
    if (covers.medium) imageArray.push(covers.medium);
    if (covers.small) imageArray.push(covers.small);
    if (covers.thumbnail) imageArray.push(covers.thumbnail);
    
    const result = {
      id: item.id,
      title: vol.title || null,
      originalTitle: null,
      authors: vol.authors || [],
      editors: vol.publisher ? [vol.publisher] : [],
      releaseDate: vol.publishedDate || null,
      genres: vol.categories || [],
      pages: vol.pageCount || null,
      serie: null,
      synopsis: vol.description || null,
      language: vol.language || null,
      tome: null,
      image: imageArray,
      isbn: identifiers.isbn_13 || identifiers.isbn_10 || null,
      price: null,
      previewLink: vol.previewLink || null,
      infoLink: vol.infoLink || null,
      source: "google_books"
    };
    
    logGB.debug(` ✅ Volume récupéré: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.googlebooks.errors++;
    throw err;
  }
}

// ============================================================================
// OPENLIBRARY - Fonctions de recherche
// ============================================================================

/**
 * Recherche sur OpenLibrary API (pas de clé API requise)
 * @param {string} query - Requête de recherche (texte ou ISBN)
 * @param {object} options - Options (lang, maxResults)
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchOpenLibrary(query, options = {}) {
  const {
    lang = null,
    maxResults = OPENLIBRARY_DEFAULT_MAX
  } = options;
  
  // Déterminer si c'est une recherche par ISBN
  const isIsbnQuery = isIsbn(query);
  const searchType = isIsbnQuery ? 'isbn' : 'text';
  
  // Normaliser maxResults
  const limit = Math.min(Math.max(1, maxResults), OPENLIBRARY_MAX_LIMIT);
  
  // Construire la clé de cache
  const cacheKey = `openlibrary_search_${searchType}_${query}_${lang}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logOL.debug(` Cache hit pour: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logOL.debug(` Recherche ${searchType}: "${query}" (lang: ${lang || 'any'}, max: ${limit})`);
  metrics.sources.openlibrary.requests++;
  
  try {
    let result;
    
    if (isIsbnQuery) {
      // Recherche par ISBN - utiliser l'API bibkeys
      result = await searchOpenLibraryByIsbn(query, lang);
    } else {
      // Recherche par texte - utiliser l'API search
      result = await searchOpenLibraryByText(query, lang, limit);
    }
    
    logOL.debug(` ✅ ${result.totalItems || result.count} résultats trouvés`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.openlibrary.errors++;
    throw err;
  }
}

/**
 * Recherche OpenLibrary par ISBN
 * @param {string} isbn - ISBN
 * @param {string} lang - Langue préférée
 * @returns {Promise<object>} - Résultat
 */
export async function searchOpenLibraryByIsbn(isbn, lang = null) {
  const cleanedIsbn = isbn.replace(/[-\s]/g, '');
  
  // API bibkeys pour ISBN
  const url = `${OPENLIBRARY_BASE_URL}/api/books?bibkeys=ISBN:${encodeURIComponent(cleanedIsbn)}&format=json&jscmd=data`;
  
  logOL.debug(` URL ISBN: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur OpenLibrary API: ${response.status}`);
  }
  
  const data = await response.json();
  const key = `ISBN:${cleanedIsbn}`;
  
  if (!data[key]) {
    // ISBN non trouvé
    return {
      query: isbn,
      type: 'isbn',
      totalItems: 0,
      count: 0,
      books: [],
      source: "openlibrary"
    };
  }
  
  const book = data[key];
  
  // Parser le résultat
  const parsedBook = parseOpenLibraryBook(book, cleanedIsbn);
  
  return {
    query: isbn,
    type: 'isbn',
    totalItems: 1,
    count: 1,
    books: [parsedBook],
    source: "openlibrary"
  };
}

/**
 * Recherche OpenLibrary par texte
 * @param {string} query - Requête texte
 * @param {string} lang - Langue préférée
 * @param {number} limit - Nombre max de résultats
 * @returns {Promise<object>} - Résultats
 */
export async function searchOpenLibraryByText(query, lang = null, limit = OPENLIBRARY_DEFAULT_MAX) {
  // API search.json
  let url = `${OPENLIBRARY_BASE_URL}/search.json?q=${encodeURIComponent(query)}&limit=${limit}`;
  
  // Filtrage par langue si spécifié
  if (lang) {
    const langCode = lang.substring(0, 2).toLowerCase();
    // Mapping des codes langue vers OpenLibrary
    const langMap = { 'en': 'eng', 'fr': 'fre', 'es': 'spa', 'de': 'ger', 'it': 'ita', 'pt': 'por' };
    if (langMap[langCode]) {
      url += `&language=${langMap[langCode]}`;
    }
  }
  
  logOL.debug(` URL texte: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur OpenLibrary API: ${response.status}`);
  }
  
  const data = await response.json();
  const docs = data.docs || [];
  const numFound = data.numFound || 0;
  
  // Parser les résultats - Format Harmonisé
  const books = docs.map(doc => {
    // Titre
    const title = doc.title || doc.title_suggest || null;
    
    // Auteurs
    const authors = doc.author_name || [];
    
    // Éditeurs
    const editors = doc.publisher || [];
    
    // Date de publication
    let releaseDate = null;
    if (doc.first_publish_year) {
      releaseDate = String(doc.first_publish_year);
    } else if (doc.publish_year && doc.publish_year.length > 0) {
      releaseDate = String(doc.publish_year[0]);
    }
    
    // ISBN - prendre le premier ISBN-13 ou ISBN-10
    let isbn = null;
    if (doc.isbn && doc.isbn.length > 0) {
      for (const isb of doc.isbn) {
        const cleaned = isb.replace(/[-\s]/g, '');
        if (cleaned.length === 13) {
          isbn = cleaned;
          break;
        } else if (cleaned.length === 10 && !isbn) {
          isbn = cleaned;
        }
      }
    }
    
    // Images - construire le tableau avec différentes tailles
    const images = [];
    if (doc.cover_i) {
      images.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-L.jpg`);
      images.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-M.jpg`);
      images.push(`https://covers.openlibrary.org/b/id/${doc.cover_i}-S.jpg`);
    } else if (isbn) {
      images.push(`https://covers.openlibrary.org/b/isbn/${isbn}-L.jpg`);
      images.push(`https://covers.openlibrary.org/b/isbn/${isbn}-M.jpg`);
      images.push(`https://covers.openlibrary.org/b/isbn/${isbn}-S.jpg`);
    }
    
    // Clé OpenLibrary
    const olKey = doc.key || null;
    const olId = olKey ? olKey.replace('/works/', '') : null;
    
    // Genres/Sujets
    const genres = doc.subject ? doc.subject.slice(0, 10) : [];
    
    // Langue
    const language = doc.language ? doc.language[0] : null;
    
    // Format Harmonisé
    return {
      id: olId,
      type: "book",
      title: title,
      originalTitle: null,
      authors: authors,
      editors: editors,
      releaseDate: releaseDate,
      genres: genres,
      pages: null,
      serie: null,
      synopsis: null,
      language: language,
      tome: null,
      image: images,
      isbn: isbn,
      price: null,
      url: olId ? `https://openlibrary.org/works/${olId}` : null,
      source: "openlibrary"
    };
  });
  
  return {
    query: query,
    type: 'text',
    totalItems: numFound,
    count: books.length,
    books: books,
    source: "openlibrary"
  };
}

/**
 * Parse un livre OpenLibrary (format bibkeys/data)
 * @param {object} book - Données brutes
 * @param {string} isbn - ISBN utilisé pour la recherche
 * @returns {object} - Livre formaté
 */
export function parseOpenLibraryBook(book, isbn = null) {
  // Auteurs
  const authors = (book.authors || []).map(a => a.name).filter(Boolean);
  
  // Éditeurs
  const editors = (book.publishers || []).map(p => p.name).filter(Boolean);
  
  // Identifiants - récupérer l'ISBN
  let isbnValue = null;
  if (book.identifiers) {
    if (book.identifiers.isbn_13 && book.identifiers.isbn_13[0]) {
      isbnValue = book.identifiers.isbn_13[0];
    } else if (book.identifiers.isbn_10 && book.identifiers.isbn_10[0]) {
      isbnValue = book.identifiers.isbn_10[0];
    }
  }
  // Ajouter l'ISBN de recherche si pas déjà présent
  if (!isbnValue && isbn) {
    isbnValue = isbn.replace(/[-\s]/g, '');
  }
  
  // ID OpenLibrary
  const olId = book.identifiers?.openlibrary?.[0] || null;
  
  // Images - construire le tableau avec différentes tailles
  const images = [];
  if (book.cover) {
    if (book.cover.large) images.push(book.cover.large);
    if (book.cover.medium) images.push(book.cover.medium);
    if (book.cover.small) images.push(book.cover.small);
  }
  
  // Sujets/Genres
  const genres = (book.subjects || []).map(s => s.name).filter(Boolean).slice(0, 10);
  
  // Synopsis - peut être dans excerpts ou notes
  let synopsis = null;
  if (book.excerpts && book.excerpts.length > 0) {
    synopsis = book.excerpts[0].text || null;
  } else if (book.notes) {
    synopsis = typeof book.notes === 'string' ? book.notes : book.notes.value || null;
  }
  
  // Format Harmonisé
  return {
    id: olId,
    type: "book",
    title: book.title || null,
    originalTitle: null,
    authors: authors,
    editors: editors,
    releaseDate: book.publish_date || null,
    genres: genres,
    pages: book.number_of_pages || null,
    serie: null,
    synopsis: synopsis,
    language: null,
    tome: null,
    image: images,
    isbn: isbnValue,
    price: null,
    url: book.url || (olId ? `https://openlibrary.org/books/${olId}` : null),
    source: "openlibrary"
  };
}

/**
 * Récupère les détails d'un livre par son ID OpenLibrary (work ou edition)
 * @param {string} olId - ID OpenLibrary (ex: OL1234W pour work, OL1234M pour edition)
 * @returns {Promise<object>} - Détails du livre
 */
export async function getOpenLibraryById(olId) {
  const cacheKey = `openlibrary_${olId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logOL.debug(` Cache hit pour: ${olId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logOL.debug(` Récupération: ${olId}`);
  metrics.sources.openlibrary.requests++;
  
  try {
    // Déterminer le type (work ou edition)
    let url;
    const isWork = olId.endsWith('W');
    const isEdition = olId.endsWith('M');
    
    if (isWork) {
      url = `${OPENLIBRARY_BASE_URL}/works/${olId}.json`;
    } else if (isEdition) {
      url = `${OPENLIBRARY_BASE_URL}/books/${olId}.json`;
    } else {
      // Essayer comme work par défaut
      url = `${OPENLIBRARY_BASE_URL}/works/OL${olId}W.json`;
    }
    
    logOL.debug(` URL: ${url}`);
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Livre ${olId} non trouvé sur OpenLibrary`);
      }
      throw new Error(`Erreur OpenLibrary API: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Format work - Format Harmonisé
    if (data.type?.key === '/type/work') {
      // Construire le tableau d'images
      const images = data.covers ? data.covers.slice(0, 5).map(id => 
        `https://covers.openlibrary.org/b/id/${id}-L.jpg`
      ) : [];
      // Ajouter les tailles moyennes
      if (data.covers && data.covers[0]) {
        images.push(`https://covers.openlibrary.org/b/id/${data.covers[0]}-M.jpg`);
      }
      
      // Genres/Sujets
      const genres = data.subjects || [];
      
      // Synopsis
      const synopsis = typeof data.description === 'string' ? data.description : data.description?.value || null;
      
      // === ENRICHISSEMENT : Récupérer les auteurs ===
      let authors = [];
      if (data.authors && data.authors.length > 0) {
        const authorPromises = data.authors.slice(0, 5).map(async (authorRef) => {
          const authorKey = authorRef.author?.key || authorRef.key;
          if (!authorKey) return null;
          try {
            const authorResp = await fetch(`${OPENLIBRARY_BASE_URL}${authorKey}.json`, {
              headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
            });
            if (authorResp.ok) {
              const authorData = await authorResp.json();
              return authorData.name || authorData.personal_name || null;
            }
          } catch (e) {
            logOL.debug(` Erreur récupération auteur: ${e.message}`);
          }
          return null;
        });
        const authorResults = await Promise.all(authorPromises);
        authors = authorResults.filter(Boolean);
      }
      
      // === ENRICHISSEMENT : Récupérer la première édition pour ISBN/éditeur ===
      let isbn = null;
      let editors = [];
      let pages = null;
      let releaseDate = data.first_publish_date || null;
      let language = null;
      
      try {
        const editionsUrl = `${OPENLIBRARY_BASE_URL}/works/${olId}/editions.json?limit=5`;
        logOL.debug(` Récupération éditions: ${editionsUrl}`);
        const editionsResp = await fetch(editionsUrl, {
          headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
        });
        
        if (editionsResp.ok) {
          const editionsData = await editionsResp.json();
          const editions = editionsData.entries || [];
          
          // Chercher la meilleure édition (avec ISBN-13 de préférence)
          for (const edition of editions) {
            if (!isbn) {
              isbn = edition.isbn_13?.[0] || edition.isbn_10?.[0] || null;
            }
            if (editors.length === 0 && edition.publishers) {
              editors = edition.publishers;
            }
            if (!pages && edition.number_of_pages) {
              pages = edition.number_of_pages;
            }
            if (!language && edition.languages) {
              language = edition.languages[0]?.key?.replace('/languages/', '') || null;
            }
            // Si on a tout, arrêter
            if (isbn && editors.length > 0 && pages && language) break;
          }
        }
      } catch (e) {
        logOL.debug(` Erreur récupération éditions: ${e.message}`);
      }
      
      const result = {
        id: olId,
        type: "work",
        title: data.title || null,
        originalTitle: null,
        authors: authors,
        editors: editors,
        releaseDate: releaseDate,
        genres: genres.slice(0, 15),
        pages: pages,
        serie: null,
        synopsis: synopsis,
        language: language,
        tome: null,
        image: images,
        isbn: isbn,
        price: null,
        url: `https://openlibrary.org/works/${olId}`,
        source: "openlibrary",
        // Champs additionnels spécifiques au work
        subjectPlaces: data.subject_places || [],
        subjectTimes: data.subject_times || [],
        subjectPeople: data.subject_people || [],
        links: data.links || []
      };
      
      logOL.debug(` ✅ Work récupéré: ${result.title} (ISBN: ${isbn || 'N/A'}, Auteurs: ${authors.length})`);
      setCache(cacheKey, result);
      return result;
    }
    
    // Format edition - Format Harmonisé
    // Construire le tableau d'images
    const images = data.covers ? data.covers.slice(0, 3).map(id => 
      `https://covers.openlibrary.org/b/id/${id}-L.jpg`
    ) : [];
    if (data.covers && data.covers[0]) {
      images.push(`https://covers.openlibrary.org/b/id/${data.covers[0]}-M.jpg`);
    }
    
    // ISBN
    const isbn = data.isbn_13?.[0] || data.isbn_10?.[0] || null;
    
    // Synopsis
    const synopsis = typeof data.description === 'string' ? data.description : data.description?.value || null;
    
    // Langues
    const languages = data.languages ? data.languages.map(l => l.key?.replace('/languages/', '')) : [];
    
    // === ENRICHISSEMENT : Récupérer les auteurs depuis le work parent ===
    let authors = [];
    if (data.works && data.works[0]?.key) {
      try {
        const workResp = await fetch(`${OPENLIBRARY_BASE_URL}${data.works[0].key}.json`, {
          headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
        });
        if (workResp.ok) {
          const workData = await workResp.json();
          if (workData.authors && workData.authors.length > 0) {
            const authorPromises = workData.authors.slice(0, 5).map(async (authorRef) => {
              const authorKey = authorRef.author?.key || authorRef.key;
              if (!authorKey) return null;
              try {
                const authorResp = await fetch(`${OPENLIBRARY_BASE_URL}${authorKey}.json`, {
                  headers: { 'Accept': 'application/json', 'User-Agent': USER_AGENT }
                });
                if (authorResp.ok) {
                  const authorData = await authorResp.json();
                  return authorData.name || authorData.personal_name || null;
                }
              } catch (e) {}
              return null;
            });
            const authorResults = await Promise.all(authorPromises);
            authors = authorResults.filter(Boolean);
          }
        }
      } catch (e) {
        logOL.debug(` Erreur récupération work parent: ${e.message}`);
      }
    }
    
    const result = {
      id: olId,
      type: "edition",
      title: data.title || null,
      originalTitle: null,
      authors: authors,
      editors: data.publishers || [],
      releaseDate: data.publish_date || null,
      genres: [],
      pages: data.number_of_pages || null,
      serie: null,
      synopsis: synopsis,
      language: languages[0] || null,
      tome: null,
      image: images,
      isbn: isbn,
      price: null,
      url: `https://openlibrary.org/books/${olId}`,
      source: "openlibrary",
      // Champs additionnels spécifiques à l'édition
      physicalFormat: data.physical_format || null,
      workKey: data.works?.[0]?.key || null,
      allLanguages: languages
    };
    
    logOL.debug(` ✅ Edition récupérée: ${result.title} (ISBN: ${isbn || 'N/A'})`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.openlibrary.errors++;
    throw err;
  }
}

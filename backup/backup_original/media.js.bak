/**
 * lib/media.js - Module Films & Séries (TVDB + TMDB + IMDB)
 * 
 * Fonctions de recherche et récupération de films/séries via:
 * - TVDB API (nécessite clé API)
 * - TMDB API (nécessite clé API)
 * - IMDB API via imdbapi.dev (gratuit, sans clé)
 * 
 * IMPORTANT: Utilise l'état centralisé de state.js
 * 
 * @module media
 */

import { getCached, setCache, metrics } from './state.js';
import { createLogger } from './utils/logger.js';

import {
  TVDB_BASE_URL,
  TVDB_DEFAULT_MAX,
  TVDB_MAX_LIMIT,
  TMDB_BASE_URL,
  TMDB_IMAGE_BASE_URL,
  TMDB_DEFAULT_MAX,
  TMDB_MAX_LIMIT,
  IMDB_BASE_URL,
  IMDB_DEFAULT_MAX,
  IMDB_MAX_LIMIT,
  USER_AGENT
} from './config.js';

const logTVDB = createLogger('TVDB');
const logTMDB = createLogger('TMDB');
const logIMDB = createLogger('IMDB');

// ============================================================================
// CACHE GLOBAL POUR TOKENS TVDB
// ============================================================================

const tvdbTokenCache = {
  token: null,
  expiresAt: 0
};

// ============================================================================
// TVDB API
// ============================================================================

/**
 * Obtient un token d'accès TVDB
 * Token valide ~1 mois
 * @param {string} apiKey - Clé API TVDB
 * @returns {Promise<string>} - Token d'accès
 */
export async function getTvdbToken(apiKey) {
  if (tvdbTokenCache.token && Date.now() < tvdbTokenCache.expiresAt) {
    logTVDB.debug(` Utilisation du token en cache`);
    return tvdbTokenCache.token;
  }
  
  logTVDB.debug(` Obtention d'un nouveau token...`);
  
  try {
    const response = await fetch(`${TVDB_BASE_URL}/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({ apikey: apiKey })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur login TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    // Le token TVDB est valide ~1 mois, on le cache pour 25 jours
    tvdbTokenCache.token = data.data.token;
    tvdbTokenCache.expiresAt = Date.now() + (25 * 24 * 60 * 60 * 1000);
    
    logTVDB.debug(` ✅ Token obtenu, expire dans 25 jours`);
    return data.data.token;
    
  } catch (err) {
    logTVDB.error(` Erreur login:`, err.message);
    throw err;
  }
}

/**
 * Recherche sur TVDB (séries, films, personnes, compagnies)
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Clé API TVDB
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchTvdb(query, apiKey, options = {}) {
  const {
    max = TVDB_DEFAULT_MAX,
    type = null,      // series, movie, person, company
    lang = null,      // Code langue (fra, eng, etc.)
    year = null       // Année de sortie
  } = options;
  
  const cacheKey = `tvdb_search_${query}_${max}_${type}_${lang}_${year}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logTVDB.debug(` Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logTVDB.debug(` Recherche: "${query}" (type: ${type || 'all'}, lang: ${lang || 'default'}, max: ${max})`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    const params = new URLSearchParams({ query });
    if (type) params.append('type', type);
    if (lang) params.append('language', lang);
    if (year) params.append('year', year);
    params.append('limit', Math.min(max, TVDB_MAX_LIMIT));
    
    const url = `${TVDB_BASE_URL}/search?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.data || []).slice(0, max).map(item => ({
      id: item.tvdb_id || item.id,
      type: item.type || null,
      name: item.name || item.title,
      slug: item.slug,
      year: item.year || (item.first_air_time ? new Date(item.first_air_time).getFullYear() : null),
      overview: item.overview || null,
      overviews: item.overviews || null,
      primaryLanguage: item.primary_language || null,
      status: item.status || null,
      network: item.network || null,
      country: item.country || null,
      thumbnail: item.thumbnail || item.image_url || null,
      image: item.image || item.image_url || null,
      aliases: item.aliases || [],
      objectID: item.objectID,
      url: item.type === 'series' 
        ? `https://thetvdb.com/series/${item.slug}`
        : item.type === 'movie'
        ? `https://thetvdb.com/movies/${item.slug}`
        : `https://thetvdb.com/search?query=${encodeURIComponent(item.name || query)}`,
      source: "tvdb"
    }));
    
    const result = {
      query,
      type: type || 'all',
      total: results.length,
      results,
      source: "tvdb"
    };
    
    logTVDB.debug(` ✅ ${results.length} résultat(s) trouvé(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'une série TVDB par ID
 * @param {string|number} id - ID de la série
 * @param {string} apiKey - Clé API TVDB
 * @param {string} lang - Code langue (fra, eng, etc.)
 * @returns {Promise<object>} - Détails de la série
 */
export async function getTvdbSeriesById(id, apiKey, lang = null) {
  const cacheKey = `tvdb_series_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logTVDB.debug(` Cache hit: series ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logTVDB.debug(` Récupération série: ${id}`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    const url = `${TVDB_BASE_URL}/series/${id}/extended`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Série TVDB ${id} non trouvée`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const series = data.data;
    
    // Récupère les traductions si langue spécifiée
    let translations = null;
    if (lang) {
      try {
        const transResponse = await fetch(`${TVDB_BASE_URL}/series/${id}/translations/${lang}`, {
          headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json' }
        });
        if (transResponse.ok) {
          const transData = await transResponse.json();
          translations = transData.data;
        }
      } catch (e) {
        logTVDB.debug(` Pas de traduction ${lang} pour série ${id}`);
      }
    }
    
    const result = {
      id: series.id,
      type: 'series',
      name: translations?.name || series.name,
      originalName: series.name,
      slug: series.slug,
      overview: translations?.overview || series.overview,
      firstAired: series.firstAired,
      lastAired: series.lastAired,
      nextAired: series.nextAired,
      status: series.status?.name || null,
      year: series.year,
      averageRuntime: series.averageRuntime,
      score: series.score,
      originalCountry: series.originalCountry,
      originalLanguage: series.originalLanguage,
      defaultSeasonType: series.defaultSeasonType,
      isOrderRandomized: series.isOrderRandomized,
      lastUpdated: series.lastUpdated,
      
      image: series.image,
      artworks: series.artworks?.slice(0, 20).map(a => ({
        id: a.id,
        type: a.type,
        image: a.image,
        thumbnail: a.thumbnail,
        language: a.language,
        score: a.score
      })) || [],
      
      genres: series.genres?.map(g => ({
        id: g.id,
        name: g.name,
        slug: g.slug
      })) || [],
      
      characters: series.characters?.slice(0, 30).map(c => ({
        id: c.id,
        name: c.name,
        peopleId: c.peopleId,
        personName: c.personName,
        image: c.image,
        type: c.type,
        sort: c.sort
      })) || [],
      
      seasons: series.seasons?.map(s => ({
        id: s.id,
        number: s.number,
        name: s.name,
        type: s.type?.name,
        image: s.image
      })) || [],
      
      companies: series.companies?.map(c => ({
        id: c.id,
        name: c.name,
        slug: c.slug,
        country: c.country,
        activeDate: c.activeDate,
        companyType: c.companyType?.name
      })) || [],
      
      remoteIds: series.remoteIds || [],
      trailers: series.trailers?.map(t => ({
        id: t.id,
        name: t.name,
        url: t.url,
        runtime: t.runtime,
        language: t.language
      })) || [],
      
      lists: series.lists?.slice(0, 10).map(l => ({
        id: l.id,
        name: l.name,
        overview: l.overview,
        url: l.url
      })) || [],
      
      contentRatings: series.contentRatings || [],
      
      url: `https://thetvdb.com/series/${series.slug}`,
      source: "tvdb"
    };
    
    logTVDB.debug(` ✅ Série récupérée: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'un film TVDB par ID
 * @param {string|number} id - ID du film
 * @param {string} apiKey - Clé API TVDB
 * @param {string} lang - Code langue (fra, eng, etc.)
 * @returns {Promise<object>} - Détails du film
 */
export async function getTvdbMovieById(id, apiKey, lang = null) {
  const cacheKey = `tvdb_movie_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logTVDB.debug(` Cache hit: movie ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logTVDB.debug(` Récupération film: ${id}`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    const url = `${TVDB_BASE_URL}/movies/${id}/extended`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Film TVDB ${id} non trouvé`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const movie = data.data;
    
    // Récupère les traductions si langue spécifiée
    let translations = null;
    if (lang) {
      try {
        const transResponse = await fetch(`${TVDB_BASE_URL}/movies/${id}/translations/${lang}`, {
          headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json' }
        });
        if (transResponse.ok) {
          const transData = await transResponse.json();
          translations = transData.data;
        }
      } catch (e) {
        logTVDB.debug(` Pas de traduction ${lang} pour film ${id}`);
      }
    }
    
    const result = {
      id: movie.id,
      type: 'movie',
      name: translations?.name || movie.name,
      originalName: movie.name,
      slug: movie.slug,
      overview: translations?.overview || movie.overview,
      year: movie.year,
      runtime: movie.runtime,
      score: movie.score,
      status: movie.status?.name || null,
      originalCountry: movie.originalCountry,
      originalLanguage: movie.originalLanguage,
      lastUpdated: movie.lastUpdated,
      
      releases: movie.releases?.map(r => ({
        country: r.country,
        date: r.date,
        detail: r.detail
      })) || [],
      
      image: movie.image,
      artworks: movie.artworks?.slice(0, 20).map(a => ({
        id: a.id,
        type: a.type,
        image: a.image,
        thumbnail: a.thumbnail,
        language: a.language,
        score: a.score
      })) || [],
      
      genres: movie.genres?.map(g => ({
        id: g.id,
        name: g.name,
        slug: g.slug
      })) || [],
      
      characters: movie.characters?.slice(0, 30).map(c => ({
        id: c.id,
        name: c.name,
        peopleId: c.peopleId,
        personName: c.personName,
        image: c.image,
        type: c.type
      })) || [],
      
      companies: movie.companies?.map(c => ({
        id: c.id,
        name: c.name,
        slug: c.slug,
        country: c.country,
        companyType: c.companyType?.name
      })) || [],
      
      boxOffice: movie.boxOffice,
      boxOfficeUS: movie.boxOfficeUS,
      budget: movie.budget,
      
      trailers: movie.trailers?.map(t => ({
        id: t.id,
        name: t.name,
        url: t.url,
        runtime: t.runtime,
        language: t.language
      })) || [],
      
      remoteIds: movie.remoteIds || [],
      contentRatings: movie.contentRatings || [],
      
      url: `https://thetvdb.com/movies/${movie.slug}`,
      source: "tvdb"
    };
    
    logTVDB.debug(` ✅ Film récupéré: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

// ============================================================================
// TMDB API
// ============================================================================

/**
 * Recherche multi sur TMDB (films, séries, personnes)
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Clé API TMDB
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchTmdb(query, apiKey, options = {}) {
  const {
    max = TMDB_DEFAULT_MAX,
    type = null,      // movie, tv, person, multi (défaut)
    lang = 'fr-FR',   // Code langue ISO 639-1 + pays
    page = 1,
    year = null,
    includeAdult = false
  } = options;
  
  const searchType = type || 'multi';
  const cacheKey = `tmdb_search_${query}_${searchType}_${max}_${lang}_${page}_${year}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logTMDB.debug(` Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logTMDB.debug(` Recherche: "${query}" (type: ${searchType}, lang: ${lang}, page: ${page})`);
  metrics.sources.tmdb.requests++;
  
  try {
    const params = new URLSearchParams({
      api_key: apiKey,
      query: query,
      language: lang,
      page: page,
      include_adult: includeAdult
    });
    
    if (year) {
      if (searchType === 'movie') {
        params.append('primary_release_year', year);
      } else if (searchType === 'tv') {
        params.append('first_air_date_year', year);
      } else if (searchType === 'multi') {
        params.append('year', year);
      }
    }
    
    const url = `${TMDB_BASE_URL}/search/${searchType}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.results || []).slice(0, max).map(item => {
      const mediaType = item.media_type || searchType;
      const isMovie = mediaType === 'movie';
      const isTv = mediaType === 'tv';
      const isPerson = mediaType === 'person';
      
      return {
        id: item.id,
        mediaType: mediaType,
        title: item.title || item.name,
        originalTitle: item.original_title || item.original_name,
        overview: item.overview || null,
        releaseDate: item.release_date || item.first_air_date || null,
        year: (item.release_date || item.first_air_date) 
          ? new Date(item.release_date || item.first_air_date).getFullYear() 
          : null,
        popularity: item.popularity,
        voteAverage: item.vote_average,
        voteCount: item.vote_count,
        originalLanguage: item.original_language,
        genreIds: item.genre_ids || [],
        adult: item.adult || false,
        
        poster: item.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${item.poster_path}` : null,
        posterSmall: item.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${item.poster_path}` : null,
        backdrop: item.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${item.backdrop_path}` : null,
        
        profilePath: isPerson && item.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${item.profile_path}` : null,
        knownFor: isPerson ? (item.known_for || []).map(k => ({
          id: k.id,
          mediaType: k.media_type,
          title: k.title || k.name,
          poster: k.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${k.poster_path}` : null
        })) : null,
        knownForDepartment: item.known_for_department || null,
        
        originCountry: isTv ? item.origin_country : null,
        
        url: isMovie 
          ? `https://www.themoviedb.org/movie/${item.id}`
          : isTv 
          ? `https://www.themoviedb.org/tv/${item.id}`
          : `https://www.themoviedb.org/person/${item.id}`,
        source: "tmdb"
      };
    });
    
    const result = {
      query,
      searchType,
      page: data.page,
      totalPages: data.total_pages,
      totalResults: data.total_results,
      resultsOnPage: results.length,
      results,
      source: "tmdb"
    };
    
    logTMDB.debug(` ✅ ${results.length} résultat(s) sur ${data.total_results} total`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'un film TMDB par ID
 * @param {string|number} id - ID du film
 * @param {string} apiKey - Clé API TMDB
 * @param {string} lang - Code langue (fr-FR, en-US, etc.)
 * @returns {Promise<object>} - Détails du film
 */
export async function getTmdbMovieById(id, apiKey, lang = 'fr-FR') {
  const cacheKey = `tmdb_movie_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logTMDB.debug(` Cache hit: movie ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logTMDB.debug(` Récupération film: ${id}`);
  metrics.sources.tmdb.requests++;
  
  try {
    const params = new URLSearchParams({
      api_key: apiKey,
      language: lang,
      append_to_response: 'credits,videos,keywords,recommendations,similar,external_ids,release_dates'
    });
    
    const url = `${TMDB_BASE_URL}/movie/${id}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Film TMDB ${id} non trouvé`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const movie = await response.json();
    
    const result = {
      id: movie.id,
      type: 'movie',
      imdbId: movie.imdb_id,
      title: movie.title,
      originalTitle: movie.original_title,
      tagline: movie.tagline,
      overview: movie.overview,
      releaseDate: movie.release_date,
      year: movie.release_date ? new Date(movie.release_date).getFullYear() : null,
      runtime: movie.runtime,
      status: movie.status,
      adult: movie.adult,
      video: movie.video,
      
      popularity: movie.popularity,
      voteAverage: movie.vote_average,
      voteCount: movie.vote_count,
      
      originalLanguage: movie.original_language,
      spokenLanguages: movie.spoken_languages?.map(l => ({
        code: l.iso_639_1,
        name: l.name,
        englishName: l.english_name
      })) || [],
      productionCountries: movie.production_countries?.map(c => ({
        code: c.iso_3166_1,
        name: c.name
      })) || [],
      
      budget: movie.budget,
      revenue: movie.revenue,
      
      poster: movie.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${movie.poster_path}` : null,
      posterOriginal: movie.poster_path ? `${TMDB_IMAGE_BASE_URL}/original${movie.poster_path}` : null,
      backdrop: movie.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${movie.backdrop_path}` : null,
      backdropOriginal: movie.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/original${movie.backdrop_path}` : null,
      
      genres: movie.genres?.map(g => ({ id: g.id, name: g.name })) || [],
      
      productionCompanies: movie.production_companies?.map(c => ({
        id: c.id,
        name: c.name,
        logo: c.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.logo_path}` : null,
        country: c.origin_country
      })) || [],
      
      belongsToCollection: movie.belongs_to_collection ? {
        id: movie.belongs_to_collection.id,
        name: movie.belongs_to_collection.name,
        poster: movie.belongs_to_collection.poster_path 
          ? `${TMDB_IMAGE_BASE_URL}/w500${movie.belongs_to_collection.poster_path}` : null,
        backdrop: movie.belongs_to_collection.backdrop_path
          ? `${TMDB_IMAGE_BASE_URL}/w1280${movie.belongs_to_collection.backdrop_path}` : null
      } : null,
      
      cast: movie.credits?.cast?.slice(0, 20).map(c => ({
        id: c.id,
        name: c.name,
        character: c.character,
        order: c.order,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      crew: movie.credits?.crew?.filter(c => 
        ['Director', 'Writer', 'Screenplay', 'Producer', 'Executive Producer', 'Original Music Composer'].includes(c.job)
      ).map(c => ({
        id: c.id,
        name: c.name,
        job: c.job,
        department: c.department,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      videos: movie.videos?.results?.filter(v => v.site === 'YouTube').map(v => ({
        id: v.id,
        key: v.key,
        name: v.name,
        type: v.type,
        official: v.official,
        url: `https://www.youtube.com/watch?v=${v.key}`
      })) || [],
      
      keywords: movie.keywords?.keywords?.map(k => k.name) || [],
      
      externalIds: {
        imdb: movie.external_ids?.imdb_id,
        facebook: movie.external_ids?.facebook_id,
        instagram: movie.external_ids?.instagram_id,
        twitter: movie.external_ids?.twitter_id,
        wikidata: movie.external_ids?.wikidata_id
      },
      
      certifications: movie.release_dates?.results?.map(r => ({
        country: r.iso_3166_1,
        certification: r.release_dates?.[0]?.certification || null,
        releaseDate: r.release_dates?.[0]?.release_date || null
      })).filter(c => c.certification) || [],
      
      recommendations: movie.recommendations?.results?.slice(0, 10).map(r => ({
        id: r.id,
        title: r.title,
        releaseDate: r.release_date,
        voteAverage: r.vote_average,
        poster: r.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${r.poster_path}` : null
      })) || [],
      
      similar: movie.similar?.results?.slice(0, 10).map(s => ({
        id: s.id,
        title: s.title,
        releaseDate: s.release_date,
        voteAverage: s.vote_average,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null
      })) || [],
      
      homepage: movie.homepage || null,
      url: `https://www.themoviedb.org/movie/${movie.id}`,
      source: "tmdb"
    };
    
    logTMDB.debug(` ✅ Film récupéré: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'une série TV TMDB par ID
 * @param {string|number} id - ID de la série
 * @param {string} apiKey - Clé API TMDB
 * @param {string} lang - Code langue (fr-FR, en-US, etc.)
 * @returns {Promise<object>} - Détails de la série
 */
export async function getTmdbTvById(id, apiKey, lang = 'fr-FR') {
  const cacheKey = `tmdb_tv_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logTMDB.debug(` Cache hit: tv ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logTMDB.debug(` Récupération série: ${id}`);
  metrics.sources.tmdb.requests++;
  
  try {
    const params = new URLSearchParams({
      api_key: apiKey,
      language: lang,
      append_to_response: 'credits,videos,keywords,recommendations,similar,external_ids,content_ratings'
    });
    
    const url = `${TMDB_BASE_URL}/tv/${id}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Série TMDB ${id} non trouvée`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const tv = await response.json();
    
    const result = {
      id: tv.id,
      type: 'tv',
      name: tv.name,
      originalName: tv.original_name,
      tagline: tv.tagline,
      overview: tv.overview,
      firstAirDate: tv.first_air_date,
      lastAirDate: tv.last_air_date,
      year: tv.first_air_date ? new Date(tv.first_air_date).getFullYear() : null,
      status: tv.status,
      tvType: tv.type,
      inProduction: tv.in_production,
      adult: tv.adult,
      
      numberOfSeasons: tv.number_of_seasons,
      numberOfEpisodes: tv.number_of_episodes,
      episodeRunTime: tv.episode_run_time || [],
      
      lastEpisodeToAir: tv.last_episode_to_air ? {
        id: tv.last_episode_to_air.id,
        name: tv.last_episode_to_air.name,
        overview: tv.last_episode_to_air.overview,
        airDate: tv.last_episode_to_air.air_date,
        seasonNumber: tv.last_episode_to_air.season_number,
        episodeNumber: tv.last_episode_to_air.episode_number,
        voteAverage: tv.last_episode_to_air.vote_average
      } : null,
      nextEpisodeToAir: tv.next_episode_to_air ? {
        id: tv.next_episode_to_air.id,
        name: tv.next_episode_to_air.name,
        overview: tv.next_episode_to_air.overview,
        airDate: tv.next_episode_to_air.air_date,
        seasonNumber: tv.next_episode_to_air.season_number,
        episodeNumber: tv.next_episode_to_air.episode_number
      } : null,
      
      popularity: tv.popularity,
      voteAverage: tv.vote_average,
      voteCount: tv.vote_count,
      
      originalLanguage: tv.original_language,
      languages: tv.languages || [],
      originCountry: tv.origin_country || [],
      spokenLanguages: tv.spoken_languages?.map(l => ({
        code: l.iso_639_1,
        name: l.name,
        englishName: l.english_name
      })) || [],
      productionCountries: tv.production_countries?.map(c => ({
        code: c.iso_3166_1,
        name: c.name
      })) || [],
      
      poster: tv.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${tv.poster_path}` : null,
      posterOriginal: tv.poster_path ? `${TMDB_IMAGE_BASE_URL}/original${tv.poster_path}` : null,
      backdrop: tv.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${tv.backdrop_path}` : null,
      backdropOriginal: tv.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/original${tv.backdrop_path}` : null,
      
      genres: tv.genres?.map(g => ({ id: g.id, name: g.name })) || [],
      
      networks: tv.networks?.map(n => ({
        id: n.id,
        name: n.name,
        logo: n.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${n.logo_path}` : null,
        country: n.origin_country
      })) || [],
      
      productionCompanies: tv.production_companies?.map(c => ({
        id: c.id,
        name: c.name,
        logo: c.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.logo_path}` : null,
        country: c.origin_country
      })) || [],
      
      createdBy: tv.created_by?.map(c => ({
        id: c.id,
        name: c.name,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      seasons: tv.seasons?.map(s => ({
        id: s.id,
        name: s.name,
        overview: s.overview,
        seasonNumber: s.season_number,
        episodeCount: s.episode_count,
        airDate: s.air_date,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null,
        voteAverage: s.vote_average
      })) || [],
      
      cast: tv.credits?.cast?.slice(0, 20).map(c => ({
        id: c.id,
        name: c.name,
        character: c.character,
        order: c.order,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      crew: tv.credits?.crew?.filter(c => 
        ['Executive Producer', 'Creator', 'Original Music Composer', 'Director of Photography'].includes(c.job)
      ).map(c => ({
        id: c.id,
        name: c.name,
        job: c.job,
        department: c.department,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      videos: tv.videos?.results?.filter(v => v.site === 'YouTube').map(v => ({
        id: v.id,
        key: v.key,
        name: v.name,
        type: v.type,
        official: v.official,
        url: `https://www.youtube.com/watch?v=${v.key}`
      })) || [],
      
      keywords: tv.keywords?.results?.map(k => k.name) || [],
      
      externalIds: {
        imdb: tv.external_ids?.imdb_id,
        tvdb: tv.external_ids?.tvdb_id,
        facebook: tv.external_ids?.facebook_id,
        instagram: tv.external_ids?.instagram_id,
        twitter: tv.external_ids?.twitter_id,
        wikidata: tv.external_ids?.wikidata_id
      },
      
      contentRatings: tv.content_ratings?.results?.map(r => ({
        country: r.iso_3166_1,
        rating: r.rating
      })) || [],
      
      recommendations: tv.recommendations?.results?.slice(0, 10).map(r => ({
        id: r.id,
        name: r.name,
        firstAirDate: r.first_air_date,
        voteAverage: r.vote_average,
        poster: r.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${r.poster_path}` : null
      })) || [],
      
      similar: tv.similar?.results?.slice(0, 10).map(s => ({
        id: s.id,
        name: s.name,
        firstAirDate: s.first_air_date,
        voteAverage: s.vote_average,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null
      })) || [],
      
      homepage: tv.homepage || null,
      url: `https://www.themoviedb.org/tv/${tv.id}`,
      source: "tmdb"
    };
    
    logTMDB.debug(` ✅ Série récupérée: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

// ============================================================================
// IMDB API (via imdbapi.dev - NO API KEY NEEDED)
// ============================================================================

/**
 * Recherche de titres sur IMDB via imdbapi.dev
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchImdb(query, options = {}) {
  const {
    max = IMDB_DEFAULT_MAX
  } = options;
  
  const limit = Math.min(max, IMDB_MAX_LIMIT);
  
  const cacheKey = `imdb_search_${query}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logIMDB.debug(` Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logIMDB.debug(` Recherche: "${query}" (limit: ${limit})`);
  metrics.sources.imdb.requests++;
  
  try {
    const params = new URLSearchParams({
      query: query,
      limit: limit
    });
    
    const url = `${IMDB_BASE_URL}/search/titles?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.titles || []).map(item => ({
      id: item.id,
      type: item.type,
      title: item.primaryTitle,
      originalTitle: item.originalTitle,
      year: item.startYear,
      endYear: item.endYear || null,
      runtimeMinutes: item.runtimeSeconds ? Math.round(item.runtimeSeconds / 60) : null,
      genres: item.genres || [],
      rating: item.rating ? {
        average: item.rating.aggregateRating,
        votes: item.rating.voteCount
      } : null,
      poster: item.primaryImage?.url || null,
      posterWidth: item.primaryImage?.width || null,
      posterHeight: item.primaryImage?.height || null,
      isAdult: item.isAdult || false,
      url: `https://www.imdb.com/title/${item.id}/`,
      source: "imdb"
    }));
    
    const result = {
      query,
      resultsCount: results.length,
      results,
      source: "imdb"
    };
    
    logIMDB.debug(` ✅ ${results.length} résultat(s) trouvé(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'un titre IMDB par ID
 * @param {string} titleId - ID IMDB (format: tt1234567)
 * @returns {Promise<object>} - Détails du titre
 */
export async function getImdbTitleById(titleId) {
  const cacheKey = `imdb_title_${titleId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logIMDB.debug(` Cache hit: title ${titleId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logIMDB.debug(` Récupération titre: ${titleId}`);
  metrics.sources.imdb.requests++;
  
  try {
    const url = `${IMDB_BASE_URL}/titles/${titleId}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404 || response.status === 5) {
        throw new Error(`Titre IMDB ${titleId} non trouvé`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const title = await response.json();
    
    if (title.code === 5 || title.message === 'Not Found') {
      throw new Error(`Titre IMDB ${titleId} non trouvé`);
    }
    
    const result = {
      id: title.id,
      type: title.type,
      title: title.primaryTitle,
      originalTitle: title.originalTitle || title.primaryTitle,
      year: title.startYear,
      endYear: title.endYear || null,
      runtimeMinutes: title.runtimeSeconds ? Math.round(title.runtimeSeconds / 60) : null,
      isAdult: title.isAdult || false,
      
      rating: title.rating ? {
        average: title.rating.aggregateRating,
        votes: title.rating.voteCount
      } : null,
      
      metacritic: title.metacritic ? {
        score: title.metacritic.score,
        reviewCount: title.metacritic.reviewCount
      } : null,
      
      plot: title.plot || null,
      genres: title.genres || [],
      
      poster: title.primaryImage?.url || null,
      posterWidth: title.primaryImage?.width || null,
      posterHeight: title.primaryImage?.height || null,
      
      directors: (title.directors || []).map(d => ({
        id: d.id,
        name: d.displayName,
        alternativeNames: d.alternativeNames || [],
        image: d.primaryImage?.url || null,
        professions: d.primaryProfessions || []
      })),
      
      writers: (title.writers || []).map(w => ({
        id: w.id,
        name: w.displayName,
        alternativeNames: w.alternativeNames || [],
        image: w.primaryImage?.url || null,
        professions: w.primaryProfessions || []
      })),
      
      stars: (title.stars || []).map(s => ({
        id: s.id,
        name: s.displayName,
        alternativeNames: s.alternativeNames || [],
        image: s.primaryImage?.url || null,
        professions: s.primaryProfessions || []
      })),
      
      originCountries: (title.originCountries || []).map(c => ({
        code: c.code,
        name: c.name
      })),
      
      spokenLanguages: (title.spokenLanguages || []).map(l => ({
        code: l.code,
        name: l.name
      })),
      
      interests: (title.interests || []).filter(i => !i.isSubgenre).map(i => ({
        id: i.id,
        name: i.name
      })),
      subgenres: (title.interests || []).filter(i => i.isSubgenre).map(i => ({
        id: i.id,
        name: i.name
      })),
      
      url: `https://www.imdb.com/title/${title.id}/`,
      source: "imdb"
    };
    
    logIMDB.debug(` ✅ Titre récupéré: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

/**
 * Liste/Browse des titres IMDB avec filtres
 * @param {object} options - Options de filtrage
 * @returns {Promise<object>} - Liste de titres
 */
export async function browseImdbTitles(options = {}) {
  const {
    types = [],
    genres = [],
    startYear = null,
    endYear = null,
    minRating = null,
    maxRating = null,
    sortBy = 'SORT_BY_POPULARITY',
    sortOrder = 'DESC',
    pageToken = null,
    limit = IMDB_DEFAULT_MAX
  } = options;
  
  const cacheKey = `imdb_browse_${types.join(',')}_${genres.join(',')}_${startYear}_${endYear}_${minRating}_${maxRating}_${sortBy}_${sortOrder}_${pageToken}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logIMDB.debug(` Cache hit: browse`);
    metrics.requests.cached++;
    return cached;
  }
  
  logIMDB.debug(` Browse titles: types=${types.join(',')}, genres=${genres.join(',')}, years=${startYear}-${endYear}`);
  metrics.sources.imdb.requests++;
  
  try {
    const params = new URLSearchParams();
    
    if (types.length > 0) {
      types.forEach(t => params.append('types', t));
    }
    
    if (genres.length > 0) {
      genres.forEach(g => params.append('genres', g));
    }
    
    if (startYear) params.append('startYear', startYear);
    if (endYear) params.append('endYear', endYear);
    
    if (minRating !== null) params.append('minAggregateRating', minRating);
    if (maxRating !== null) params.append('maxAggregateRating', maxRating);
    
    params.append('sortBy', sortBy);
    params.append('sortOrder', sortOrder);
    
    if (pageToken) params.append('pageToken', pageToken);
    
    const url = `${IMDB_BASE_URL}/titles?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const titles = (data.titles || []).slice(0, limit);
    
    const results = titles.map(item => ({
      id: item.id,
      type: item.type,
      title: item.primaryTitle,
      originalTitle: item.originalTitle,
      year: item.startYear,
      endYear: item.endYear || null,
      runtimeMinutes: item.runtimeSeconds ? Math.round(item.runtimeSeconds / 60) : null,
      genres: item.genres || [],
      rating: item.rating ? {
        average: item.rating.aggregateRating,
        votes: item.rating.voteCount
      } : null,
      plot: item.plot || null,
      poster: item.primaryImage?.url || null,
      isAdult: item.isAdult || false,
      url: `https://www.imdb.com/title/${item.id}/`,
      source: "imdb"
    }));
    
    const result = {
      filters: {
        types: types.length > 0 ? types : 'all',
        genres: genres.length > 0 ? genres : 'all',
        years: {
          start: startYear || 'any',
          end: endYear || 'any'
        },
        rating: {
          min: minRating || 'any',
          max: maxRating || 'any'
        },
        sortBy,
        sortOrder
      },
      totalCount: data.totalCount || null,
      resultsCount: results.length,
      nextPageToken: data.nextPageToken || null,
      results,
      source: "imdb"
    };
    
    logIMDB.debug(` ✅ ${results.length} titre(s) trouvé(s) sur ${data.totalCount || '?'} total`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

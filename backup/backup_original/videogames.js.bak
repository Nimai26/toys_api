/**
 * lib/videogames.js - Module Jeux Vidéo (RAWG + IGDB + JVC)
 * 
 * Fonctions de recherche et récupération de jeux vidéo via:
 * - RAWG API (nécessite clé API)
 * - IGDB/Twitch API (nécessite clientId:clientSecret)
 * - JeuxVideo.com (scraping via FlareSolverr)
 * 
 * IMPORTANT: Utilise l'état centralisé de state.js
 * 
 * @module videogames
 */

import {
  getCached,
  setCache,
  metrics
} from './state.js';

import { createLogger } from './utils/logger.js';
import { decodeHtmlEntities } from './utils.js';

import {
  RAWG_BASE_URL,
  RAWG_DEFAULT_MAX,
  RAWG_MAX_LIMIT,
  IGDB_BASE_URL,
  IGDB_AUTH_URL,
  IGDB_DEFAULT_MAX,
  IGDB_MAX_LIMIT,
  JVC_BASE_URL,
  JVC_DEFAULT_MAX,
  FSR_BASE,
  USER_AGENT
} from './config.js';

import {
  ensureFsrSession,
  fsrRequest,
  getFsrSessionId
} from './flaresolverr.js';

const logRAWG = createLogger('RAWG');
const logIGDB = createLogger('IGDB');
const logJVC = createLogger('JVC');

// ============================================================================
// CACHE GLOBAL POUR TOKENS IGDB
// ============================================================================

const igdbTokenCache = {
  token: null,
  expiresAt: 0
};

// ============================================================================
// FONCTIONS UTILITAIRES JEUX VIDEO
// ============================================================================

/**
 * Parse les credentials IGDB depuis la clé API
 * Format attendu: "clientId:clientSecret"
 * @param {string} apiKey - Clé au format clientId:clientSecret
 * @returns {{clientId: string, clientSecret: string}}
 */
export function parseIgdbCredentials(apiKey) {
  const parts = apiKey.split(':');
  if (parts.length !== 2) {
    throw new Error("Format de clé IGDB invalide. Attendu: 'clientId:clientSecret'");
  }
  return {
    clientId: parts[0].trim(),
    clientSecret: parts[1].trim()
  };
}

/**
 * Convertit le code de catégorie de site web IGDB en nom lisible
 * @param {number} category - Code de catégorie IGDB
 * @returns {string} - Nom de la catégorie
 */
export function getIgdbWebsiteCategory(category) {
  const categories = {
    1: 'official', 2: 'wikia', 3: 'wikipedia', 4: 'facebook',
    5: 'twitter', 6: 'twitch', 8: 'instagram', 9: 'youtube',
    10: 'iphone', 11: 'ipad', 12: 'android', 13: 'steam',
    14: 'reddit', 15: 'itch', 16: 'epicgames', 17: 'gog', 18: 'discord'
  };
  return categories[category] || 'other';
}

/**
 * Convertit les codes IGDB age_rating en valeurs lisibles
 * @param {number} organization - 1=ESRB, 2=PEGI, 3=CERO, 4=USK, 5=GRAC, 6=CLASS_IND, 7=ACB
 * @param {number} ratingCategory - Code du rating (varie selon organization)
 * @returns {{system: string, rating: string, minAge: number|null}}
 */
export function parseIgdbAgeRating(organization, ratingCategory) {
  const systems = {
    1: 'ESRB',
    2: 'PEGI',
    3: 'CERO',
    4: 'USK',
    5: 'GRAC',
    6: 'CLASS_IND',
    7: 'ACB'
  };
  
  const pegiRatings = {
    1: { rating: 'PEGI 3', minAge: 3 },
    2: { rating: 'PEGI 7', minAge: 7 },
    3: { rating: 'PEGI 12', minAge: 12 },
    4: { rating: 'PEGI 16', minAge: 16 },
    5: { rating: 'PEGI 18', minAge: 18 },
    8: { rating: 'PEGI 3', minAge: 3 },
    9: { rating: 'PEGI 7', minAge: 7 },
    10: { rating: 'PEGI 12', minAge: 12 },
    11: { rating: 'PEGI 16', minAge: 16 },
    12: { rating: 'PEGI 18', minAge: 18 }
  };
  
  const esrbRatings = {
    1: { rating: 'RP', minAge: null },
    2: { rating: 'EC', minAge: 3 },
    3: { rating: 'E', minAge: 6 },
    4: { rating: 'E10+', minAge: 10 },
    5: { rating: 'T', minAge: 13 },
    6: { rating: 'M', minAge: 17 },
    7: { rating: 'AO', minAge: 18 }
  };
  
  const ceroRatings = {
    1: { rating: 'CERO A', minAge: 0 },
    2: { rating: 'CERO B', minAge: 12 },
    3: { rating: 'CERO C', minAge: 15 },
    4: { rating: 'CERO D', minAge: 17 },
    5: { rating: 'CERO Z', minAge: 18 },
    13: { rating: 'CERO A', minAge: 0 },
    14: { rating: 'CERO B', minAge: 12 },
    15: { rating: 'CERO C', minAge: 15 },
    16: { rating: 'CERO D', minAge: 17 },
    17: { rating: 'CERO Z', minAge: 18 }
  };
  
  const uskRatings = {
    1: { rating: 'USK 0', minAge: 0 },
    2: { rating: 'USK 6', minAge: 6 },
    3: { rating: 'USK 12', minAge: 12 },
    4: { rating: 'USK 16', minAge: 16 },
    5: { rating: 'USK 18', minAge: 18 },
    18: { rating: 'USK 0', minAge: 0 },
    19: { rating: 'USK 6', minAge: 6 },
    20: { rating: 'USK 12', minAge: 12 },
    21: { rating: 'USK 16', minAge: 16 },
    22: { rating: 'USK 18', minAge: 18 }
  };
  
  const acbRatings = {
    1: { rating: 'G', minAge: 0 },
    2: { rating: 'PG', minAge: 0 },
    3: { rating: 'M', minAge: 15 },
    4: { rating: 'MA 15+', minAge: 15 },
    5: { rating: 'R 18+', minAge: 18 },
    6: { rating: 'RC', minAge: null }
  };
  
  const system = systems[organization] || `Unknown (${organization})`;
  let ratingInfo = { rating: `Unknown (${ratingCategory})`, minAge: null };
  
  switch (organization) {
    case 1: ratingInfo = esrbRatings[ratingCategory] || ratingInfo; break;
    case 2: ratingInfo = pegiRatings[ratingCategory] || ratingInfo; break;
    case 3: ratingInfo = ceroRatings[ratingCategory] || ratingInfo; break;
    case 4: ratingInfo = uskRatings[ratingCategory] || ratingInfo; break;
    case 7: ratingInfo = acbRatings[ratingCategory] || ratingInfo; break;
    default: break;
  }
  
  return {
    system,
    rating: ratingInfo.rating,
    minAge: ratingInfo.minAge
  };
}

/**
 * Détermine si un jeu est multijoueur à partir des modes de jeu
 * @param {string[]} gameModes - Liste des modes
 * @returns {{isMultiplayer: boolean, modes: string[]}}
 */
export function detectMultiplayer(gameModes) {
  const multiModes = ['Multiplayer', 'Co-operative', 'Split screen', 'Massively Multiplayer Online (MMO)', 'Battle Royale'];
  const hasMulti = gameModes.some(mode => multiModes.includes(mode));
  return {
    isMultiplayer: hasMulti,
    modes: gameModes
  };
}

/**
 * Harmonise les détails d'un jeu vidéo vers un format standard
 * @param {object} rawData - Données brutes de la source
 * @param {string} source - Source des données (igdb, rawg, jvc)
 * @returns {object} - Données harmonisées
 */
export function harmonizeGameDetails(rawData, source) {
  const extractNames = (arr) => {
    if (!arr) return [];
    if (typeof arr === 'string') return [arr];
    return arr.map(item => typeof item === 'object' ? (item.name || item) : item).filter(Boolean);
  };

  const extractGenres = (arr) => {
    if (!arr) return [];
    return arr.map(item => typeof item === 'object' ? (item.name || item) : item).filter(Boolean);
  };

  const extractPlatforms = (arr) => {
    if (!arr) return [];
    return arr.map(item => typeof item === 'object' ? (item.name || item) : item).filter(Boolean);
  };

  const normalizeRating = (rating, source) => {
    if (rating == null) return null;
    if (source === 'rawg') return Math.round(rating * 20);
    if (source === 'jvc') return Math.round(rating * 5);
    return Math.round(rating);
  };

  const harmonized = {
    source: source,
    id: rawData.id,
    slug: rawData.slug || null,
    title: rawData.title || rawData.name,
    image: rawData.image || [],
    synopsis: rawData.synopsis || rawData.summary || rawData.description || null,
    releaseDate: rawData.releaseDate || rawData.released || null,
    platforms: extractPlatforms(rawData.platforms),
    genres: extractGenres(rawData.genres),
    developers: extractNames(rawData.developers || (rawData.developer ? [rawData.developer] : [])),
    publishers: extractNames(rawData.publishers || (rawData.publisher ? [rawData.publisher] : [])),
    pegi: rawData.pegi || null,
    minAge: rawData.minAge || null,
    isMultiplayer: rawData.isMultiplayer || false,
    rating: normalizeRating(
      rawData.totalRating || rawData.rating || rawData.ratings?.test,
      source
    ),
    url: rawData.url
  };

  const specificFields = {};

  if (source === 'igdb') {
    Object.assign(specificFields, {
      storyline: rawData.storyline,
      aggregatedRating: rawData.aggregatedRating,
      ratingCount: rawData.ratingCount,
      cover: rawData.cover,
      artworks: rawData.artworks,
      screenshots: rawData.screenshots,
      gameModes: rawData.gameModes,
      themes: rawData.themes,
      playerPerspectives: rawData.playerPerspectives,
      keywords: rawData.keywords,
      franchises: rawData.franchises,
      collection: rawData.collection,
      ageRatings: rawData.ageRatings,
      videos: rawData.videos,
      websites: rawData.websites,
      similarGames: rawData.similarGames,
      dlcs: rawData.dlcs,
      expansions: rawData.expansions,
      parentGame: rawData.parentGame
    });
  } else if (source === 'rawg') {
    Object.assign(specificFields, {
      nameOriginal: rawData.nameOriginal,
      metacritic: rawData.metacritic,
      metacriticPlatforms: rawData.metacriticPlatforms,
      playtime: rawData.playtime,
      achievementsCount: rawData.achievementsCount,
      ratingsCount: rawData.ratingsCount,
      reviewsCount: rawData.reviewsCount,
      ratings: rawData.ratings,
      stores: rawData.stores,
      tags: rawData.tags,
      esrbRating: rawData.esrbRating,
      clip: rawData.clip,
      website: rawData.website,
      backgroundImage: rawData.backgroundImage,
      backgroundImageAdditional: rawData.backgroundImageAdditional,
      tba: rawData.tba,
      updated: rawData.updated
    });
  } else if (source === 'jvc') {
    Object.assign(specificFields, {
      cover: rawData.cover,
      nbPlayers: rawData.nbPlayers,
      ratings: rawData.ratings,
      testUrl: rawData.testUrl
    });
  }

  harmonized._raw = specificFields;
  return harmonized;
}

// ============================================================================
// RAWG API
// ============================================================================

/**
 * Recherche des jeux sur RAWG
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Clé API RAWG
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchRawg(query, apiKey, options = {}) {
  const {
    max = RAWG_DEFAULT_MAX,
    page = 1,
    platforms = null,
    genres = null,
    ordering = null,
    dates = null,
    metacritic = null
  } = options;
  
  const cacheKey = `rawg_search_${query}_${max}_${page}_${platforms}_${ordering}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logRAWG.debug(` Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logRAWG.debug(` Recherche: "${query}" (page ${page}, max ${max})`);
  metrics.sources.rawg.requests++;
  
  try {
    const params = new URLSearchParams({
      key: apiKey,
      search: query,
      page_size: Math.min(max, RAWG_MAX_LIMIT),
      page: page
    });
    
    if (platforms) params.append('platforms', platforms);
    if (genres) params.append('genres', genres);
    if (ordering) params.append('ordering', ordering);
    if (dates) params.append('dates', dates);
    if (metacritic) params.append('metacritic', metacritic);
    
    const url = `${RAWG_BASE_URL}/games?${params.toString()}`;
    logRAWG.debug(` URL: ${url.replace(apiKey, '***')}`);
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur RAWG API ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const result = {
      source: "rawg",
      query: query,
      page: page,
      pageSize: Math.min(max, RAWG_MAX_LIMIT),
      totalResults: data.count || 0,
      totalPages: Math.ceil((data.count || 0) / Math.min(max, RAWG_MAX_LIMIT)),
      hasNext: !!data.next,
      hasPrevious: !!data.previous,
      count: data.results?.length || 0,
      games: (data.results || []).map(game => ({
        id: game.id,
        slug: game.slug,
        name: game.name,
        image: game.background_image ? [game.background_image] : [],
        released: game.released,
        thumb: game.background_image,
        backgroundImage: game.background_image,
        rating: game.rating,
        ratingTop: game.rating_top,
        ratingsCount: game.ratings_count,
        metacritic: game.metacritic,
        playtime: game.playtime,
        platforms: game.platforms?.map(p => ({
          id: p.platform?.id,
          name: p.platform?.name,
          slug: p.platform?.slug
        })) || [],
        genres: game.genres?.map(g => ({
          id: g.id,
          name: g.name,
          slug: g.slug
        })) || [],
        esrbRating: game.esrb_rating ? {
          id: game.esrb_rating.id,
          name: game.esrb_rating.name,
          slug: game.esrb_rating.slug
        } : null,
        shortScreenshots: game.short_screenshots?.map(s => s.image) || [],
        url: `https://rawg.io/games/${game.slug}`
      }))
    };
    
    logRAWG.debug(` ✅ ${result.count} jeux trouvés sur ${result.totalResults} total`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rawg.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'un jeu sur RAWG
 * @param {string|number} gameId - ID ou slug du jeu
 * @param {string} apiKey - Clé API RAWG
 * @returns {Promise<object>} - Détails du jeu harmonisés
 */
export async function getRawgGameDetails(gameId, apiKey) {
  const cacheKey = `rawg_game_${gameId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logRAWG.debug(` Cache hit: ${gameId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logRAWG.debug(` Récupération détails: ${gameId}`);
  metrics.sources.rawg.requests++;
  
  try {
    const url = `${RAWG_BASE_URL}/games/${gameId}?key=${apiKey}`;
    
    const response = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': USER_AGENT
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Jeu ${gameId} non trouvé sur RAWG`);
      }
      throw new Error(`Erreur RAWG API: ${response.status}`);
    }
    
    const game = await response.json();
    
    // Détecter le multijoueur à partir des tags
    const multiTags = ['multiplayer', 'co-op', 'online-co-op', 'local-co-op', 'split-screen', 'mmo', 'massively-multiplayer', 'online-multiplayer', 'local-multiplayer', 'pvp', 'battle-royale'];
    const tags = game.tags?.map(t => t.slug) || [];
    const isMultiplayer = tags.some(tag => multiTags.includes(tag));
    
    // Convertir ESRB en âge minimum
    const esrbToMinAge = {
      'everyone': 6,
      'everyone-10-plus': 10,
      'teen': 13,
      'mature': 17,
      'adults-only': 18,
      'rating-pending': null,
      'early-childhood': 3
    };
    const minAge = game.esrb_rating ? (esrbToMinAge[game.esrb_rating.slug] || null) : null;
    
    const imageList = [game.background_image, game.background_image_additional].filter(Boolean);
    
    const result = {
      source: "rawg",
      id: game.id,
      slug: game.slug,
      name: game.name,
      image: imageList,
      nameOriginal: game.name_original,
      description: game.description_raw || game.description,
      released: game.released,
      tba: game.tba,
      backgroundImage: game.background_image,
      backgroundImageAdditional: game.background_image_additional,
      website: game.website,
      rating: game.rating,
      ratingTop: game.rating_top,
      ratings: game.ratings?.map(r => ({
        id: r.id,
        title: r.title,
        count: r.count,
        percent: r.percent
      })) || [],
      ratingsCount: game.ratings_count,
      reviewsCount: game.reviews_count,
      metacritic: game.metacritic,
      metacriticPlatforms: game.metacritic_platforms?.map(m => ({
        platform: m.platform?.name,
        score: m.metascore,
        url: m.url
      })) || [],
      playtime: game.playtime,
      achievementsCount: game.achievements_count,
      platforms: game.platforms?.map(p => ({
        id: p.platform?.id,
        name: p.platform?.name,
        slug: p.platform?.slug,
        requirements: p.requirements || null,
        releasedAt: p.released_at
      })) || [],
      genres: game.genres?.map(g => ({
        id: g.id,
        name: g.name,
        slug: g.slug
      })) || [],
      stores: game.stores?.map(s => ({
        id: s.store?.id,
        name: s.store?.name,
        slug: s.store?.slug,
        url: s.url
      })) || [],
      developers: game.developers?.map(d => ({
        id: d.id,
        name: d.name,
        slug: d.slug
      })) || [],
      publishers: game.publishers?.map(p => ({
        id: p.id,
        name: p.name,
        slug: p.slug
      })) || [],
      tags: game.tags?.map(t => ({
        id: t.id,
        name: t.name,
        slug: t.slug,
        language: t.language
      })) || [],
      isMultiplayer: isMultiplayer,
      esrbRating: game.esrb_rating ? {
        id: game.esrb_rating.id,
        name: game.esrb_rating.name,
        slug: game.esrb_rating.slug
      } : null,
      pegi: game.esrb_rating ? game.esrb_rating.name : null,
      minAge: minAge,
      clip: game.clip ? {
        video: game.clip.clip,
        preview: game.clip.preview
      } : null,
      updated: game.updated,
      url: `https://rawg.io/games/${game.slug}`
    };
    
    const harmonized = harmonizeGameDetails(result, 'rawg');
    
    logRAWG.debug(` ✅ Jeu récupéré: ${result.name}`);
    setCache(cacheKey, harmonized);
    return harmonized;
    
  } catch (err) {
    metrics.sources.rawg.errors++;
    throw err;
  }
}

// ============================================================================
// IGDB API (Twitch)
// ============================================================================

/**
 * Obtient un token d'accès IGDB via OAuth2
 * @param {string} clientId - Client ID Twitch
 * @param {string} clientSecret - Client Secret Twitch
 * @returns {Promise<string>} - Token d'accès
 */
export async function getIgdbToken(clientId, clientSecret) {
  if (igdbTokenCache.token && Date.now() < igdbTokenCache.expiresAt) {
    logIGDB.debug(` Utilisation du token en cache`);
    return igdbTokenCache.token;
  }
  
  logIGDB.debug(` Obtention d'un nouveau token OAuth2...`);
  
  try {
    const url = `${IGDB_AUTH_URL}?client_id=${clientId}&client_secret=${clientSecret}&grant_type=client_credentials`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur OAuth2 IGDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    igdbTokenCache.token = data.access_token;
    igdbTokenCache.expiresAt = Date.now() + ((data.expires_in - 3600) * 1000);
    
    logIGDB.debug(` ✅ Token obtenu, expire dans ${Math.floor(data.expires_in / 3600)}h`);
    return data.access_token;
    
  } catch (err) {
    logIGDB.error(` Erreur OAuth2:`, err.message);
    throw err;
  }
}

/**
 * Recherche des jeux sur IGDB
 * @param {string} query - Terme de recherche
 * @param {string} clientId - Client ID Twitch
 * @param {string} accessToken - Token OAuth2
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchIgdb(query, clientId, accessToken, options = {}) {
  const { max = IGDB_DEFAULT_MAX, platforms = null, genres = null } = options;
  
  const cacheKey = `igdb_search_${query}_${max}_${platforms}_${genres}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logIGDB.debug(` Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logIGDB.debug(` Recherche: "${query}" (max ${max})`);
  metrics.sources.igdb.requests++;
  
  try {
    let body = `search "${query}";`;
    body += `fields id,name,slug,summary,rating,aggregated_rating,total_rating,first_release_date,`;
    body += `cover.image_id,genres.name,platforms.name,platforms.abbreviation,`;
    body += `involved_companies.company.name,involved_companies.developer,involved_companies.publisher,`;
    body += `screenshots.image_id,videos.video_id,game_modes.name,themes.name;`;
    body += `limit ${Math.min(max, IGDB_MAX_LIMIT)};`;
    
    let filters = [];
    if (platforms) filters.push(`platforms = (${platforms})`);
    if (genres) filters.push(`genres = (${genres})`);
    if (filters.length > 0) body += `where ${filters.join(' & ')};`;
    
    const response = await fetch(`${IGDB_BASE_URL}/games`, {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Client-ID': clientId,
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'text/plain'
      },
      body: body
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IGDB API ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const result = {
      source: "igdb",
      query: query,
      count: data.length,
      games: data.map(game => {
        const developers = game.involved_companies?.filter(ic => ic.developer)?.map(ic => ic.company?.name) || [];
        const publishers = game.involved_companies?.filter(ic => ic.publisher)?.map(ic => ic.company?.name) || [];
        
        return {
          id: game.id,
          slug: game.slug,
          name: game.name,
          image: game.cover ? [`https://images.igdb.com/igdb/image/upload/t_cover_big/${game.cover.image_id}.jpg`] : [],
          summary: game.summary || null,
          thumb: game.cover ? `https://images.igdb.com/igdb/image/upload/t_cover_big/${game.cover.image_id}.jpg` : null,
          rating: game.rating ? Math.round(game.rating * 10) / 10 : null,
          aggregatedRating: game.aggregated_rating ? Math.round(game.aggregated_rating * 10) / 10 : null,
          totalRating: game.total_rating ? Math.round(game.total_rating * 10) / 10 : null,
          releaseDate: game.first_release_date ? new Date(game.first_release_date * 1000).toISOString().split('T')[0] : null,
          cover: game.cover ? {
            imageId: game.cover.image_id,
            thumbnail: `https://images.igdb.com/igdb/image/upload/t_thumb/${game.cover.image_id}.jpg`,
            coverSmall: `https://images.igdb.com/igdb/image/upload/t_cover_small/${game.cover.image_id}.jpg`,
            coverBig: `https://images.igdb.com/igdb/image/upload/t_cover_big/${game.cover.image_id}.jpg`,
            hd: `https://images.igdb.com/igdb/image/upload/t_720p/${game.cover.image_id}.jpg`
          } : null,
          genres: game.genres?.map(g => g.name) || [],
          platforms: game.platforms?.map(p => ({ name: p.name, abbreviation: p.abbreviation })) || [],
          developers: developers,
          publishers: publishers,
          gameModes: game.game_modes?.map(m => m.name) || [],
          themes: game.themes?.map(t => t.name) || [],
          screenshots: game.screenshots?.slice(0, 5).map(s => ({
            imageId: s.image_id,
            thumbnail: `https://images.igdb.com/igdb/image/upload/t_thumb/${s.image_id}.jpg`,
            full: `https://images.igdb.com/igdb/image/upload/t_screenshot_big/${s.image_id}.jpg`
          })) || [],
          videos: game.videos?.map(v => ({
            videoId: v.video_id,
            youtubeUrl: `https://www.youtube.com/watch?v=${v.video_id}`
          })) || [],
          url: `https://www.igdb.com/games/${game.slug}`
        };
      })
    };
    
    logIGDB.debug(` ✅ ${result.count} jeux trouvés`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.igdb.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'un jeu sur IGDB
 * @param {string|number} gameId - ID ou slug du jeu
 * @param {string} clientId - Client ID Twitch
 * @param {string} accessToken - Token OAuth2
 * @returns {Promise<object>} - Détails du jeu harmonisés
 */
export async function getIgdbGameDetails(gameId, clientId, accessToken) {
  const cacheKey = `igdb_game_${gameId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    logIGDB.debug(` Cache hit: ${gameId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  logIGDB.debug(` Récupération détails: ${gameId}`);
  metrics.sources.igdb.requests++;
  
  try {
    const isNumeric = /^\d+$/.test(String(gameId));
    let whereClause = isNumeric ? `where id = ${gameId};` : `where slug = "${gameId}";`;
    
    let body = `fields id,name,slug,summary,storyline,rating,aggregated_rating,total_rating,`;
    body += `rating_count,first_release_date,`;
    body += `cover.image_id,artworks.image_id,screenshots.image_id,`;
    body += `genres.name,platforms.name,platforms.abbreviation,`;
    body += `involved_companies.company.name,involved_companies.developer,involved_companies.publisher,`;
    body += `game_modes.name,themes.name,player_perspectives.name,keywords.name,`;
    body += `franchises.name,collection.name,age_ratings.*,`;
    body += `videos.name,videos.video_id,websites.url,websites.category,`;
    body += `similar_games.name,similar_games.slug,similar_games.cover.image_id,`;
    body += `dlcs.name,dlcs.slug,expansions.name,expansions.slug,parent_game.name,parent_game.slug;`;
    body += whereClause;
    
    const response = await fetch(`${IGDB_BASE_URL}/games`, {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Client-ID': clientId,
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'text/plain'
      },
      body: body
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IGDB API ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    if (!data || data.length === 0) {
      throw new Error(`Jeu ${gameId} non trouvé sur IGDB`);
    }
    
    const game = data[0];
    const developers = game.involved_companies?.filter(ic => ic.developer)?.map(ic => ic.company?.name) || [];
    const publishers = game.involved_companies?.filter(ic => ic.publisher)?.map(ic => ic.company?.name) || [];
    const gameModes = game.game_modes?.map(m => m.name) || [];
    const multiplayerInfo = detectMultiplayer(gameModes);
    
    // Parser les age ratings
    const ageRatings = game.age_ratings?.map(ar => parseIgdbAgeRating(ar.organization, ar.rating_category)) || [];
    
    // Extraire PEGI en priorité, sinon ESRB
    const pegiRating = ageRatings.find(r => r.system === 'PEGI');
    const esrbRating = ageRatings.find(r => r.system === 'ESRB');
    const primaryRating = pegiRating || esrbRating || ageRatings[0] || null;
    
    // Construire la liste d'images harmonisée
    const imageList = [];
    if (game.cover?.image_id) {
      imageList.push(`https://images.igdb.com/igdb/image/upload/t_cover_big/${game.cover.image_id}.jpg`);
    }
    game.artworks?.slice(0, 5).forEach(a => {
      if (a.image_id) imageList.push(`https://images.igdb.com/igdb/image/upload/t_720p/${a.image_id}.jpg`);
    });
    game.screenshots?.slice(0, 5).forEach(s => {
      if (s.image_id) imageList.push(`https://images.igdb.com/igdb/image/upload/t_screenshot_big/${s.image_id}.jpg`);
    });
    
    const result = {
      source: "igdb",
      id: game.id,
      slug: game.slug,
      name: game.name,
      image: imageList,
      summary: game.summary || null,
      storyline: game.storyline || null,
      rating: game.rating ? Math.round(game.rating * 10) / 10 : null,
      aggregatedRating: game.aggregated_rating ? Math.round(game.aggregated_rating * 10) / 10 : null,
      totalRating: game.total_rating ? Math.round(game.total_rating * 10) / 10 : null,
      ratingCount: game.rating_count || 0,
      releaseDate: game.first_release_date ? new Date(game.first_release_date * 1000).toISOString().split('T')[0] : null,
      cover: game.cover ? {
        imageId: game.cover.image_id,
        thumbnail: `https://images.igdb.com/igdb/image/upload/t_thumb/${game.cover.image_id}.jpg`,
        coverSmall: `https://images.igdb.com/igdb/image/upload/t_cover_small/${game.cover.image_id}.jpg`,
        coverBig: `https://images.igdb.com/igdb/image/upload/t_cover_big/${game.cover.image_id}.jpg`,
        hd: `https://images.igdb.com/igdb/image/upload/t_720p/${game.cover.image_id}.jpg`,
        fullHd: `https://images.igdb.com/igdb/image/upload/t_1080p/${game.cover.image_id}.jpg`
      } : null,
      artworks: game.artworks?.map(a => ({
        imageId: a.image_id,
        thumbnail: `https://images.igdb.com/igdb/image/upload/t_thumb/${a.image_id}.jpg`,
        hd: `https://images.igdb.com/igdb/image/upload/t_720p/${a.image_id}.jpg`
      })) || [],
      screenshots: game.screenshots?.map(s => ({
        imageId: s.image_id,
        thumbnail: `https://images.igdb.com/igdb/image/upload/t_thumb/${s.image_id}.jpg`,
        big: `https://images.igdb.com/igdb/image/upload/t_screenshot_big/${s.image_id}.jpg`
      })) || [],
      genres: game.genres?.map(g => g.name) || [],
      platforms: game.platforms?.map(p => ({ name: p.name, abbreviation: p.abbreviation })) || [],
      developers: developers,
      publishers: publishers,
      gameModes: gameModes,
      isMultiplayer: multiplayerInfo.isMultiplayer,
      themes: game.themes?.map(t => t.name) || [],
      playerPerspectives: game.player_perspectives?.map(p => p.name) || [],
      keywords: game.keywords?.map(k => k.name) || [],
      franchises: game.franchises?.map(f => f.name) || [],
      collection: game.collection?.name || null,
      ageRatings: ageRatings,
      pegi: primaryRating ? primaryRating.rating : null,
      minAge: primaryRating ? primaryRating.minAge : null,
      videos: game.videos?.map(v => ({
        name: v.name,
        videoId: v.video_id,
        youtubeUrl: `https://www.youtube.com/watch?v=${v.video_id}`
      })) || [],
      websites: game.websites?.map(w => ({
        url: w.url,
        category: getIgdbWebsiteCategory(w.category)
      })) || [],
      similarGames: game.similar_games?.slice(0, 10).map(sg => ({
        name: sg.name,
        slug: sg.slug,
        cover: sg.cover ? `https://images.igdb.com/igdb/image/upload/t_cover_small/${sg.cover.image_id}.jpg` : null,
        url: `https://www.igdb.com/games/${sg.slug}`
      })) || [],
      dlcs: game.dlcs?.map(d => ({ name: d.name, slug: d.slug })) || [],
      expansions: game.expansions?.map(e => ({ name: e.name, slug: e.slug })) || [],
      parentGame: game.parent_game ? { name: game.parent_game.name, slug: game.parent_game.slug } : null,
      url: `https://www.igdb.com/games/${game.slug}`
    };
    
    const harmonized = harmonizeGameDetails(result, 'igdb');
    
    logIGDB.debug(` ✅ Jeu récupéré: ${result.name}`);
    setCache(cacheKey, harmonized);
    return harmonized;
    
  } catch (err) {
    metrics.sources.igdb.errors++;
    throw err;
  }
}

// ============================================================================
// JVC (JeuxVideo.com) - Scraping via FlareSolverr
// ============================================================================

/**
 * Recherche de jeux sur JeuxVideo.com
 * @param {string} query - Terme de recherche
 * @param {object} options - Options { max }
 * @returns {Promise<object>} - Résultats de recherche
 */
export async function searchJVC(query, options = {}) {
  metrics.sources.jvc.requests++;
  const max = Math.min(options.max || JVC_DEFAULT_MAX, 50);
  
  const cacheKey = `jvc_search_${query}_${max}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    logJVC.debug(` Recherche: ${query} (max: ${max})`);
    
    const searchUrl = `${JVC_BASE_URL}/tous-les-jeux/?search=${encodeURIComponent(query)}`;
    const fsrSessionId = getFsrSessionId();
    
    const response = await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        cmd: "request.get",
        url: searchUrl,
        maxTimeout: 30000,
        session: fsrSessionId
      })
    });

    const data = await response.json();
    
    if (data.status !== "ok") {
      throw new Error(`FlareSolverr error: ${data.message || 'Unknown error'}`);
    }

    const html = data.solution?.response || "";
    
    // Parser les résultats de recherche
    const results = [];
    const seenIds = new Set();
    
    const gameRegex = /cardGameList__gameTitleLink"[^>]*href="\/jeux\/jeu-(\d+)\/"[^>]*>([^<]+)</gi;
    const descRegex = /cardGameList__gameDescription">([^<]+)</gi;
    const dateRegex = /cardGameList__releaseDate">Sortie:\s*<span>([^<]+)<\/span>/gi;
    const imgRegex = /cardGameList__image[^>]*src="(https:\/\/image\.jeuxvideo\.com[^"]+)"/gi;
    
    let match;
    const games = [];
    
    while ((match = gameRegex.exec(html)) !== null) {
      const [, id, title] = match;
      if (!seenIds.has(id)) {
        seenIds.add(id);
        games.push({
          id: parseInt(id),
          title: decodeHtmlEntities(title.trim())
        });
      }
    }
    
    const descriptions = [];
    while ((match = descRegex.exec(html)) !== null) {
      descriptions.push(decodeHtmlEntities(match[1].trim()));
    }
    
    const dates = [];
    while ((match = dateRegex.exec(html)) !== null) {
      dates.push(match[1].trim());
    }
    
    const images = [];
    while ((match = imgRegex.exec(html)) !== null) {
      images.push(match[1]);
    }
    
    for (let i = 0; i < Math.min(games.length, max); i++) {
      const coverUrl = images[i] || null;
      results.push({
        id: games[i].id,
        type: 'game',
        title: games[i].title,
        description: descriptions[i] || null,
        releaseDate: dates[i] || null,
        image: coverUrl ? [coverUrl] : [],
        thumb: coverUrl,
        cover: coverUrl,
        url: `${JVC_BASE_URL}/jeux/jeu-${games[i].id}/`,
        source: 'jvc'
      });
    }

    const result = {
      query,
      resultsCount: results.length,
      results,
      source: 'jvc',
      note: 'Résultats en français depuis JeuxVideo.com'
    };

    logJVC.debug(` ✅ ${results.length} jeux trouvés`);
    setCache(cacheKey, result);
    return result;

  } catch (err) {
    metrics.sources.jvc.errors++;
    throw err;
  }
}

/**
 * Récupère les détails d'un jeu sur JeuxVideo.com par ID
 * @param {string|number} gameId - ID du jeu
 * @returns {Promise<object>} - Détails du jeu harmonisés
 */
export async function getJVCGameById(gameId) {
  metrics.sources.jvc.requests++;
  
  const cacheKey = `jvc_game_${gameId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    logJVC.debug(` Récupération jeu: ${gameId}`);
    
    const gameUrl = `${JVC_BASE_URL}/jeux/jeu-${gameId}/`;
    const fsrSessionId = getFsrSessionId();
    
    const response = await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        cmd: "request.get",
        url: gameUrl,
        maxTimeout: 30000,
        session: fsrSessionId
      })
    });

    const data = await response.json();
    
    if (data.status !== "ok") {
      throw new Error(`FlareSolverr error: ${data.message || 'Unknown error'}`);
    }

    const html = data.solution?.response || "";
    
    // Extraire le titre
    const titleMatch = html.match(/gameHeaderBanner__title[^>]*>([^<]+)/i);
    const title = titleMatch ? decodeHtmlEntities(titleMatch[1].trim()) : null;
    
    if (!title) {
      throw new Error(`Jeu non trouvé: ${gameId}`);
    }
    
    // Extraire les données structurées
    let genres = [];
    let publisher = null;
    let developer = null;
    let releaseDate = null;
    let pegi = null;
    let platforms = [];
    let nbPlayers = null;
    let isMultiplayer = false;
    
    // Parser analyticsMetadata
    const analyticsMatch = html.match(/window\.jvc\.analyticsMetadata\s*=\s*(\{[^}]+\})/i);
    if (analyticsMatch) {
      try {
        const analytics = JSON.parse(analyticsMatch[1]);
        if (analytics.genre_tags_name) {
          genres = analytics.genre_tags_name.split('|').map(g => g.trim()).filter(g => g);
        }
        if (analytics.publisher_tags_name) {
          publisher = analytics.publisher_tags_name;
        }
        if (analytics.developer_tags_name) {
          developer = analytics.developer_tags_name;
        }
        if (analytics.masterfiche_game_release_date) {
          releaseDate = analytics.masterfiche_game_release_date;
        }
        if (analytics.pegi_tags_name) {
          pegi = analytics.pegi_tags_name;
        }
      } catch (e) {
        logJVC.debug(` Erreur parsing analyticsMetadata: ${e.message}`);
      }
    }
    
    // Parser dataLayer pour les plateformes
    const dataLayerMatch = html.match(/dataLayer\s*=\s*\[(\{[^}]+\})\]/i);
    if (dataLayerMatch) {
      try {
        const dataLayer = JSON.parse(dataLayerMatch[1]);
        if (dataLayer.platform && Array.isArray(dataLayer.platform)) {
          const platformMap = {
            'switch': 'Nintendo Switch',
            'switch-2': 'Nintendo Switch 2',
            'wiiu': 'Wii U',
            'ps5': 'PlayStation 5',
            'ps4': 'PlayStation 4',
            'ps3': 'PlayStation 3',
            'xboxone': 'Xbox One',
            'xboxseries': 'Xbox Series X|S',
            'pc': 'PC',
            '3ds': 'Nintendo 3DS',
            'vita': 'PS Vita',
            'android': 'Android',
            'ios': 'iOS',
            'stadia': 'Stadia',
            'luna': 'Amazon Luna'
          };
          platforms = dataLayer.platform.map(p => platformMap[p.toLowerCase()] || p.toUpperCase());
        }
        if (!developer && dataLayer.game_developer && Array.isArray(dataLayer.game_developer)) {
          developer = dataLayer.game_developer[0];
        }
      } catch (e) {
        logJVC.debug(` Erreur parsing dataLayer: ${e.message}`);
      }
    }
    
    // Fallback: extraire le développeur depuis le HTML
    if (!developer) {
      const devMatch = html.match(/Développeur[^:]*:\s*<[^>]+>([^<]+)</i) ||
                       html.match(/developer[^"]*"[^>]*>([^<]+)</i);
      if (devMatch) {
        developer = decodeHtmlEntities(devMatch[1].trim());
      }
    }
    
    // Extraire le nombre de joueurs
    const playersMatch = html.match(/Nombre de joueurs[^:]*:\s*<[^>]*>([^<]+)</i) ||
                         html.match(/Nombre de joueurs[^:]*:\s*([0-9][^<]*)</i) ||
                         html.match(/"nb_players"\s*:\s*"([^"]+)"/i);
    if (playersMatch) {
      const rawPlayers = playersMatch[1].trim();
      if (/\d/.test(rawPlayers) && rawPlayers.length < 50) {
        nbPlayers = rawPlayers;
        const numMatch = nbPlayers.match(/(\d+)\s*(?:à|-)?\s*(\d+)?/);
        if (numMatch) {
          const maxPlayers = parseInt(numMatch[2] || numMatch[1]);
          isMultiplayer = maxPlayers > 1;
        }
        if (/multijoueur|multi|en ligne|online|coop|co-op/i.test(nbPlayers)) {
          isMultiplayer = true;
        }
      }
    }
    
    // Détecter multijoueur depuis les genres ou le HTML
    if (!isMultiplayer) {
      const multiMatch = html.match(/multijoueur|multiplayer|en ligne|online|co-op|coop/i);
      if (multiMatch) {
        isMultiplayer = true;
      }
    }
    
    // Fallback: extraire les plateformes depuis le header
    if (platforms.length === 0) {
      const platformRegex = /gameHeaderBanner__platformLink[^>]*>([^<]+)</gi;
      let platformMatch;
      while ((platformMatch = platformRegex.exec(html)) !== null) {
        const platformName = platformMatch[1].trim();
        if (platformName && !platforms.includes(platformName)) {
          platforms.push(platformName);
        }
      }
    }
    
    // Extraire la description depuis les meta tags
    const descMatch = html.match(/name="description"[^>]*content="([^"]+)"/i) ||
                      html.match(/property="og:description"[^>]*content="([^"]+)"/i);
    let description = descMatch ? decodeHtmlEntities(descMatch[1].trim()) : null;
    
    if (description) {
      const cleanDesc = description.replace(/^[^:]+:\s*retrouvez toutes les informations et actualités du jeu sur tous ses supports\.\s*/i, '');
      description = cleanDesc || description;
    }
    
    // Extraire l'image OG
    const ogImageMatch = html.match(/property="og:image"[^>]*content="([^"]+)"/i);
    const cover = ogImageMatch ? ogImageMatch[1] : null;
    
    // Extraire le lien vers le test
    const testMatch = html.match(/href="(\/test\/[^"]+\.htm)"/i);
    const testUrl = testMatch ? `${JVC_BASE_URL}${testMatch[1]}` : null;
    
    // Extraire les notes
    let testRating = null;
    const ratingMatch = html.match(/"game_tester_rating"\s*:\s*"(\d+(?:\.\d+)?)"/i);
    if (ratingMatch) {
      testRating = parseFloat(ratingMatch[1]);
    }
    
    let userRating = null;
    const userRatingMatch = html.match(/"game_usr_rating"\s*:\s*"(\d+(?:\.\d+)?)"/i);
    if (userRatingMatch) {
      userRating = parseFloat(userRatingMatch[1]);
    }
    
    // Extraire l'âge minimum depuis le PEGI
    let minAge = null;
    if (pegi) {
      const ageMatch = pegi.match(/\+?(\d+)/);
      if (ageMatch) {
        minAge = parseInt(ageMatch[1]);
      }
    }
    
    const result = {
      id: parseInt(gameId),
      type: 'game',
      title: title,
      image: cover ? [cover] : [],
      description: description,
      cover: cover,
      releaseDate: releaseDate,
      platforms: platforms.length > 0 ? platforms : null,
      genres: genres.length > 0 ? genres : null,
      publisher: publisher,
      developer: developer,
      pegi: pegi,
      minAge: minAge,
      nbPlayers: nbPlayers,
      isMultiplayer: isMultiplayer,
      ratings: {
        test: testRating,
        users: userRating
      },
      testUrl: testUrl,
      url: gameUrl,
      source: 'jvc'
    };

    const harmonized = harmonizeGameDetails(result, 'jvc');
    
    logJVC.debug(` ✅ Jeu récupéré: ${result.title}`);
    setCache(cacheKey, harmonized);
    return harmonized;

  } catch (err) {
    metrics.sources.jvc.errors++;
    throw err;
  }
}

// index.js
import express from "express";
import fetch from "node-fetch";
import crypto from "crypto";
import compression from "compression";

// Import du module Amazon
import {
  searchAmazon,
  getAmazonProduct,
  searchByBarcode as searchAmazonByBarcode,
  searchMultiCountry as searchAmazonMultiCountry,
  comparePrices as compareAmazonPrices,
  getSupportedMarketplaces,
  getSupportedCategories,
  AMAZON_MARKETPLACES,
  AMAZON_CATEGORIES,
  checkVpnStatus,
  rotateVpnIp
} from './lib/amazon.js';

// Import du module LEGO (avec alias)
import {
  callLegoGraphql as callLegoGraphqlLib,
  getProductDetails as getLegoProductDetailsLib,
  getBuildingInstructions as getBuildingInstructionsLib
} from './lib/lego.js';

// Import du module Rebrickable (avec alias)
import {
  smartRebrickableSearch as smartRebrickableSearchLib,
  getRebrickableSetFull as getRebrickableSetFullLib,
  getRebrickableSetParts as getRebrickableSetPartsLib,
  getRebrickableSetMinifigs as getRebrickableSetMinifigsLib,
  searchRebrickable as searchRebrickableLib,
  getRebrickableThemes as getRebrickableThemesLib,
  getRebrickableColors as getRebrickableColorsLib
} from './lib/rebrickable.js';

// Import du module livres (Google Books + OpenLibrary) (avec alias)
import {
  searchGoogleBooks as searchGoogleBooksLib,
  getGoogleBookById as getGoogleBookByIdLib,
  searchOpenLibrary as searchOpenLibraryLib,
  searchOpenLibraryByIsbn as searchOpenLibraryByIsbnLib,
  searchOpenLibraryByText as searchOpenLibraryByTextLib,
  getOpenLibraryById as getOpenLibraryByIdLib,
  isIsbn as isIsbnLib
} from './lib/books.js';

// Import du module jeux vid√©o (RAWG + IGDB + JVC) (avec alias)
import {
  searchRawg as searchRawgLib,
  getRawgGameDetails as getRawgGameDetailsLib,
  getIgdbToken as getIgdbTokenLib,
  searchIgdb as searchIgdbLib,
  getIgdbGameDetails as getIgdbGameDetailsLib,
  searchJVC as searchJVCLib,
  getJVCGameById as getJVCGameByIdLib
} from './lib/videogames.js';

// Import du module m√©dias (TVDB + TMDB + IMDB) (avec alias)
import {
  getTvdbToken as getTvdbTokenLib,
  searchTvdb as searchTvdbLib,
  getTvdbSeriesById as getTvdbSeriesByIdLib,
  getTvdbMovieById as getTvdbMovieByIdLib,
  searchTmdb as searchTmdbLib,
  getTmdbMovieById as getTmdbMovieByIdLib,
  getTmdbTvById as getTmdbTvByIdLib,
  searchImdb as searchImdbLib,
  getImdbTitleById as getImdbTitleByIdLib,
  browseImdbTitles as browseImdbTitlesLib
} from './lib/media.js';

// Import du module anime (Jikan) (avec alias)
import {
  searchJikanAnime as searchJikanAnimeLib,
  searchJikanManga as searchJikanMangaLib,
  getJikanAnimeById as getJikanAnimeByIdLib,
  getJikanMangaById as getJikanMangaByIdLib
} from './lib/anime.js';

// Import du module comics (ComicVine + MangaDex + Bedetheque) (avec alias)
import {
  searchComicVine as searchComicVineLib,
  getComicVineVolume as getComicVineVolumeLib,
  getComicVineIssue as getComicVineIssueLib,
  searchMangaDex as searchMangaDexLib,
  getMangaDexById as getMangaDexByIdLib,
  searchBedetheque as searchBedethequeLib,
  searchBedethequeAlbums as searchBedethequeAlbumsLib,
  getBedethequeSerieById as getBedethequeSerieByIdLib,
  getBedethequeAlbumById as getBedethequeAlbumByIdLib
} from './lib/comics.js';

// Import du module collectibles (Coleka, LuluBerlu, Paninimania, etc.) (avec alias)
import {
  searchMega as searchMegaLib,
  getMegaProductById as getMegaProductByIdLib,
  searchColeka as searchColekaLib,
  searchLuluBerlu as searchLuluBerluLib,
  searchTransformerland as searchTransformerlandLib,
  searchConsoleVariations as searchConsoleVariationsLib,
  searchPaninimania as searchPaninimanaLib
} from './lib/collectibles.js';

// Import de la configuration centralis√©e
import {
  API_VERSION,
  DEFAULT_LOCALE,
  MAX_RETRIES,
  FSR_BASE,
  COLEKA_BASE_URL,
  COLEKA_DEFAULT_NBPP,
  LULUBERLU_BASE_URL,
  LULUBERLU_SEARCH_URL,
  LULUBERLU_RESULTS_PER_PAGE,
  LULUBERLU_DEFAULT_MAX,
  TRANSFORMERLAND_BASE_URL,
  TRANSFORMERLAND_SEARCH_URL,
  TRANSFORMERLAND_DEFAULT_MAX,
  PANINIMANIA_BASE_URL,
  PANINIMANIA_RESULTS_PER_PAGE,
  PANINIMANIA_DEFAULT_MAX,
  REBRICKABLE_BASE_URL,
  REBRICKABLE_DEFAULT_MAX,
  GOOGLE_BOOKS_BASE_URL,
  GOOGLE_BOOKS_DEFAULT_MAX,
  GOOGLE_BOOKS_MAX_LIMIT,
  OPENLIBRARY_BASE_URL,
  OPENLIBRARY_DEFAULT_MAX,
  OPENLIBRARY_MAX_LIMIT,
  RAWG_BASE_URL,
  RAWG_DEFAULT_MAX,
  RAWG_MAX_LIMIT,
  IGDB_BASE_URL,
  IGDB_AUTH_URL,
  IGDB_DEFAULT_MAX,
  IGDB_MAX_LIMIT,
  TVDB_BASE_URL,
  TVDB_DEFAULT_MAX,
  TVDB_MAX_LIMIT,
  TMDB_BASE_URL,
  TMDB_IMAGE_BASE_URL,
  TMDB_DEFAULT_MAX,
  TMDB_MAX_LIMIT,
  IMDB_BASE_URL,
  IMDB_DEFAULT_MAX,
  IMDB_MAX_LIMIT,
  JIKAN_BASE_URL,
  JIKAN_DEFAULT_MAX,
  JIKAN_MAX_LIMIT,
  COMICVINE_API_KEY,
  COMICVINE_BASE_URL,
  COMICVINE_DEFAULT_MAX,
  COMICVINE_MAX_LIMIT,
  MANGADEX_BASE_URL,
  MANGADEX_COVERS_URL,
  MANGADEX_DEFAULT_MAX,
  MANGADEX_MAX_LIMIT,
  BEDETHEQUE_BASE_URL,
  BEDETHEQUE_DEFAULT_MAX,
  JVC_BASE_URL,
  JVC_DEFAULT_MAX,
  MEGA_API_URL_US,
  MEGA_SITE_ID_US,
  MEGA_BASE_URL_US,
  MEGA_API_URL_EU,
  MEGA_SITE_ID_EU,
  MEGA_BASE_URL_EU,
  MEGA_DEFAULT_MAX,
  MEGA_MAX_LIMIT,
  MEGA_DEFAULT_LANG,
  MEGA_LANG_REGION,
  UPCITEMDB_BASE_URL,
  OPENFOODFACTS_BASE_URL,
  BARCODELOOKUP_BASE_URL,
  MUSICBRAINZ_BASE_URL,
  MUSICBRAINZ_COVER_URL,
  DISCOGS_BASE_URL,
  DEEZER_BASE_URL,
  ITUNES_BASE_URL,
  MUSIC_DEFAULT_MAX,
  CONSOLEVARIATIONS_BASE_URL,
  CONSOLEVARIATIONS_CDN_URL,
  CONSOLEVARIATIONS_DEFAULT_MAX,
  USER_AGENT,
  GRAPHQL_URL
} from './lib/config.js';

const app = express();
const PORT = process.env.PORT ? parseInt(process.env.PORT) : 3000;

// Activer la compression gzip pour toutes les r√©ponses
app.use(compression({
  level: 6, // Niveau de compression (1-9, 6 est un bon compromis vitesse/taille)
  threshold: 1024, // Ne compresser que si > 1KB
  filter: (req, res) => {
    // Compresser sauf si le header indique de ne pas le faire
    if (req.headers['x-no-compression']) return false;
    return compression.filter(req, res);
  }
}));

// Middleware JSON avec limite de taille (protection contre les gros payloads)
app.use(express.json({ limit: '1mb' }));

// Middleware CORS - permet l'acc√®s depuis n'importe quel domaine
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});

// Middleware pour les headers de s√©curit√©
app.use((req, res, next) => {
  res.header('X-Content-Type-Options', 'nosniff');
  res.header('X-Frame-Options', 'DENY');
  res.header('X-XSS-Protection', '1; mode=block');
  next();
});

// Middleware pour ajouter un Request ID unique (utile pour le debugging)
app.use((req, res, next) => {
  req.id = crypto.randomUUID().substring(0, 8);
  res.header('X-Request-ID', req.id);
  next();
});

// Configuration du cache
const CACHE_TTL = process.env.CACHE_TTL ? parseInt(process.env.CACHE_TTL) : 300000; // 5 minutes par d√©faut
const CACHE_MAX_SIZE = process.env.CACHE_MAX_SIZE ? parseInt(process.env.CACHE_MAX_SIZE) : 100; // Max 100 entr√©es
const cache = new Map();

// Mode de log: 'debug' = tous les logs, 'info' = logs importants, 'error' = erreurs seulement
const LOG_LEVEL = process.env.LOG_LEVEL || 'info';
const log = {
  debug: (...args) => LOG_LEVEL === 'debug' && console.log(...args),
  info: (...args) => ['debug', 'info'].includes(LOG_LEVEL) && console.log(...args),
  warn: (...args) => ['debug', 'info', 'warn'].includes(LOG_LEVEL) && console.warn(...args),
  error: (...args) => console.error(...args)
};

// M√©triques pour le cache et les performances
const metrics = {
  startTime: Date.now(),
  requests: { total: 0, cached: 0, errors: 0 },
  responseTimeSum: 0,
  responseTimeCount: 0,
  sources: {
    lego: { requests: 0, errors: 0 },
    coleka: { requests: 0, errors: 0 },
    luluberlu: { requests: 0, errors: 0 },
    transformerland: { requests: 0, errors: 0 },
    paninimania: { requests: 0, errors: 0 },
    rebrickable: { requests: 0, errors: 0 },
    googlebooks: { requests: 0, errors: 0 },
    openlibrary: { requests: 0, errors: 0 },
    rawg: { requests: 0, errors: 0 },
    igdb: { requests: 0, errors: 0 },
    tvdb: { requests: 0, errors: 0 },
    tmdb: { requests: 0, errors: 0 },
    imdb: { requests: 0, errors: 0 },
    jikan: { requests: 0, errors: 0 },
    comicvine: { requests: 0, errors: 0 },
    mangadex: { requests: 0, errors: 0 },
    bedetheque: { requests: 0, errors: 0 },
    jvc: { requests: 0, errors: 0 },
    mega: { requests: 0, errors: 0 },
    consolevariations: { requests: 0, errors: 0 },
    amazon: { requests: 0, errors: 0 },
    barcode: { requests: 0, errors: 0 },
    musicbrainz: { requests: 0, errors: 0 },
    discogs: { requests: 0, errors: 0 },
    deezer: { requests: 0, errors: 0 }
  }
};

// Middleware pour tracker les m√©triques
app.use((req, res, next) => {
  const startTime = Date.now();
  metrics.requests.total++;
  
  res.on('finish', () => {
    const duration = Date.now() - startTime;
    metrics.responseTimeSum += duration;
    metrics.responseTimeCount++;
  });
  
  next();
});

// Fonction de cache avec TTL
function getCached(key) {
  const entry = cache.get(key);
  if (!entry) return null;
  if (Date.now() > entry.expiry) {
    cache.delete(key);
    return null;
  }
  // Mise √† jour du lastAccess pour LRU
  entry.lastAccess = Date.now();
  console.log(`[Cache] HIT: ${key.substring(0, 50)}...`);
  metrics.requests.cached++;
  return entry.data;
}

function setCache(key, data, customTtl = null) {
  // Nettoyer le cache si trop grand (LRU: supprimer le moins r√©cemment utilis√©)
  if (cache.size >= CACHE_MAX_SIZE) {
    let oldestKey = null;
    let oldestAccess = Infinity;
    for (const [k, v] of cache) {
      if (v.lastAccess < oldestAccess) {
        oldestAccess = v.lastAccess;
        oldestKey = k;
      }
    }
    if (oldestKey) cache.delete(oldestKey);
  }
  const ttl = customTtl || CACHE_TTL;
  const now = Date.now();
  cache.set(key, { data, expiry: now + ttl, lastAccess: now });
  console.log(`[Cache] SET: ${key.substring(0, 50)}... (TTL: ${ttl/1000}s)`);
}

// Middleware pour ajouter les headers Cache-Control
function addCacheHeaders(res, maxAge = 300) {
  res.set('Cache-Control', `public, max-age=${maxAge}`);
  res.set('X-Cache-TTL', `${maxAge}s`);
}

// Cache pour les tokens IGDB (dur√©e de vie ~60 jours)
let igdbTokenCache = {
  token: null,
  expiresAt: 0
};

// Cache pour les tokens TVDB (dur√©e de vie ~1 mois)
let tvdbTokenCache = {
  token: null,
  expiresAt: 0
};


// Session ID pour FlareSolverr (persistante)
let fsrSessionId = null;
// Timestamp de la derni√®re visite de la page d'accueil LEGO (pour √©viter de revisiter trop souvent)
let lastLegoHomeVisit = 0;
// Dur√©e de validit√© des cookies LEGO (10 minutes)
const LEGO_SESSION_TTL = 10 * 60 * 1000;

// M√©triques pour barcode
metrics.sources.barcode = { requests: 0, errors: 0 };
// M√©triques pour musique
metrics.sources.musicbrainz = { requests: 0, errors: 0 };
metrics.sources.discogs = { requests: 0, errors: 0 };
metrics.sources.deezer = { requests: 0, errors: 0 };

console.log("=========================================");
console.log(`üß∏ Toys API v${API_VERSION}`);
console.log("=========================================");
console.log("FSR:", FSR_BASE);
console.log("Coleka:", COLEKA_BASE_URL);
console.log("Lulu-Berlu:", LULUBERLU_BASE_URL);
console.log("Transformerland:", TRANSFORMERLAND_BASE_URL);
console.log("Google Books:", GOOGLE_BOOKS_BASE_URL);
console.log("OpenLibrary:", OPENLIBRARY_BASE_URL);
console.log("RAWG:", RAWG_BASE_URL);
console.log("IGDB:", IGDB_BASE_URL);
console.log("TVDB:", TVDB_BASE_URL);
console.log("TMDB:", TMDB_BASE_URL);
console.log("Paninimania:", PANINIMANIA_BASE_URL);
console.log("Rebrickable:", REBRICKABLE_BASE_URL);
console.log("JVC:", JVC_BASE_URL);
console.log("Mega Construx US:", MEGA_API_URL_US);
console.log("Mega Construx EU:", MEGA_API_URL_EU);
console.log("Mega Default Lang:", MEGA_DEFAULT_LANG);
console.log("MusicBrainz:", MUSICBRAINZ_BASE_URL);
console.log("Discogs:", DISCOGS_BASE_URL);
console.log("Deezer:", DEEZER_BASE_URL);
console.log("ConsoleVariations:", CONSOLEVARIATIONS_BASE_URL);
console.log("Cache TTL:", CACHE_TTL/1000, "seconds");

// D√©coder les entit√©s HTML
function decodeHtmlEntities(text) {
  if (!text) return text;
  return text
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&apos;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    .replace(/&nbsp;/g, ' ')
    .replace(/&#160;/g, ' ')
    .replace(/&#(\d+);/g, (_, dec) => String.fromCharCode(dec))
    .replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
}

// -----------------------------
// Syst√®me de chiffrement des cl√©s API (AES-256-GCM)
// -----------------------------
const API_ENCRYPTION_KEY = process.env.API_ENCRYPTION_KEY || null;
const ENCRYPTION_ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 12; // Recommand√© pour GCM
const AUTH_TAG_LENGTH = 16;

/**
 * D√©chiffre une cl√© API chiffr√©e en AES-256-GCM
 * Format attendu: base64(iv + authTag + ciphertext)
 * @param {string} encryptedData - Donn√©es chiffr√©es en base64
 * @returns {string|null} - Cl√© d√©chiffr√©e ou null si erreur
 */
function decryptApiKey(encryptedData) {
  if (!API_ENCRYPTION_KEY) {
    console.error("[Crypto] API_ENCRYPTION_KEY non configur√©e");
    return null;
  }
  
  try {
    // D√©code le base64
    const buffer = Buffer.from(encryptedData, 'base64');
    
    // Extrait IV (12 bytes), authTag (16 bytes), et ciphertext
    const iv = buffer.subarray(0, IV_LENGTH);
    const authTag = buffer.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    const ciphertext = buffer.subarray(IV_LENGTH + AUTH_TAG_LENGTH);
    
    // Pr√©pare la cl√© (32 bytes pour AES-256)
    const key = crypto.createHash('sha256').update(API_ENCRYPTION_KEY).digest();
    
    // D√©chiffre
    const decipher = crypto.createDecipheriv(ENCRYPTION_ALGORITHM, key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(ciphertext, null, 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  } catch (err) {
    console.error("[Crypto] Erreur d√©chiffrement:", err.message);
    return null;
  }
}

/**
 * Chiffre une cl√© API en AES-256-GCM
 * Retourne: base64(iv + authTag + ciphertext)
 * Cette fonction est fournie pour r√©f√©rence client
 * @param {string} plainKey - Cl√© en clair
 * @returns {string|null} - Donn√©es chiffr√©es en base64 ou null si erreur
 */
function encryptApiKey(plainKey) {
  if (!API_ENCRYPTION_KEY) {
    console.error("[Crypto] API_ENCRYPTION_KEY non configur√©e");
    return null;
  }
  
  try {
    // G√©n√®re un IV al√©atoire
    const iv = crypto.randomBytes(IV_LENGTH);
    
    // Pr√©pare la cl√© (32 bytes pour AES-256)
    const key = crypto.createHash('sha256').update(API_ENCRYPTION_KEY).digest();
    
    // Chiffre
    const cipher = crypto.createCipheriv(ENCRYPTION_ALGORITHM, key, iv);
    
    let ciphertext = cipher.update(plainKey, 'utf8');
    ciphertext = Buffer.concat([ciphertext, cipher.final()]);
    
    const authTag = cipher.getAuthTag();
    
    // Combine: iv + authTag + ciphertext
    const result = Buffer.concat([iv, authTag, ciphertext]);
    
    return result.toString('base64');
  } catch (err) {
    console.error("[Crypto] Erreur chiffrement:", err.message);
    return null;
  }
}

/**
 * Extrait et d√©chiffre la cl√© API depuis les headers
 * Supporte: X-Encrypted-Key (chiffr√©e) ou X-Api-Key (clair, si pas de cl√© de chiffrement configur√©e)
 * @param {object} req - Request Express
 * @returns {string|null} - Cl√© API d√©chiffr√©e ou null
 */
function extractApiKey(req) {
  // Priorit√© 1: Cl√© chiffr√©e dans X-Encrypted-Key
  const encryptedKey = req.headers['x-encrypted-key'];
  if (encryptedKey) {
    const decrypted = decryptApiKey(encryptedKey);
    if (decrypted) {
      return decrypted;
    }
    console.warn("[Crypto] √âchec d√©chiffrement de X-Encrypted-Key");
    return null;
  }
  
  // Priorit√© 2: Cl√© en clair dans X-Api-Key (seulement si API_ENCRYPTION_KEY non configur√©e)
  const plainKey = req.headers['x-api-key'];
  if (plainKey) {
    if (API_ENCRYPTION_KEY) {
      console.warn("[Crypto] X-Api-Key ignor√©e car le chiffrement est activ√©. Utilisez X-Encrypted-Key.");
      return null;
    }
    return plainKey;
  }
  
  // Priorit√© 3: Param√®tre query 'api_key' (seulement si API_ENCRYPTION_KEY non configur√©e)
  const queryKey = req.query.api_key;
  if (queryKey) {
    if (API_ENCRYPTION_KEY) {
      console.warn("[Crypto] api_key query ignor√©e car le chiffrement est activ√©. Utilisez X-Encrypted-Key.");
      return null;
    }
    return queryKey;
  }
  
  return null;
}

// Log configuration chiffrement au d√©marrage
if (API_ENCRYPTION_KEY) {
  console.log("[Crypto] Chiffrement des cl√©s API activ√© (AES-256-GCM)");
} else {
  console.log("[Crypto] Chiffrement des cl√©s API d√©sactiv√© (API_ENCRYPTION_KEY non d√©finie)");
}

// G√©n√®re un UUID v4
function generateUUID() {
  return crypto.randomUUID();
}

// G√©n√®re un ID de session al√©atoire (21 chars)
function generateSessionId() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < 21; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Nettoie un ID en retirant les pr√©fixes courants ajout√©s par les clients
 * Pr√©fixes support√©s: {source}_, {source}-, ex: bedetheque_12345, olib_OL123W
 * @param {string} id - L'ID √† nettoyer
 * @param {string} source - La source attendue (openlibrary, bedetheque, googlebooks, etc.)
 * @returns {string} - L'ID nettoy√©
 */
function cleanSourceId(id, source) {
  if (!id) return id;
  
  // Pr√©fixes courants par source
  const prefixes = {
    openlibrary: ['olib_', 'openlibrary_', 'ol_'],
    bedetheque: ['bedetheque_', 'bede_', 'bdtheque_'],
    googlebooks: ['googlebooks_', 'gbooks_', 'gb_'],
    comicvine: ['comicvine_', 'cv_'],
    jikan: ['jikan_', 'mal_', 'myanimelist_'],
    mangadex: ['mangadex_', 'mdex_', 'md_']
  };
  
  // Construire le pattern de nettoyage
  const sourcePrefixes = prefixes[source] || [];
  for (const prefix of sourcePrefixes) {
    if (id.toLowerCase().startsWith(prefix.toLowerCase())) {
      return id.substring(prefix.length);
    }
  }
  
  return id;
}

// -----------------------------
// Cr√©er une session FlareSolverr persistante
// -----------------------------
async function createFsrSession() {
  const body = {
    cmd: "sessions.create"
  };

  try {
    const res = await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const json = await res.json();
    if (json.status === "ok" && json.session) {
      console.log("Session FlareSolverr cr√©√©e:", json.session);
      return json.session;
    }
  } catch (err) {
    console.error("Erreur cr√©ation session FSR:", err.message);
  }
  return null;
}

// -----------------------------
// D√©truire une session FlareSolverr
// -----------------------------
async function destroyFsrSession(sessionId) {
  if (!sessionId) return;
  
  const body = {
    cmd: "sessions.destroy",
    session: sessionId
  };

  try {
    await fetch(FSR_BASE, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    console.log("Session FlareSolverr d√©truite:", sessionId);
    // R√©initialiser le timestamp LEGO pour forcer un rafra√Æchissement des cookies
    lastLegoHomeVisit = 0;
  } catch (err) {
    console.error("Erreur destruction session FSR:", err.message);
  }
}

// -----------------------------
// R√©soudre le challenge anti-bot Coleka
// Le site demande de cliquer sur un bouton qui fait un POST √† /verify/ajax.php
// -----------------------------
async function solveColekaChallenge(session, lang = "fr") {
  console.log("[Coleka] R√©solution du challenge anti-bot...");
  
  // Le bouton fait un POST √† /verify/ajax.php avec lang et token
  const verifyUrl = `${COLEKA_BASE_URL}/verify/ajax.php`;
  const postData = `lang=${lang}&token=${Date.now()}`;
  
  try {
    const solution = await fsrRequest("request.post", verifyUrl, session, {
      postData: postData,
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "X-Requested-With": "XMLHttpRequest",
        "Referer": `${COLEKA_BASE_URL}/verify/?lang=${lang}`
      }
    }, 60000);
    
    const responseText = solution.response || "";
    console.log("[Coleka] R√©ponse verify:", responseText.substring(0, 200));
    
    // V√©rifier si la r√©ponse contient success: true
    if (responseText.includes('"success"') && responseText.includes('true')) {
      console.log("[Coleka] ‚úÖ Challenge r√©solu avec succ√®s!");
      return true;
    }
    
    // Essayer de parser la r√©ponse JSON
    try {
      const json = JSON.parse(responseText);
      if (json.success) {
        console.log("[Coleka] ‚úÖ Challenge r√©solu avec succ√®s!");
        return true;
      } else {
        console.log("[Coleka] ‚ùå Challenge √©chou√©:", json.error || "unknown");
        return false;
      }
    } catch (e) {
      console.log("[Coleka] R√©ponse non-JSON, v√©rification par contenu...");
      // Si ce n'est pas du JSON, v√©rifier si on n'a pas d'erreur
      return !responseText.includes("error") && responseText.length > 0;
    }
  } catch (err) {
    console.error("[Coleka] Erreur r√©solution challenge:", err.message);
    return false;
  }
}

// -----------------------------
// Appel FlareSolverr avec session
// -----------------------------
async function fsrRequest(cmd, url, session = null, extraOptions = {}, maxTimeout = 60000) {
  const body = {
    cmd,
    url,
    maxTimeout,
    ...extraOptions
  };

  if (session) {
    body.session = session;
  }

  const res = await fetch(FSR_BASE, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const errorText = await res.text();
    console.error("FlareSolverr HTTP error:", res.status, errorText);
    throw new Error(`FlareSolverr error ${res.status}`);
  }
  
  const json = await res.json();
  
  if (json.status !== "ok") {
    console.error("FlareSolverr status error:", json);
    throw new Error(`FlareSolverr status: ${json.status} - ${json.message || 'unknown error'}`);
  }
  
  if (!json.solution) throw new Error("FlareSolverr: pas de solution");
  
  return json.solution;
}

// -----------------------------
// R√©cup√©rer cookies et token via FSR en visitant la page de recherche
// -----------------------------
async function obtainSessionData(searchTerm, lang = DEFAULT_LOCALE) {
  // Visiter la page de recherche pour obtenir les cookies Cloudflare
  const searchUrl = `https://www.lego.com/${lang.toLowerCase()}/search?q=${encodeURIComponent(searchTerm)}`;
  const sol = await fsrRequest("request.get", searchUrl, fsrSessionId);
  
  const cookies = Array.isArray(sol.cookies) ? sol.cookies : [];
  const html = sol.response || "";
  
  // Chercher le token d'autorisation dans le HTML (souvent dans un script __NEXT_DATA__ ou similaire)
  let authorization = null;
  
  // Chercher dans les cookies
  const authCookie = cookies.find(c => c.name && (c.name.toLowerCase() === "gqauth" || c.name === "authorization"));
  if (authCookie) {
    authorization = authCookie.value;
  }
  
  // Si pas trouv√© dans cookies, chercher dans le HTML
  if (!authorization) {
    // Pattern pour trouver le token JWT dans le HTML
    const jwtPattern = /eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+/g;
    const matches = html.match(jwtPattern);
    if (matches && matches.length > 0) {
      // Prendre le premier token trouv√©
      authorization = matches[0];
    }
  }
  
  return { cookies, authorization, html };
}

// -----------------------------
// Construire string Cookie pour header a partir du tableau cookie FSR
// -----------------------------
function cookiesToHeader(cookieArray = []) {
  if (!Array.isArray(cookieArray) || cookieArray.length === 0) return "";
  return cookieArray.map(c => `${c.name}=${c.value}`).join("; ");
}

// -----------------------------
// Query GraphQL compl√®te (celle fournie par l'utilisateur)
// -----------------------------
const GRAPHQL_QUERY = `query SearchProductsQuery($searchSessionId: Int, $q: String!, $page: Int!, $perPage: Int!, $sort: SortInput, $filters: [Filter!], $visibility: ProductVisibility, $offset: Int) {
  searchProducts(
    searchSession: $searchSessionId
    query: $q
    page: $page
    perPage: $perPage
    filters: $filters
    sort: $sort
    visibility: $visibility
  ) {
    ... on RedirectAction {
      __typename
      url
    }
    ... on SearchProducts {
      __typename
      productResult {
        count
        total
        results {
          __typename
          id
          productCode
          name
          slug
          primaryImage(size: THUMBNAIL)
          baseImgUrl: primaryImage
          ... on SingleVariantProduct {
            variant {
              id
              sku
              salePercentage
              attributes {
                rating
                availabilityStatus
                availabilityText
                canAddToBag
                onSale
                isNew
                ageRange
                pieceCount
              }
              price {
                formattedAmount
                centAmount
                currencyCode
              }
              listPrice {
                formattedAmount
                centAmount
              }
            }
          }
        }
      }
      resultFor
    }
    __typename
  }
}`;

// -----------------------------
// Valider un ID produit LEGO
// Un ID valide est un nombre √† 4-6 chiffres (ex: 75192, 40778, 10497)
// Rejette les IDs avec param√®tres de tracking (?icmp=...), slugs invalides, etc.
// -----------------------------
function isValidLegoProductId(id) {
  if (!id) return false;
  
  // Convertir en string
  const idStr = String(id);
  
  // Rejeter si contient des caract√®res invalides (?, &, =, etc.)
  if (/[?&=]/.test(idStr)) return false;
  
  // Rejeter les slugs de type "tbdholiday-ii-40778" sans productCode num√©rique extrait
  if (idStr.includes('tbd') || idStr.includes('icmp')) return false;
  
  // Extraire le code num√©rique s'il y en a un
  const numericMatch = idStr.match(/^(\d{4,6})$/);
  if (numericMatch) return true;
  
  // Accepter aussi les slugs propres qui se terminent par un ID num√©rique
  // Ex: "millennium-falcon-75192" -> valide si on peut extraire 75192
  const slugMatch = idStr.match(/-(\d{4,6})$/);
  if (slugMatch) return true;
  
  return false;
}

// Nettoyer et extraire l'ID num√©rique d'un produit LEGO
function extractLegoProductId(id) {
  if (!id) return null;
  
  const idStr = String(id);
  
  // Si c'est d√©j√† un ID num√©rique pur
  const numericMatch = idStr.match(/^(\d{4,6})$/);
  if (numericMatch) return numericMatch[1];
  
  // Extraire l'ID num√©rique d'un slug
  const slugMatch = idStr.match(/(\d{4,6})(?:\?|$)/);
  if (slugMatch) return slugMatch[1];
  
  return null;
}

// -----------------------------
// Appel GraphQL via scraping de la page de recherche
// Les r√©sultats sont dans __NEXT_DATA__ de la page
// -----------------------------
async function callLegoGraphql(searchTerm, lang = DEFAULT_LOCALE, retries = MAX_RETRIES, perPage = 24) {
  // V√©rifier le cache
  const cacheKey = `lego:search:${searchTerm}:${lang}:${perPage}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`Tentative ${attempt}/${retries} pour recherche: "${searchTerm}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      // Visiter la page d'accueil LEGO uniquement si les cookies sont p√©rim√©s (toutes les 10 min)
      const now = Date.now();
      if (now - lastLegoHomeVisit > LEGO_SESSION_TTL) {
        console.log("Visite de la page d'accueil LEGO pour rafra√Æchir les cookies...");
        const homeSolution = await fsrRequest("request.get", `https://www.lego.com/${lang.toLowerCase()}/`, fsrSessionId, {}, 30000);
        const cookies = homeSolution.cookies || [];
        console.log(`Obtenu ${cookies.length} cookies`);
        lastLegoHomeVisit = now;
      } else {
        console.log("Cookies LEGO encore valides, skip visite page d'accueil");
      }
      
      // Essayer de faire l'appel GraphQL via FlareSolverr POST
      // L'URL avec les param√®tres query encod√©s
      const variables = {
        q: searchTerm,
        page: 1,
        perPage: Math.min(perPage, 100), // LEGO limite probablement √† 100 max
        sort: { key: "RELEVANCE", direction: "DESC" }
      };
      
      const graphqlPayload = {
        operationName: "SearchProductsQuery",
        variables: variables,
        query: GRAPHQL_QUERY
      };
      
      // Utiliser request.post de FlareSolverr
      console.log("Appel GraphQL via FlareSolverr POST...");
      
      try {
        const graphqlSolution = await fsrRequest("request.post", GRAPHQL_URL, fsrSessionId, {
          postData: JSON.stringify(graphqlPayload)
        }, 60000);
        
        // V√©rifier si on a une r√©ponse valide
        const responseText = graphqlSolution.response || "";
        
        if (responseText.includes('"data"') && responseText.includes('"searchProducts"')) {
          const graphqlResponse = JSON.parse(responseText);
          
          if (graphqlResponse.data?.searchProducts?.productResult) {
            const productResult = graphqlResponse.data.searchProducts.productResult;
            const results = productResult.results || [];
            
            // Mapper et filtrer les produits invalides
            const products = results
              .map(p => ({
                id: extractLegoProductId(p.productCode || p.id) || p.id,
                productCode: extractLegoProductId(p.productCode) || p.productCode,
                name: p.name,
                slug: p.slug,
                thumb: p.primaryImage || null,
                baseImgUrl: p.baseImgUrl || null,
                variant: p.variant || null
              }))
              .filter(p => {
                // Filtrer les produits avec IDs invalides (tracking params, tbd, etc.)
                const isValid = isValidLegoProductId(p.id) || isValidLegoProductId(p.productCode);
                if (!isValid) {
                  console.log(`[LEGO] Filtr√© produit invalide: ${p.id} (${p.name})`);
                }
                return isValid;
              });
            
            console.log(`‚úÖ GraphQL: Trouv√© ${results.length} produits, ${products.length} valides apr√®s filtrage`);
            
            const result = {
              products,
              total: products.length,
              count: products.length,
              resultFor: graphqlResponse.data.searchProducts.resultFor || searchTerm
            };
            
            // Mettre en cache le r√©sultat
            setCache(cacheKey, result);
            return result;
          }
        }
        
        console.log("R√©ponse GraphQL non valide, fallback sur scraping...");
      } catch (graphqlErr) {
        console.log("Erreur GraphQL:", graphqlErr.message, "- fallback sur scraping...");
      }
      
      // Fallback: Scraper la page de recherche
      const searchUrl = `https://www.lego.com/${lang.toLowerCase()}/search?q=${encodeURIComponent(searchTerm)}`;
      console.log("Visite de la page:", searchUrl);
      
      // waitInSeconds permet d'attendre que le JS charge les produits apr√®s le challenge
      const pageSolution = await fsrRequest("request.get", searchUrl, fsrSessionId, {
        waitInSeconds: 2  // Attendre 2 secondes pour le rendu JS des produits
      }, 60000);
      
      const html = pageSolution.response || "";
      console.log("Page re√ßue, taille:", html.length);
      
      let products = [];
      let total = 0;
      let resultFor = searchTerm;
      
      // Chercher les scripts qui contiennent des donn√©es de produits
      // Pattern: productCode, ou des liens vers /product/ ou /fr-fr/product/
      
      // Chercher les donn√©es dans __NEXT_DATA__
      const nextDataMatch = html.match(/<script\s+id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i);
      
      if (nextDataMatch) {
        try {
          const nextData = JSON.parse(nextDataMatch[1]);
          console.log("__NEXT_DATA__ pars√© avec succ√®s");
          
          // V√©rifier si les donn√©es sont dans pageProps
          const pageProps = nextData?.props?.pageProps;
          const apolloState = pageProps?.__APOLLO_STATE__ || pageProps?.initialApolloState || {};
          
          // Chercher les cl√©s qui contiennent des produits
          const allKeys = Object.keys(apolloState);
          const productKeys = allKeys.filter(k => 
            k.startsWith("SingleVariantProduct:") || 
            k.startsWith("Product:") ||
            k.startsWith("MultiVariantProduct:")
          );
          
          console.log(`Trouv√© ${productKeys.length} cl√©s de produits dans Apollo State`);
          
          if (productKeys.length > 0) {
            for (const key of productKeys) {
              const product = apolloState[key];
              if (product && product.name) {
                let variantData = product.variant;
                if (variantData?.__ref) {
                  variantData = apolloState[variantData.__ref];
                }
                
                let priceData = variantData?.price;
                if (priceData?.__ref) {
                  priceData = apolloState[priceData.__ref];
                }
                
                products.push({
                  id: product.id,
                  productCode: product.productCode,
                  name: product.name,
                  slug: product.slug,
                  image: product.primaryImage || product.baseImgUrl || null,  // Alias standard
                  thumb: product.primaryImage || product.baseImgUrl || null,
                  baseImgUrl: product.baseImgUrl || null,
                  variant: variantData ? {
                    id: variantData.id,
                    sku: variantData.sku,
                    price: priceData,
                    attributes: variantData.attributes
                  } : null
                });
              }
            }
          }
        } catch (parseErr) {
          console.error("Erreur parsing __NEXT_DATA__:", parseErr.message);
        }
      }
      
      // M√©thode 2: Si pas de produits dans __NEXT_DATA__, parser le HTML directement
      if (products.length === 0) {
        console.log("Recherche de produits dans le HTML...");
        
        // Chercher les liens produits avec pattern: /product/nom-xxxxx ou les data-test
        // Pattern typique LEGO: href="/fr-fr/product/millennium-falcon-75192"
        const productLinkPattern = /href="\/[a-z]{2}-[a-z]{2}\/product\/([^"]+)"/gi;
        const productMatches = [...html.matchAll(productLinkPattern)];
        
        // Chercher les images des produits - plusieurs formats possibles
        const imgPatterns = [
          /src="(https:\/\/[^"]*(?:lego|brickset)[^"]*\/(?:products|images|set\/assets)[^"]*\.(jpg|png|webp)[^"]*)"/gi,
          /srcset="([^"]*lego[^"]*)/gi,
          /data-src="(https:\/\/[^"]*lego[^"]*\.(jpg|png|webp)[^"]*)"/gi
        ];
        
        // Trouver tous les src d'images
        const allImages = [];
        for (const pattern of imgPatterns) {
          const matches = [...html.matchAll(pattern)];
          for (const m of matches) {
            // D√©coder les entit√©s HTML (&amp; -> &)
            const cleanUrl = m[1].replace(/&amp;/g, '&');
            allImages.push(cleanUrl);
          }
        }
        
        // Cr√©er une map des images par code produit
        const productImages = new Map();
        for (const imgUrl of allImages) {
          // Nettoyer l'URL : garder seulement jusqu'√† l'extension
          const cleanedUrl = imgUrl.replace(/\?(.*?)$/, '');
          
          const codePatterns = [
            /\/(\d{5,6})(?:\/|_|\.|$)/,
            /_(\d{5,6})(?:_|\.|$)/,
            /-(\d{5,6})(?:-|\.|$)/
          ];
          
          for (const cp of codePatterns) {
            const match = cleanedUrl.match(cp);
            if (match && !productImages.has(match[1])) {
              productImages.set(match[1], cleanedUrl);
              break;
            }
          }
        }
        
        // Chercher les noms de produits localis√©s dans le HTML
        // Le nom est dans l'attribut aria-label du lien produit
        const productNames = new Map();
        
        // Pattern: aria-label="Nom du produit" href="/fr-fr/product/slug-xxxxx"
        const ariaLabelPattern = /aria-label="([^"]+)"[^>]*href="\/[a-z]{2}-[a-z]{2}\/product\/([^"]+)"/gi;
        for (const match of html.matchAll(ariaLabelPattern)) {
          const name = match[1].trim();
          const slug = match[2];
          if (slug && name && !productNames.has(slug)) {
            productNames.set(slug, name);
          }
        }
        
        // Pattern alternatif: href avant aria-label
        const ariaLabelPattern2 = /href="\/[a-z]{2}-[a-z]{2}\/product\/([^"]+)"[^>]*aria-label="([^"]+)"/gi;
        for (const match of html.matchAll(ariaLabelPattern2)) {
          const slug = match[1];
          const name = match[2].trim();
          if (slug && name && !productNames.has(slug)) {
            productNames.set(slug, name);
          }
        }
        
        // Pattern pour data-test="product-leaf-title-link" avec aria-label
        const titleLinkPattern = /data-test="product-leaf-title-link"[^>]*aria-label="([^"]+)"[^>]*href="[^"]*\/product\/([^"]+)"/gi;
        for (const match of html.matchAll(titleLinkPattern)) {
          const name = match[1].trim();
          const slug = match[2];
          if (slug && name && !productNames.has(slug)) {
            productNames.set(slug, name);
          }
        }
        
        console.log(`Noms de produits trouv√©s: ${productNames.size}`);
        
        const seenSlugs = new Set();
        for (const match of productMatches) {
          const slug = match[1];
          
          // Ignorer les produits fictifs/publicitaires
          if (slug.includes('mosaic-maker') || slug.includes('mosaic_maker')) {
            continue;
          }
          
          // Ignorer les URLs avec param√®tres de tracking
          if (slug.includes('?') || slug.includes('icmp') || slug.includes('tbd')) {
            console.log(`[LEGO] Filtr√© slug invalide: ${slug}`);
            continue;
          }
          
          if (!seenSlugs.has(slug)) {
            seenSlugs.add(slug);
            // Extraire le code produit du slug (g√©n√©ralement les derniers chiffres)
            const codeMatch = slug.match(/(\d{4,6})(?:\?|$)/);
            const productCode = codeMatch ? codeMatch[1] : null;
            
            // Ne pas ajouter si on ne peut pas extraire un ID valide
            if (!productCode || !isValidLegoProductId(productCode)) {
              console.log(`[LEGO] Filtr√© produit sans ID valide: ${slug}`);
              continue;
            }
            
            // Chercher l'image correspondante
            const thumb = productCode ? productImages.get(productCode) : null;
            
            // Chercher le nom localis√©, sinon utiliser le slug
            const localizedName = productNames.get(slug);
            const name = localizedName || slug.replace(/-/g, ' ').replace(/\d+$/, '').trim();
            
            products.push({
              id: productCode,
              productCode: productCode,
              name: name,
              slug: slug,
              image: thumb,       // Alias standard
              thumb: thumb,
              baseImgUrl: thumb,
              variant: null
            });
          }
        }
        
        console.log(`Trouv√© ${products.length} liens produits dans le HTML (${productImages.size} images)`);
      }
      
      // M√©thode 3: Chercher les balises article ou div avec data-test="product-leaf"
      if (products.length === 0) {
        console.log("Recherche via data-test attributes...");
        
        // Pattern pour les cartes produits LEGO
        const productCardPattern = /data-test="product-leaf"[^>]*>[\s\S]*?<\/article>/gi;
        const cardMatches = html.match(productCardPattern) || [];
        
        for (const card of cardMatches) {
          // Extraire le nom du produit
          const nameMatch = card.match(/data-test="product-leaf-title"[^>]*>([^<]+)/i);
          // Extraire le prix
          const priceMatch = card.match(/data-test="product-price"[^>]*>([^<]+)/i);
          // Extraire l'image
          const imgMatch = card.match(/src="([^"]+lego\.com[^"]+)"/i);
          // Extraire le lien
          const linkMatch = card.match(/href="\/[^"]*\/product\/([^"]+)"/i);
          
          if (nameMatch || linkMatch) {
            const slug = linkMatch ? linkMatch[1] : null;
            const codeMatch = slug ? slug.match(/(\d{4,6})(?:\?|$)/) : null;
            const productId = codeMatch ? codeMatch[1] : null;
            
            // Ne pas ajouter si l'ID n'est pas valide
            if (!productId || !isValidLegoProductId(productId)) {
              console.log(`[LEGO] Filtr√© carte produit invalide: ${slug}`);
              continue;
            }
            
            products.push({
              id: productId,
              productCode: productId,
              name: nameMatch ? nameMatch[1].trim() : slug?.replace(/-/g, ' ') || 'Unknown',
              slug: slug,
              image: imgMatch ? imgMatch[1] : null,  // Alias standard
              thumb: imgMatch ? imgMatch[1] : null,
              price: priceMatch ? priceMatch[1].trim() : null,
              variant: null
            });
          }
        }
        
        console.log(`Trouv√© ${products.length} cartes produits valides`);
      }
      
      // Filtrage final pour s'assurer que tous les produits ont des IDs valides
      const validProducts = products.filter(p => {
        const isValid = isValidLegoProductId(p.id) || isValidLegoProductId(p.productCode);
        if (!isValid) {
          console.log(`[LEGO] Filtr√© produit final invalide: ${p.id} (${p.name})`);
        }
        return isValid;
      });
      
      total = validProducts.length;
      console.log(`‚úÖ Trouv√© ${validProducts.length} produits valides (${products.length - validProducts.length} filtr√©s)`);
      
      const result = { 
        products: validProducts, 
        total,
        count: validProducts.length,
        resultFor,
        htmlSize: html.length
      };
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, result);
      return result;

    } catch (err) {
      lastError = err;
      console.warn(`Erreur tentative ${attempt}: ${err.message}`);
      
      // D√©truire la session en cas d'erreur pour repartir proprement
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      // backoff exponentiel
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// R√©cup√©rer les d√©tails complets d'un produit par son ID
// -----------------------------
async function getProductDetails(productId, lang = DEFAULT_LOCALE, retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `lego:product:${productId}:${lang}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`Tentative ${attempt}/${retries} pour produit: "${productId}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      // Rafra√Æchir les cookies LEGO si p√©rim√©s
      const now = Date.now();
      if (now - lastLegoHomeVisit > LEGO_SESSION_TTL) {
        console.log("Rafra√Æchissement cookies LEGO...");
        await fsrRequest("request.get", `https://www.lego.com/${lang.toLowerCase()}/`, fsrSessionId, {}, 30000);
        lastLegoHomeVisit = now;
      }
      
      // Construire l'URL du produit
      // LEGO utilise le format: /fr-fr/product/slug-XXXXX ou juste /fr-fr/product/XXXXX
      const productUrl = `https://www.lego.com/${lang.toLowerCase()}/product/${productId}`;
      console.log("Visite de la page produit:", productUrl);
      
      // Attendre le rendu JavaScript
      const pageSolution = await fsrRequest("request.get", productUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      const html = pageSolution.response || "";
      console.log("Page produit re√ßue, taille:", html.length);
      
      // V√©rifier si le produit existe - chercher des √©l√©ments sp√©cifiques de la page produit
      // plut√¥t que de chercher "404" qui peut appara√Ætre ailleurs
      const isProductPage = html.includes('product-overview') || 
                            html.includes('ProductOverview') ||
                            html.includes('data-test="product-') ||
                            html.includes('/product/' + productId);
      
      if (!isProductPage && (html.includes("Cette page n'existe pas") || html.length < 100000)) {
        throw new Error("Produit non trouv√©");
      }
      
      // Extraire les informations du produit
      const product = {
        id: productId,
        productCode: productId,
        name: null,
        description: null,
        images: [],
        videos: [],
        ageRange: null,
        pieceCount: null,
        minifiguresCount: null,
        price: null,
        listPrice: null,
        availability: null,
        availabilityText: null,
        rating: null,
        reviewCount: null,
        themes: [],
        url: productUrl
      };
      
      // --- Extraction du nom ---
      // Pattern 1: balise h1 avec data-test="product-overview-name"
      const namePatterns = [
        /<h1[^>]*data-test="product-overview-name"[^>]*>([^<]+)<\/h1>/i,
        /<h1[^>]*class="[^"]*ProductOverviewstyles[^"]*"[^>]*>([^<]+)<\/h1>/i,
        /<span[^>]*data-test="product-overview-name"[^>]*>([^<]+)<\/span>/i,
        /<h1[^>]*>([^<]+)<\/h1>/i
      ];
      
      for (const pattern of namePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.name = match[1].trim();
          break;
        }
      }
      
      // --- Extraction de la description ---
      const descPatterns = [
        /<p[^>]*data-test="product-overview-description"[^>]*>([\s\S]*?)<\/p>/i,
        /<div[^>]*class="[^"]*ProductDescription[^"]*"[^>]*>([\s\S]*?)<\/div>/i
      ];
      
      for (const pattern of descPatterns) {
        const match = html.match(pattern);
        if (match) {
          // Nettoyer le HTML de la description
          product.description = match[1].replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
          break;
        }
      }
      
      // --- Extraction des images (haute r√©solution, uniques) ---
      // Chercher toutes les images du produit
      const imagePatterns = [
        /src="(https:\/\/[^"]*(?:lego\.com|cloudfront)[^"]*\/(?:products|set\/assets)[^"]*\.(jpg|png|webp)[^"]*)"/gi,
        /srcset="([^"]+)"/gi,
        /data-src="(https:\/\/[^"]*lego[^"]*\.(jpg|png|webp)[^"]*)"/gi
      ];
      
      // On utilise un Set bas√© sur le nom de base de l'image (sans param√®tres)
      const seenImageBases = new Set();
      
      for (const pattern of imagePatterns) {
        const matches = [...html.matchAll(pattern)];
        for (const m of matches) {
          let imgUrl = m[1].replace(/&amp;/g, '&');
          
          // Pour srcset, prendre chaque URL
          const urlsToProcess = [];
          if (imgUrl.includes(',')) {
            const srcsetParts = imgUrl.split(',').map(s => s.trim());
            for (const part of srcsetParts) {
              urlsToProcess.push(part.split(' ')[0]);
            }
          } else {
            urlsToProcess.push(imgUrl);
          }
          
          for (const url of urlsToProcess) {
            // Nettoyer l'URL : garder seulement jusqu'√† l'extension
            const cleanUrl = url.replace(/\?(.*?)$/, '');
            
            // Extraire le nom du fichier
            const fileNameMatch = cleanUrl.match(/\/([^\/]+\.(jpg|png|webp))$/i);
            if (!fileNameMatch) continue;
            
            const fileName = fileNameMatch[1];
            const baseName = fileName.toLowerCase();
            
            // Filtrer : garder seulement les images qui contiennent l'ID du produit dans le nom
            // Ex: 75192_Prod.png, 75192_alt1.jpg, 75192_minifig_lineup.png
            // Exclure : thumbnail, logo, promo, autres produits
            const isProductImage = fileName.includes(productId) && 
                                   !baseName.includes('thumbnail') &&
                                   !baseName.includes('logo');
            
            if (isProductImage && !seenImageBases.has(baseName)) {
              seenImageBases.add(baseName);
              product.images.push(cleanUrl);
            }
          }
        }
      }
      
      // --- Extraction des vid√©os ---
      const videoPatterns = [
        /src="(https:\/\/[^"]*(?:youtube|vimeo|lego)[^"]*(?:embed|video)[^"]*)"/gi,
        /data-video-id="([^"]+)"/gi,
        /"videoId"\s*:\s*"([^"]+)"/gi,
        /youtube\.com\/embed\/([^"?\s]+)/gi
      ];
      
      const seenVideos = new Set();
      
      for (const pattern of videoPatterns) {
        const matches = [...html.matchAll(pattern)];
        for (const m of matches) {
          let videoUrl = m[1];
          
          // Si c'est un ID YouTube, construire l'URL
          if (videoUrl.match(/^[a-zA-Z0-9_-]{11}$/)) {
            videoUrl = `https://www.youtube.com/watch?v=${videoUrl}`;
          }
          
          if (!seenVideos.has(videoUrl)) {
            seenVideos.add(videoUrl);
            product.videos.push(videoUrl);
          }
        }
      }
      
      // --- Extraction de l'√¢ge recommand√© ---
      const agePatterns = [
        /data-test="product-details-ages"[^>]*>([^<]+)</i,
        /"ageRange"\s*:\s*"([^"]+)"/i,
        /√Çge[s]?\s*:?\s*(\d+\+?)/i,
        /Age[s]?\s*:?\s*(\d+\+?)/i,
        /<span[^>]*>(\d+\+)<\/span>/i
      ];
      
      for (const pattern of agePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.ageRange = match[1].trim();
          break;
        }
      }
      
      // --- Extraction du nombre de pi√®ces ---
      const piecePatterns = [
        /data-test="product-details-pieces"[^>]*>([^<]+)</i,
        /"pieceCount"\s*:\s*(\d+)/i,
        /(\d+)\s*(?:pi√®ces?|pieces?|√©l√©ments?)/i,
        /Pi√®ces?\s*:?\s*(\d[\d\s]*)/i,
        /Pieces?\s*:?\s*(\d[\d\s]*)/i
      ];
      
      for (const pattern of piecePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.pieceCount = parseInt(match[1].replace(/\s/g, ''), 10);
          break;
        }
      }
      
      // --- Extraction du nombre de figurines ---
      const minifigPatterns = [
        /data-test="product-details-minifigures"[^>]*>([^<]+)</i,
        /"minifiguresCount"\s*:\s*(\d+)/i,
        /(\d+)\s*(?:figurines?|minifig(?:ure)?s?)/i,
        /Minifigurines?\s*:?\s*(\d+)/i
      ];
      
      for (const pattern of minifigPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.minifiguresCount = parseInt(match[1], 10);
          break;
        }
      }
      
      // --- Extraction du prix ---
      const pricePatterns = [
        /data-test="product-price"[^>]*>([^<]+)</i,
        /data-test="product-price-sale"[^>]*>([^<]+)</i,
        /"formattedAmount"\s*:\s*"([^"]+)"/i,
        /"centAmount"\s*:\s*(\d+)/i,
        /Prix\s*:?\s*([\d,.\s]+\s*‚Ç¨)/i,
        /([\d,.\s]+\s*‚Ç¨)/i
      ];
      
      for (const pattern of pricePatterns) {
        const match = html.match(pattern);
        if (match) {
          // Nettoyer les entit√©s HTML
          product.price = match[1].trim().replace(/&nbsp;/g, ' ').replace(/&#160;/g, ' ');
          break;
        }
      }
      
      // Prix original (si en promo)
      const listPricePatterns = [
        /data-test="product-price-list"[^>]*>([^<]+)</i,
        /<s[^>]*>([^<]*‚Ç¨[^<]*)<\/s>/i
      ];
      
      for (const pattern of listPricePatterns) {
        const match = html.match(pattern);
        if (match) {
          product.listPrice = match[1].trim();
          break;
        }
      }
      
      // --- Extraction de la disponibilit√© ---
      const availabilityPatterns = [
        /data-test="product-overview-availability"[^>]*>([^<]+)</i,
        /"availabilityStatus"\s*:\s*"([^"]+)"/i,
        /"availabilityText"\s*:\s*"([^"]+)"/i,
        /Disponibilit√©\s*:?\s*([^<]+)</i,
        /Availability\s*:?\s*([^<]+)</i
      ];
      
      for (const pattern of availabilityPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.availabilityText = match[1].trim();
          // D√©duire le statut
          const text = product.availabilityText.toLowerCase();
          if (text.includes('disponible') || text.includes('available') || text.includes('en stock')) {
            product.availability = 'AVAILABLE';
          } else if (text.includes('√©puis√©') || text.includes('out of stock') || text.includes('indisponible')) {
            product.availability = 'OUT_OF_STOCK';
          } else if (text.includes('bient√¥t') || text.includes('coming soon') || text.includes('prochainement')) {
            product.availability = 'COMING_SOON';
          } else if (text.includes('retir√©') || text.includes('retired') || text.includes('fin de s√©rie')) {
            product.availability = 'RETIRED';
          } else {
            product.availability = 'UNKNOWN';
          }
          break;
        }
      }
      
      // --- Extraction de la note et nombre d'avis ---
      const ratingPatterns = [
        /data-test="product-rating"[^>]*>([^<]+)</i,
        /"rating"\s*:\s*([\d.]+)/i,
        /(\d+(?:[.,]\d+)?)\s*(?:\/\s*5|sur\s*5|√©toiles?|stars?)/i
      ];
      
      for (const pattern of ratingPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.rating = parseFloat(match[1].replace(',', '.'));
          break;
        }
      }
      
      const reviewPatterns = [
        /data-test="product-review-count"[^>]*>([^<]+)</i,
        /"reviewCount"\s*:\s*(\d+)/i,
        /(\d+)\s*(?:avis|reviews?|√©valuations?)/i
      ];
      
      for (const pattern of reviewPatterns) {
        const match = html.match(pattern);
        if (match) {
          product.reviewCount = parseInt(match[1], 10);
          break;
        }
      }
      
      // --- Essayer d'extraire depuis __NEXT_DATA__ pour des donn√©es plus structur√©es ---
      const nextDataMatch = html.match(/<script\s+id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i);
      
      if (nextDataMatch) {
        try {
          const nextData = JSON.parse(nextDataMatch[1]);
          const pageProps = nextData?.props?.pageProps;
          const apolloState = pageProps?.__APOLLO_STATE__ || pageProps?.initialApolloState || {};
          
          // Chercher les donn√©es du produit dans Apollo State
          for (const key of Object.keys(apolloState)) {
            if (key.startsWith("SingleVariantProduct:") || key.startsWith("Product:") || key.startsWith("MultiVariantProduct:")) {
              const prodData = apolloState[key];
              
              if (prodData && (prodData.productCode === productId || key.includes(productId))) {
                // Nom
                if (prodData.name && !product.name) {
                  product.name = prodData.name;
                }
                
                // R√©soudre les r√©f√©rences
                if (prodData.variant?.__ref) {
                  const variantData = apolloState[prodData.variant.__ref];
                  if (variantData) {
                    // Attributs
                    if (variantData.attributes) {
                      const attrs = variantData.attributes;
                      if (attrs.rating && !product.rating) product.rating = attrs.rating;
                      if (attrs.availabilityStatus && !product.availability) product.availability = attrs.availabilityStatus;
                      if (attrs.availabilityText && !product.availabilityText) product.availabilityText = attrs.availabilityText;
                      if (attrs.ageRange && !product.ageRange) product.ageRange = attrs.ageRange;
                      if (attrs.pieceCount && !product.pieceCount) product.pieceCount = attrs.pieceCount;
                    }
                    
                    // Prix
                    if (variantData.price?.__ref) {
                      const priceData = apolloState[variantData.price.__ref];
                      if (priceData?.formattedAmount && !product.price) {
                        product.price = priceData.formattedAmount;
                      }
                    } else if (variantData.price?.formattedAmount && !product.price) {
                      product.price = variantData.price.formattedAmount;
                    }
                  }
                }
                
                break;
              }
            }
          }
        } catch (parseErr) {
          console.warn("Erreur parsing __NEXT_DATA__ pour produit:", parseErr.message);
        }
      }
      
      console.log(`‚úÖ Produit r√©cup√©r√©: ${product.name || productId}`);
      console.log(`   Images: ${product.images.length}, Vid√©os: ${product.videos.length}`);
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, product);
      return product;

    } catch (err) {
      lastError = err;
      console.warn(`Erreur tentative ${attempt}: ${err.message}`);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// R√©cup√©rer les manuels d'instructions d'un produit par son ID
// -----------------------------
async function getBuildingInstructions(productId, lang = DEFAULT_LOCALE, retries = MAX_RETRIES) {
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`Tentative ${attempt}/${retries} pour instructions: "${productId}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      // Rafra√Æchir les cookies LEGO si p√©rim√©s
      const now = Date.now();
      if (now - lastLegoHomeVisit > LEGO_SESSION_TTL) {
        console.log("Rafra√Æchissement cookies LEGO...");
        await fsrRequest("request.get", `https://www.lego.com/${lang.toLowerCase()}/`, fsrSessionId, {}, 30000);
        lastLegoHomeVisit = now;
      }
      
      // Construire l'URL des instructions
      const instructionsUrl = `https://www.lego.com/${lang.toLowerCase()}/service/building-instructions/${productId}`;
      console.log("Visite de la page instructions:", instructionsUrl);
      
      // Attendre le rendu JavaScript
      const pageSolution = await fsrRequest("request.get", instructionsUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      const html = pageSolution.response || "";
      console.log("Page instructions re√ßue, taille:", html.length);
      
      // V√©rifier si la page existe
      const isInstructionsPage = html.includes('building-instructions') || 
                                  html.includes('BuildingInstructions') ||
                                  html.includes('.pdf');
      
      if (!isInstructionsPage && (html.includes("Cette page n'existe pas") || html.length < 50000)) {
        throw new Error("Instructions non trouv√©es pour ce produit");
      }
      
      // Structure de retour
      const instructions = {
        id: productId,
        productCode: productId,
        name: null,
        ageRange: null,
        pieceCount: null,
        year: null,
        manuals: [],
        url: instructionsUrl
      };
      
      // --- Chercher dans __NEXT_DATA__ ---
      const nextDataMatch = html.match(/<script\s+id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/i);
      
      if (nextDataMatch) {
        try {
          const nextData = JSON.parse(nextDataMatch[1]);
          const pageProps = nextData?.props?.pageProps;
          
          // Chercher les donn√©es du produit
          const productData = pageProps?.product || pageProps?.data?.product;
          
          if (productData) {
            // Nom du produit
            if (productData.name) {
              instructions.name = productData.name;
            }
            
            // √Çge
            if (productData.ageRange) {
              instructions.ageRange = productData.ageRange;
            }
            
            // Nombre de pi√®ces
            if (productData.pieceCount) {
              instructions.pieceCount = parseInt(productData.pieceCount, 10);
            }
          }
          
          // Chercher les instructions de montage
          const buildingInstructions = pageProps?.buildingInstructions || 
                                       pageProps?.data?.buildingInstructions ||
                                       pageProps?.instructions ||
                                       pageProps?.data?.instructions;
          
          if (Array.isArray(buildingInstructions)) {
            for (const instr of buildingInstructions) {
              if (instr.pdfUrl || instr.pdfLocation || instr.url) {
                instructions.manuals.push({
                  id: instr.id || null,
                  description: instr.description || instr.name || null,
                  pdfUrl: instr.pdfUrl || instr.pdfLocation || instr.url,
                  sequence: instr.sequence || instr.sequenceNumber || null
                });
              }
            }
          }
          
          // Chercher aussi dans Apollo State
          const apolloState = pageProps?.__APOLLO_STATE__ || pageProps?.initialApolloState || {};
          
          for (const key of Object.keys(apolloState)) {
            const data = apolloState[key];
            
            // Chercher les donn√©es produit
            if (key.startsWith("Product:") || key.startsWith("SingleVariantProduct:") || key.includes(productId)) {
              if (data.name && !instructions.name) {
                instructions.name = data.name;
              }
              if (data.ageRange && !instructions.ageRange) {
                instructions.ageRange = data.ageRange;
              }
              if (data.pieceCount && !instructions.pieceCount) {
                instructions.pieceCount = parseInt(data.pieceCount, 10);
              }
              
              // Chercher dans les attributs du variant
              if (data.variant?.__ref) {
                const variantData = apolloState[data.variant.__ref];
                if (variantData?.attributes) {
                  const attrs = variantData.attributes;
                  if (attrs.ageRange && !instructions.ageRange) {
                    instructions.ageRange = attrs.ageRange;
                  }
                  if (attrs.pieceCount && !instructions.pieceCount) {
                    instructions.pieceCount = parseInt(attrs.pieceCount, 10);
                  }
                }
              }
            }
            
            // Chercher dans ProductAttributes directement
            if (key.includes("ProductAttributes") || key.includes("VariantAttributes")) {
              if (data.ageRange && !instructions.ageRange) {
                instructions.ageRange = data.ageRange;
              }
              if (data.pieceCount && !instructions.pieceCount) {
                instructions.pieceCount = parseInt(data.pieceCount, 10);
              }
            }
            
            // Chercher les instructions
            if (key.includes("BuildingInstruction") || (data && data.pdfLocation)) {
              if (data.pdfLocation && !instructions.manuals.find(m => m.pdfUrl === data.pdfLocation)) {
                instructions.manuals.push({
                  id: data.id || key,
                  description: data.description || data.name || null,
                  pdfUrl: data.pdfLocation,
                  sequence: data.sequence || data.sequenceNumber || null
                });
              }
            }
          }
          
        } catch (parseErr) {
          console.error("Erreur parsing __NEXT_DATA__:", parseErr.message);
        }
      }
      
      // --- Extraction depuis le HTML si pas trouv√© dans __NEXT_DATA__ ---
      
      // Nom du produit
      if (!instructions.name) {
        const namePatterns = [
          /<h1[^>]*>([^<]+)<\/h1>/i,
          /data-test="[^"]*product[^"]*name[^"]*"[^>]*>([^<]+)</i,
          /"name"\s*:\s*"([^"]+)"/i
        ];
        
        for (const pattern of namePatterns) {
          const match = html.match(pattern);
          if (match && !match[1].includes('LEGO')) {
            instructions.name = match[1].trim();
            break;
          }
        }
      }
      
      // √Çge - chercher d'abord dans les donn√©es structur√©es
      if (!instructions.ageRange) {
        const agePatterns = [
          /"ageRange"\s*:\s*"([^"]+)"/i,
          // Pattern pour: <p class="...productDetails...">18+<!-- --> <span...
          /<p[^>]*productDetails[^>]*>(\d{1,2}\+)/i,
          // Pattern pour: class="_setId__productDetails...">18+
          /class="[^"]*productDetails[^"]*">(\d{1,2}\+)/i,
          /data-test="[^"]*age[^"]*"[^>]*>(\d{1,2}\+)/i,
          /√Çge[s]?\s*:?\s*(\d{1,2}\+)/i,
          /Ages?\s*:?\s*(\d{1,2}\+)/i
        ];
        
        for (const pattern of agePatterns) {
          const match = html.match(pattern);
          if (match) {
            instructions.ageRange = match[1];
            break;
          }
        }
      }
      
      // Nombre de pi√®ces
      if (!instructions.pieceCount) {
        const piecePatterns = [
          /"pieceCount"\s*:\s*(\d+)/i,
          /(\d+)\s*(?:pi√®ces?|pieces?|√©l√©ments?)/i
        ];
        
        for (const pattern of piecePatterns) {
          const match = html.match(pattern);
          if (match) {
            instructions.pieceCount = parseInt(match[1], 10);
            break;
          }
        }
      }
      
      // Ann√©e de sortie
      if (!instructions.year) {
        const yearPatterns = [
          /"launchDate"\s*:\s*"(\d{4})/i,
          /"year"\s*:\s*(\d{4})/i,
          // Pattern pour: <p class="...productDetails...">Ann√©e : 2024</p>
          /<p[^>]*productDetails[^>]*>Ann√©e\s*:\s*(\d{4})/i,
          /class="[^"]*productDetails[^"]*">Ann√©e\s*:\s*(\d{4})/i,
          /Year\s*:\s*(\d{4})/i
        ];
        
        for (const pattern of yearPatterns) {
          const match = html.match(pattern);
          if (match) {
            instructions.year = parseInt(match[1], 10);
            break;
          }
        }
      }
      
      // Chercher les liens PDF directement dans le HTML
      if (instructions.manuals.length === 0) {
        // Pattern pour les URLs de PDF
        const pdfPatterns = [
          /href="(https?:\/\/[^"]+\.pdf)"/gi,
          /src="(https?:\/\/[^"]+\.pdf)"/gi,
          /"pdfUrl"\s*:\s*"([^"]+\.pdf)"/gi,
          /"pdfLocation"\s*:\s*"([^"]+\.pdf)"/gi,
          /"url"\s*:\s*"(https?:\/\/[^"]+\.pdf)"/gi,
          /(https?:\/\/[^"\s]+\.pdf)/gi
        ];
        
        const seenPdfs = new Set();
        
        for (const pattern of pdfPatterns) {
          const matches = [...html.matchAll(pattern)];
          for (const m of matches) {
            let pdfUrl = m[1].replace(/\\u002F/g, '/').replace(/\\/g, '');
            
            // Nettoyer l'URL
            if (pdfUrl.startsWith('//')) {
              pdfUrl = 'https:' + pdfUrl;
            }
            
            if (!seenPdfs.has(pdfUrl)) {
              seenPdfs.add(pdfUrl);
              
              // Extraire une description du nom du fichier
              const fileNameMatch = pdfUrl.match(/\/([^\/]+)\.pdf$/i);
              const fileName = fileNameMatch ? fileNameMatch[1] : null;
              
              // Filtrer les PDFs qui ne sont pas des manuels d'instructions
              // Exclure : documents l√©gaux, rapports, policies, etc.
              const excludePatterns = [
                /slavery/i, /transparency/i, /statement/i, /policy/i,
                /report/i, /annual/i, /legal/i, /terms/i, /privacy/i,
                /cookie/i, /compliance/i, /corporate/i
              ];
              
              const isExcluded = excludePatterns.some(pattern => pattern.test(fileName || pdfUrl));
              
              // V√©rifier que c'est bien un manuel (contient product.bi ou l'ID produit ou est num√©rique)
              const isManual = pdfUrl.includes('product.bi') || 
                               pdfUrl.includes(productId) || 
                               /^\d+$/.test(fileName);
              
              if (!isExcluded && isManual) {
                // Extraire le num√©ro de s√©quence du nom de fichier si possible
                // Ex: 6481239.pdf, 10333_1.pdf, 10333_BK1.pdf, 10333_BK2.pdf
                let sequence = null;
                const seqMatch = fileName?.match(/_(?:BK)?(\d+)(?:_|$)/i);
                if (seqMatch) {
                  sequence = parseInt(seqMatch[1], 10);
                }
                
                instructions.manuals.push({
                  id: fileName || seenPdfs.size.toString(),
                  description: fileName ? `Manuel ${fileName}` : null,
                  pdfUrl: pdfUrl,
                  sequence: sequence
                });
              }
            }
          }
        }
      }
      
      // Trier les manuels par s√©quence
      instructions.manuals.sort((a, b) => {
        if (a.sequence === null && b.sequence === null) return 0;
        if (a.sequence === null) return 1;
        if (b.sequence === null) return -1;
        return a.sequence - b.sequence;
      });
      
      console.log(`‚úÖ Trouv√© ${instructions.manuals.length} manuels pour ${productId}`);
      
      return instructions;

    } catch (err) {
      lastError = err;
      console.warn(`Erreur tentative ${attempt}: ${err.message}`);
      
      // D√©truire la session en cas d'erreur pour repartir proprement
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      // backoff exponentiel
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// R√©cup√©rer les d√©tails d'un item Lulu-Berlu
// -----------------------------
async function getLuluBerluItemDetails(itemId, retries = MAX_RETRIES) {
  // V√©rifier le cache
  const cacheKey = `luluberlu:item:${itemId}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    try {
      console.log(`[LuluBerlu] Tentative ${attempt}/${retries} pour item: "${itemId}"`);
      
      // Cr√©er une session FSR si elle n'existe pas
      if (!fsrSessionId) {
        fsrSessionId = await createFsrSession();
      }
      
      if (!fsrSessionId) {
        throw new Error("Impossible de cr√©er une session FlareSolverr");
      }
      
      // Construire l'URL de l'item
      // itemId peut √™tre:
      // - une URL compl√®te (https://www.lulu-berlu.com/...)
      // - un chemin relatif (final-fantasy-viii-bandai-figurine-15cm-squall-leonhart-loose-a78643.html)
      // - juste l'ID num√©rique (78643)
      let itemUrl;
      if (itemId.startsWith('http')) {
        itemUrl = itemId;
      } else if (itemId.includes('.html')) {
        itemUrl = itemId.startsWith('/') ? `${LULUBERLU_BASE_URL}${itemId}` : `${LULUBERLU_BASE_URL}/${itemId}`;
      } else if (/^\d+$/.test(itemId)) {
        // Juste l'ID num√©rique - on ne peut pas acc√©der directement car Lulu-Berlu
        // n√©cessite le slug complet dans l'URL. On essaie une recherche mais c'est peu fiable.
        console.log(`[LuluBerlu] ID num√©rique d√©tect√©, tentative de recherche...`);
        
        // Essayer de chercher avec le nom de l'article (pas l'ID)
        // Les r√©sultats de recherche contiennent l'ID dans les attributs
        // Utiliser la recherche /luluberlu/search pour trouver l'article d'abord
        throw new Error("ID seul non support√©. Utilisez l'URL compl√®te du produit ou son chemin (ex: /final-fantasy-viii-bandai-figurine-15cm-squall-leonhart-loose-a78643.html)");
      } else {
        // Essayer comme chemin relatif
        itemUrl = `${LULUBERLU_BASE_URL}/${itemId}`;
      }
      
      console.log(`[LuluBerlu] Visite de: ${itemUrl}`);
      
      const pageSolution = await fsrRequest("request.get", itemUrl, fsrSessionId, {
        waitInSeconds: 1  // R√©duit de 2s √† 1s
      }, 45000);  // Timeout r√©duit
      
      const html = pageSolution.response || "";
      console.log(`[LuluBerlu] Page item re√ßue, taille: ${html.length}`);
      
      // V√©rifier si la page existe
      if (html.includes("Page non trouv√©e") || html.includes("Error 404") || html.length < 5000) {
        throw new Error("Item non trouv√©");
      }
      
      // Structure de retour
      const item = {
        id: itemId,
        name: null,
        url: itemUrl,
        images: [],
        description: null,
        brand: null,
        reference: null,
        price: null,
        availability: null,
        attributes: {},
        source: "lulu-berlu"
      };
      
      // Extraire l'ID depuis le HTML si on ne l'a pas
      const idMatch = html.match(/id_article"\s*value="(\d+)"/i);
      if (idMatch) {
        item.id = idMatch[1];
      }
      
      // --- Extraction du nom ---
      const namePatterns = [
        /<title>([^<]+)<\/title>/i,
        /<h1[^>]*>([^<]+)<\/h1>/i,
        /<meta[^>]*property="og:title"[^>]*content="([^"]+)"/i
      ];
      
      for (const pattern of namePatterns) {
        const match = html.match(pattern);
        if (match) {
          item.name = match[1].trim().replace(/ - Lulu Berlu$/, '').replace(/\s+/g, ' ');
          if (item.name.length > 0) break;
        }
      }
      
      // --- Extraction des images ---
      // Extraire la section principale du produit (fa_bloc-image)
      // jusqu'√† fa_bloc-details pour √©viter les images des produits recommand√©s
      const mainImageSection = html.match(/<div[^>]*class="[^"]*fa_bloc-image[^"]*"[^>]*>([\s\S]*?)<div[^>]*class="[^"]*fa_bloc-details[^"]*"/i);
      const imageHtml = mainImageSection ? mainImageSection[1] : '';
      
      const seenImages = new Set();
      
      // Extraire l'image principale depuis og:image (la plus fiable)
      const ogImageMatch = html.match(/<meta[^>]*property="og:image"[^>]*content="([^"]+)"/i);
      if (ogImageMatch) {
        let imgUrl = ogImageMatch[1];
        // Convertir en grande taille
        imgUrl = imgUrl.replace('-moyenne.', '-grande.');
        if (!seenImages.has(imgUrl)) {
          seenImages.add(imgUrl);
          item.images.push(imgUrl);
        }
      }
      
      // Chercher les images suppl√©mentaires dans la section principale
      if (imageHtml) {
        // Pattern pour les liens href vers les images grandes (dans le carrousel)
        // Format: href="https://...p-image-552834-grande.jpg"
        const hrefPattern = /href="([^"]*p-image-\d+-grande\.[^"]+)"/gi;
        const hrefMatches = [...imageHtml.matchAll(hrefPattern)];
        
        for (const m of hrefMatches) {
          let imgUrl = m[1];
          if (!imgUrl.startsWith('http')) {
            imgUrl = LULUBERLU_BASE_URL + (imgUrl.startsWith('/') ? '' : '/') + imgUrl;
          }
          if (!seenImages.has(imgUrl)) {
            seenImages.add(imgUrl);
            item.images.push(imgUrl);
          }
        }
        
        // Pattern pour data-url-img (images du conteneur principal)
        const dataUrlPattern = /data-url-img="([^"]+)"/gi;
        const dataMatches = [...imageHtml.matchAll(dataUrlPattern)];
        
        for (const m of dataMatches) {
          let imgUrl = m[1];
          if (imgUrl.includes('favicon') || imgUrl.includes('icon') || imgUrl.includes('logo')) continue;
          
          if (!imgUrl.startsWith('http')) {
            imgUrl = LULUBERLU_BASE_URL + (imgUrl.startsWith('/') ? '' : '/') + imgUrl;
          }
          
          // Convertir les URLs moyennes en grandes
          imgUrl = imgUrl.replace('-moyenne.', '-grande.');
          
          if (!seenImages.has(imgUrl)) {
            seenImages.add(imgUrl);
            item.images.push(imgUrl);
          }
        }
      }
      
      // --- Extraction du prix ---
      const pricePatterns = [
        /itemprop="price"[^>]*content="([^"]+)"/i,
        /(\d+[.,]\d+)\s*(?:‚Ç¨|&euro;|EUR)/i
      ];
      
      for (const pattern of pricePatterns) {
        const match = html.match(pattern);
        if (match) {
          item.price = parseFloat(match[1].replace(',', '.'));
          break;
        }
      }
      
      // --- Extraction de la r√©f√©rence (SKU) ---
      const skuMatch = html.match(/itemprop="sku"[^>]*content="([^"]+)"/i);
      if (skuMatch) {
        item.reference = skuMatch[1];
      } else {
        const refMatch = html.match(/R√©f\.\s*:?\s*([A-Z0-9]+)/i);
        if (refMatch) {
          item.reference = refMatch[1];
        }
      }
      
      // --- Extraction de la marque ---
      const brandPatterns = [
        /itemprop="brand"[^>]*content="([^"]+)"/i,
        /<span[^>]*itemprop="brand"[^>]*>([^<]+)<\/span>/i,
        /class="bp_marque"[^>]*>[\s\S]*?<a[^>]*>([^<]+)<\/a>/i
      ];
      
      for (const pattern of brandPatterns) {
        const match = html.match(pattern);
        if (match) {
          item.brand = match[1].trim();
          break;
        }
      }
      
      // --- Extraction de la disponibilit√© ---
      const availabilityPatterns = [
        /itemprop="availability"[^>]*content="([^"]+)"/i,
        /<span class="articleDispo">[\s\S]*?>(En stock|Non disponible|√âpuis√©|Pr√©commande)/i
      ];
      
      for (const pattern of availabilityPatterns) {
        const match = html.match(pattern);
        if (match) {
          const status = match[1].toLowerCase();
          if (status.includes('instock') || status.includes('en stock')) {
            item.availability = 'in_stock';
          } else if (status.includes('preorder') || status.includes('pr√©commande')) {
            item.availability = 'preorder';
          } else {
            item.availability = 'out_of_stock';
          }
          break;
        }
      }
      
      // --- Extraction de la description ---
      const descPatterns = [
        /<meta[^>]*name="description"[^>]*content="([^"]+)"/i,
        /<meta[^>]*property="og:description"[^>]*content="([^"]+)"/i
      ];
      
      for (const pattern of descPatterns) {
        const match = html.match(pattern);
        if (match) {
          // D√©coder les entit√©s HTML
          item.description = match[1]
            .replace(/&nbsp;/g, ' ')
            .replace(/&amp;/g, '&')
            .replace(/&eacute;/g, '√©')
            .replace(/&egrave;/g, '√®')
            .replace(/&agrave;/g, '√†')
            .replace(/&#(\d+);/g, (m, c) => String.fromCharCode(c))
            .trim();
          break;
        }
      }
      
      // --- Extraction des attributs depuis la description ---
      if (item.description) {
        // Parser les attributs comme "Type : Figurine articul√©e Mati√®re : Plastique Taille : 15cm"
        const attrPattern = /(Type|Mati√®re|Taille|Origine|Ann√©e|Condition)\s*:\s*([^:]+?)(?=(?:Type|Mati√®re|Taille|Origine|Ann√©e|Condition)\s*:|$)/gi;
        const attrMatches = [...item.description.matchAll(attrPattern)];
        
        for (const m of attrMatches) {
          const key = m[1].toLowerCase();
          const value = m[2].trim();
          item.attributes[key] = value;
          
          // Mapper les attributs sp√©cifiques
          if (key === 'ann√©e') {
            item.year = value;
          }
        }
      }
      
      // --- Extraction suppl√©mentaire des caract√©ristiques depuis le HTML ---
      const charPattern = /<div[^>]*>(?:Type|Mati√®re|Taille|Origine|Ann√©e|Condition)\s*:\s*([^<]+)<\/div>/gi;
      const charMatches = [...html.matchAll(charPattern)];
      
      for (const m of charMatches) {
        const fullMatch = m[0];
        const keyMatch = fullMatch.match(/(Type|Mati√®re|Taille|Origine|Ann√©e|Condition)/i);
        if (keyMatch) {
          const key = keyMatch[1].toLowerCase();
          const value = m[1].replace(/&nbsp;/g, ' ').replace(/&eacute;/g, '√©').trim();
          if (!item.attributes[key]) {
            item.attributes[key] = value;
          }
        }
      }
      
      console.log(`[LuluBerlu] ‚úÖ Item r√©cup√©r√©: ${item.name || item.id}`);
      console.log(`[LuluBerlu]    Images: ${item.images.length}, Prix: ${item.price || 'N/A'}, R√©f: ${item.reference || 'N/A'}`);
      
      // Mettre en cache le r√©sultat
      setCache(cacheKey, item);
      return item;

    } catch (err) {
      lastError = err;
      console.warn(`[LuluBerlu] Erreur tentative ${attempt}: ${err.message}`);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// -----------------------------
// Fonctions Rebrickable (API officielle)
// Documentation: https://rebrickable.com/api/v3/docs/
// N√©cessite une cl√© API (gratuite avec compte)
// -----------------------------

/**
 * Effectue une requ√™te √† l'API Rebrickable
 * @param {string} endpoint - Endpoint API (ex: "/lego/sets/")
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {object} params - Param√®tres query string optionnels
 * @returns {Promise<object>} - R√©ponse JSON de l'API
 */
async function rebrickableRequest(endpoint, apiKey, params = {}) {
  const url = new URL(`${REBRICKABLE_BASE_URL}${endpoint}`);
  
  // Ajouter les param√®tres √† l'URL
  for (const [key, value] of Object.entries(params)) {
    if (value !== undefined && value !== null) {
      url.searchParams.append(key, value);
    }
  }
  
  console.log(`[Rebrickable] Requ√™te: ${url.toString()}`);
  
  const response = await fetch(url.toString(), {
    method: 'GET',
    headers: {
      'Authorization': `key ${apiKey}`,
      'Accept': 'application/json'
    }
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    console.error(`[Rebrickable] Erreur HTTP ${response.status}: ${errorText}`);
    
    if (response.status === 401) {
      throw new Error("Cl√© API Rebrickable invalide ou manquante");
    } else if (response.status === 404) {
      throw new Error("Set non trouv√©");
    } else if (response.status === 429) {
      throw new Error("Limite de requ√™tes Rebrickable d√©pass√©e (rate limit)");
    }
    
    throw new Error(`Erreur Rebrickable: ${response.status} - ${errorText}`);
  }
  
  return response.json();
}

/**
 * Recherche des sets LEGO sur Rebrickable
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {number} maxResults - Nombre max de r√©sultats
 * @param {object} options - Options suppl√©mentaires (theme_id, min_year, max_year, min_parts, max_parts)
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchRebrickable(query, apiKey, maxResults = REBRICKABLE_DEFAULT_MAX, options = {}) {
  const cacheKey = `rebrickable_search_${query}_${maxResults}_${JSON.stringify(options)}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour recherche: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  const params = {
    search: query,
    page_size: Math.min(maxResults, 1000), // Max 1000 par page
    ordering: '-year', // Plus r√©cents d'abord
    ...options
  };
  
  try {
    const data = await rebrickableRequest('/lego/sets/', apiKey, params);
    
    const result = {
      count: data.count || 0,
      next: data.next,
      previous: data.previous,
      sets: (data.results || []).map(set => ({
        set_num: set.set_num,
        name: set.name,
        year: set.year,
        theme_id: set.theme_id,
        num_parts: set.num_parts,
        set_img_url: set.set_img_url,
        set_url: set.set_url,
        last_modified_dt: set.last_modified_dt
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} sets trouv√©s pour "${query}"`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un set LEGO par son num√©ro
 * @param {string} setNum - Num√©ro du set (ex: "75192-1" ou "75192")
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - D√©tails du set
 */
async function getRebrickableSet(setNum, apiKey) {
  // Ajouter -1 si pas de suffixe
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_set_${setNum}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour set: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest(`/lego/sets/${setNum}/`, apiKey);
    
    const result = {
      set_num: data.set_num,
      name: data.name,
      year: data.year,
      theme_id: data.theme_id,
      num_parts: data.num_parts,
      set_img_url: data.set_img_url,
      set_url: data.set_url,
      last_modified_dt: data.last_modified_dt,
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ Set trouv√©: ${result.name} (${result.set_num})`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les pi√®ces d'un set LEGO
 * @param {string} setNum - Num√©ro du set
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {number} maxParts - Nombre max de pi√®ces √† retourner
 * @returns {Promise<object>} - Liste des pi√®ces
 */
async function getRebrickableSetParts(setNum, apiKey, maxParts = 500) {
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_parts_${setNum}_${maxParts}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour pi√®ces: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest(`/lego/sets/${setNum}/parts/`, apiKey, {
      page_size: Math.min(maxParts, 1000)
    });
    
    const result = {
      set_num: setNum,
      count: data.count || 0,
      parts: (data.results || []).map(p => ({
        part_num: p.part?.part_num,
        name: p.part?.name,
        part_cat_id: p.part?.part_cat_id,
        part_url: p.part?.part_url,
        part_img_url: p.part?.part_img_url,
        color_id: p.color?.id,
        color_name: p.color?.name,
        color_rgb: p.color?.rgb,
        quantity: p.quantity,
        is_spare: p.is_spare,
        element_id: p.element_id
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} pi√®ces pour set ${setNum}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les minifigs d'un set LEGO
 * @param {string} setNum - Num√©ro du set
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - Liste des minifigs
 */
async function getRebrickableSetMinifigs(setNum, apiKey) {
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_minifigs_${setNum}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour minifigs: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest(`/lego/sets/${setNum}/minifigs/`, apiKey);
    
    const result = {
      set_num: setNum,
      count: data.count || 0,
      minifigs: (data.results || []).map(m => ({
        fig_num: m.set_num,
        name: m.set_name,
        quantity: m.quantity,
        set_img_url: m.set_img_url
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} minifigs pour set ${setNum}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les th√®mes LEGO disponibles
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {number} parentId - ID du th√®me parent (optionnel, pour sous-th√®mes)
 * @returns {Promise<object>} - Liste des th√®mes
 */
async function getRebrickableThemes(apiKey, parentId = null) {
  const cacheKey = `rebrickable_themes_${parentId || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour th√®mes`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const params = { page_size: 1000 };
    if (parentId) {
      params.parent_id = parentId;
    }
    
    const data = await rebrickableRequest('/lego/themes/', apiKey, params);
    
    const result = {
      count: data.count || 0,
      themes: (data.results || []).map(t => ({
        id: t.id,
        name: t.name,
        parent_id: t.parent_id
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} th√®mes r√©cup√©r√©s`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les couleurs LEGO disponibles
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - Liste des couleurs
 */
async function getRebrickableColors(apiKey) {
  const cacheKey = 'rebrickable_colors';
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour couleurs`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  try {
    const data = await rebrickableRequest('/lego/colors/', apiKey, { page_size: 500 });
    
    const result = {
      count: data.count || 0,
      colors: (data.results || []).map(c => ({
        id: c.id,
        name: c.name,
        rgb: c.rgb,
        is_trans: c.is_trans
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.count} couleurs r√©cup√©r√©es`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}

// -----------------------------
// Fonctions d'interconnexion LEGO <-> Rebrickable
// -----------------------------

/**
 * Convertit un ID LEGO en format Rebrickable
 * LEGO: 75192 -> Rebrickable: 75192-1
 * @param {string} legoId - ID au format LEGO
 * @returns {string} - ID au format Rebrickable
 */
function legoIdToRebrickable(legoId) {
  if (!legoId) return null;
  const id = String(legoId).trim();
  if (id.includes('-')) return id;
  return `${id}-1`;
}

/**
 * Convertit un ID Rebrickable en format LEGO
 * Rebrickable: 75192-1 -> LEGO: 75192
 * @param {string} rebrickableId - ID au format Rebrickable
 * @returns {string} - ID au format LEGO
 */
function rebrickableIdToLego(rebrickableId) {
  if (!rebrickableId) return null;
  const id = String(rebrickableId).trim();
  return id.replace(/-\d+$/, '');
}

/**
 * D√©tecte si une requ√™te est une recherche par ID de set ou par texte
 * @param {string} query - La requ√™te
 * @returns {boolean} - true si c'est un ID de set
 */
function isSetNumber(query) {
  if (!query) return false;
  const q = String(query).trim();
  // Patterns: 75192, 75192-1, 75192-2, etc.
  return /^\d{4,6}(-\d+)?$/.test(q);
}

/**
 * R√©cup√®re les infos compl√®tes d'un set Rebrickable (set + minifigs + parts)
 * @param {string} setNum - Num√©ro du set
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {object} options - Options (includeParts, includeMinifigs, maxParts)
 * @returns {Promise<object>} - Infos compl√®tes du set
 */
async function getRebrickableSetFull(setNum, apiKey, options = {}) {
  const {
    includeParts = true,
    includeMinifigs = true,
    maxParts = 500
  } = options;
  
  // Normaliser l'ID
  if (!setNum.includes('-')) {
    setNum = `${setNum}-1`;
  }
  
  const cacheKey = `rebrickable_full_${setNum}_${includeParts}_${includeMinifigs}_${maxParts}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour set complet: ${setNum}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[Rebrickable] R√©cup√©ration compl√®te du set ${setNum}...`);
  
  // R√©cup√©rer le set de base
  const setData = await getRebrickableSet(setNum, apiKey);
  
  const result = {
    ...setData,
    minifigs: null,
    parts: null
  };
  
  // R√©cup√©rer les minifigs en parall√®le avec les parts
  const promises = [];
  
  if (includeMinifigs) {
    promises.push(
      getRebrickableSetMinifigs(setNum, apiKey)
        .then(data => { result.minifigs = data; })
        .catch(err => { 
          console.warn(`[Rebrickable] Erreur minifigs: ${err.message}`);
          result.minifigs = { count: 0, minifigs: [], error: err.message };
        })
    );
  }
  
  if (includeParts) {
    promises.push(
      getRebrickableSetParts(setNum, apiKey, maxParts)
        .then(data => { result.parts = data; })
        .catch(err => {
          console.warn(`[Rebrickable] Erreur parts: ${err.message}`);
          result.parts = { count: 0, parts: [], error: err.message };
        })
    );
  }
  
  await Promise.all(promises);
  
  console.log(`[Rebrickable] ‚úÖ Set complet: ${result.name}, ${result.minifigs?.count || 0} minifigs, ${result.parts?.count || 0} parts`);
  
  setCache(cacheKey, result);
  return result;
}

/**
 * Enrichit les donn√©es LEGO avec les infos Rebrickable (parts, minifigs)
 * @param {object} legoData - Donn√©es du produit LEGO
 * @param {string} apiKey - Cl√© API Rebrickable
 * @returns {Promise<object>} - Donn√©es enrichies
 */
async function enrichLegoWithRebrickable(legoData, apiKey) {
  if (!apiKey || !legoData) return legoData;
  
  const productCode = legoData.productCode || legoData.id;
  if (!productCode) return legoData;
  
  const setNum = legoIdToRebrickable(productCode);
  
  console.log(`[Enrichment] Enrichissement LEGO ${productCode} avec Rebrickable...`);
  
  try {
    // R√©cup√©rer les donn√©es Rebrickable
    const [minifigsData, partsData] = await Promise.all([
      getRebrickableSetMinifigs(setNum, apiKey).catch(err => {
        console.warn(`[Enrichment] Minifigs non trouv√©es: ${err.message}`);
        return null;
      }),
      getRebrickableSetParts(setNum, apiKey, 100).catch(err => {
        console.warn(`[Enrichment] Parts non trouv√©es: ${err.message}`);
        return null;
      })
    ]);
    
    // Enrichir les donn√©es
    const enriched = {
      ...legoData,
      rebrickable: {
        set_num: setNum,
        minifigs: minifigsData ? {
          count: minifigsData.count,
          items: minifigsData.minifigs
        } : null,
        parts: partsData ? {
          count: partsData.count,
          sample: partsData.parts.slice(0, 20) // Premiers 20 parts seulement
        } : null
      }
    };
    
    console.log(`[Enrichment] ‚úÖ LEGO enrichi avec ${minifigsData?.count || 0} minifigs, ${partsData?.count || 0} parts`);
    return enriched;
    
  } catch (err) {
    console.warn(`[Enrichment] √âchec enrichissement: ${err.message}`);
    return legoData;
  }
}

/**
 * Enrichit les donn√©es Rebrickable avec les infos LEGO (manuels, prix)
 * @param {object} rebrickableData - Donn√©es du set Rebrickable
 * @param {string} lang - Langue pour LEGO
 * @returns {Promise<object>} - Donn√©es enrichies
 */
async function enrichRebrickableWithLego(rebrickableData, lang = DEFAULT_LOCALE) {
  if (!rebrickableData) return rebrickableData;
  
  const setNum = rebrickableData.set_num;
  if (!setNum) return rebrickableData;
  
  const legoId = rebrickableIdToLego(setNum);
  
  console.log(`[Enrichment] Enrichissement Rebrickable ${setNum} avec LEGO...`);
  
  try {
    // R√©cup√©rer les instructions LEGO
    const instructions = await getBuildingInstructions(legoId, lang).catch(err => {
      console.warn(`[Enrichment] Instructions non trouv√©es: ${err.message}`);
      return null;
    });
    
    // R√©cup√©rer les d√©tails produit LEGO (pour le prix)
    const productDetails = await getProductDetails(legoId, lang).catch(err => {
      console.warn(`[Enrichment] D√©tails produit non trouv√©s: ${err.message}`);
      return null;
    });
    
    // Enrichir les donn√©es
    const enriched = {
      ...rebrickableData,
      lego: {
        id: legoId,
        url: productDetails?.url || `https://www.lego.com/${lang.toLowerCase()}/product/${legoId}`,
        price: productDetails?.price || null,
        listPrice: productDetails?.listPrice || null,
        availability: productDetails?.availability || null,
        availabilityText: productDetails?.availabilityText || null,
        instructions: instructions ? {
          count: instructions.manuals?.length || 0,
          manuals: instructions.manuals || []
        } : null
      }
    };
    
    console.log(`[Enrichment] ‚úÖ Rebrickable enrichi avec ${instructions?.manuals?.length || 0} manuels`);
    return enriched;
    
  } catch (err) {
    console.warn(`[Enrichment] √âchec enrichissement: ${err.message}`);
    return rebrickableData;
  }
}

/**
 * Recherche intelligente sur Rebrickable avec pagination
 * G√®re automatiquement la recherche par ID vs texte
 * @param {string} query - Recherche (ID ou texte)
 * @param {string} apiKey - Cl√© API Rebrickable
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats
 */
async function smartRebrickableSearch(query, apiKey, options = {}) {
  const {
    page = 1,
    pageSize = 20,
    enrichWithLego = false,
    lang = DEFAULT_LOCALE,
    ...searchOptions
  } = options;
  
  // D√©terminer si c'est une recherche par ID
  if (isSetNumber(query)) {
    console.log(`[Rebrickable] Recherche par ID de set: ${query}`);
    
    // Recherche par ID -> r√©cup√©rer le set complet
    let setData = await getRebrickableSetFull(query, apiKey, {
      includeParts: true,
      includeMinifigs: true,
      maxParts: options.maxParts || 500
    });
    
    // Enrichir avec LEGO si demand√©
    if (enrichWithLego) {
      setData = await enrichRebrickableWithLego(setData, lang);
    }
    
    // Ajouter les champs type et lego_id
    return {
      ...setData,
      type: 'set_id',
      lego_id: rebrickableIdToLego(setData.set_num)
    };
  }
  
  // Recherche par texte
  console.log(`[Rebrickable] Recherche par texte: "${query}" (page ${page}, ${pageSize}/page)`);
  
  const cacheKey = `rebrickable_smart_${query}_${page}_${pageSize}_${JSON.stringify(searchOptions)}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[Rebrickable] Cache hit pour recherche smart: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  metrics.sources.rebrickable.requests++;
  
  const params = {
    search: query,
    page: page,
    page_size: pageSize,
    ordering: '-year',
    ...searchOptions
  };
  
  try {
    const data = await rebrickableRequest('/lego/sets/', apiKey, params);
    
    const result = {
      query: query,
      type: 'text_search',
      pagination: {
        page: page,
        page_size: pageSize,
        total_count: data.count || 0,
        total_pages: Math.ceil((data.count || 0) / pageSize),
        has_next: !!data.next,
        has_previous: !!data.previous
      },
      sets: (data.results || []).map(set => ({
        set_num: set.set_num,
        lego_id: rebrickableIdToLego(set.set_num),
        name: set.name,
        year: set.year,
        theme_id: set.theme_id,
        num_parts: set.num_parts,
        set_img_url: set.set_img_url,
        set_url: set.set_url,
        last_modified_dt: set.last_modified_dt
      })),
      source: "rebrickable"
    };
    
    console.log(`[Rebrickable] ‚úÖ ${result.pagination.total_count} sets trouv√©s, page ${page}/${result.pagination.total_pages}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.rebrickable.errors++;
    throw err;
  }
}


// -----------------------------
// Fonctions TVDB (API TV/Films)
// -----------------------------

/**
 * Obtient un token d'acc√®s TVDB
 * Token valide ~1 mois
 */
async function getTvdbToken(apiKey) {
  if (tvdbTokenCache.token && Date.now() < tvdbTokenCache.expiresAt) {
    console.log(`[TVDB] Utilisation du token en cache`);
    return tvdbTokenCache.token;
  }
  
  console.log(`[TVDB] Obtention d'un nouveau token...`);
  
  try {
    const response = await fetch(`${TVDB_BASE_URL}/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({ apikey: apiKey })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur login TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    // Le token TVDB est valide ~1 mois, on le cache pour 25 jours
    tvdbTokenCache.token = data.data.token;
    tvdbTokenCache.expiresAt = Date.now() + (25 * 24 * 60 * 60 * 1000);
    
    console.log(`[TVDB] ‚úÖ Token obtenu, expire dans 25 jours`);
    return data.data.token;
    
  } catch (err) {
    console.error(`[TVDB] Erreur login:`, err.message);
    throw err;
  }
}

/**
 * Recherche sur TVDB (s√©ries, films, personnes, compagnies)
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Cl√© API TVDB
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchTvdb(query, apiKey, options = {}) {
  const {
    max = TVDB_DEFAULT_MAX,
    type = null,      // series, movie, person, company
    lang = null,      // Code langue (fra, eng, etc.)
    year = null       // Ann√©e de sortie
  } = options;
  
  const cacheKey = `tvdb_search_${query}_${max}_${type}_${lang}_${year}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TVDB] Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TVDB] Recherche: "${query}" (type: ${type || 'all'}, lang: ${lang || 'default'}, max: ${max})`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    const params = new URLSearchParams({ query });
    if (type) params.append('type', type);
    if (lang) params.append('language', lang);
    if (year) params.append('year', year);
    params.append('limit', Math.min(max, TVDB_MAX_LIMIT));
    
    const url = `${TVDB_BASE_URL}/search?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.data || []).slice(0, max).map(item => ({
      id: item.tvdb_id || item.id,
      type: item.type || null,
      name: item.name || item.title,
      slug: item.slug,
      year: item.year || (item.first_air_time ? new Date(item.first_air_time).getFullYear() : null),
      overview: item.overview || null,
      overviews: item.overviews || null,  // Traductions disponibles
      primaryLanguage: item.primary_language || null,
      status: item.status || null,
      network: item.network || null,
      country: item.country || null,
      thumbnail: item.thumbnail || item.image_url || null,
      image: item.image || item.image_url || null,
      aliases: item.aliases || [],
      objectID: item.objectID,
      url: item.type === 'series' 
        ? `https://thetvdb.com/series/${item.slug}`
        : item.type === 'movie'
        ? `https://thetvdb.com/movies/${item.slug}`
        : `https://thetvdb.com/search?query=${encodeURIComponent(item.name || query)}`,
      source: "tvdb"
    }));
    
    const result = {
      query,
      type: type || 'all',
      total: results.length,
      results,
      source: "tvdb"
    };
    
    console.log(`[TVDB] ‚úÖ ${results.length} r√©sultat(s) trouv√©(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'une s√©rie TVDB par ID
 */
async function getTvdbSeriesById(id, apiKey, lang = null) {
  const cacheKey = `tvdb_series_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TVDB] Cache hit: series ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TVDB] R√©cup√©ration s√©rie: ${id}`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    // R√©cup√®re les infos √©tendues
    const url = `${TVDB_BASE_URL}/series/${id}/extended`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`S√©rie TVDB ${id} non trouv√©e`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const series = data.data;
    
    // R√©cup√®re les traductions si langue sp√©cifi√©e
    let translations = null;
    if (lang) {
      try {
        const transResponse = await fetch(`${TVDB_BASE_URL}/series/${id}/translations/${lang}`, {
          headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json' }
        });
        if (transResponse.ok) {
          const transData = await transResponse.json();
          translations = transData.data;
        }
      } catch (e) {
        console.log(`[TVDB] Pas de traduction ${lang} pour s√©rie ${id}`);
      }
    }
    
    const result = {
      id: series.id,
      type: 'series',
      name: translations?.name || series.name,
      originalName: series.name,
      slug: series.slug,
      overview: translations?.overview || series.overview,
      firstAired: series.firstAired,
      lastAired: series.lastAired,
      nextAired: series.nextAired,
      status: series.status?.name || null,
      year: series.year,
      averageRuntime: series.averageRuntime,
      score: series.score,
      originalCountry: series.originalCountry,
      originalLanguage: series.originalLanguage,
      defaultSeasonType: series.defaultSeasonType,
      isOrderRandomized: series.isOrderRandomized,
      lastUpdated: series.lastUpdated,
      
      // Images
      image: series.image,
      artworks: series.artworks?.slice(0, 20).map(a => ({
        id: a.id,
        type: a.type,
        image: a.image,
        thumbnail: a.thumbnail,
        language: a.language,
        score: a.score
      })) || [],
      
      // Genres
      genres: series.genres?.map(g => ({
        id: g.id,
        name: g.name,
        slug: g.slug
      })) || [],
      
      // Personnages principaux
      characters: series.characters?.slice(0, 30).map(c => ({
        id: c.id,
        name: c.name,
        peopleId: c.peopleId,
        personName: c.personName,
        image: c.image,
        type: c.type,
        sort: c.sort
      })) || [],
      
      // Saisons
      seasons: series.seasons?.map(s => ({
        id: s.id,
        number: s.number,
        name: s.name,
        type: s.type?.name,
        image: s.image
      })) || [],
      
      // R√©seaux/Plateformes
      companies: series.companies?.map(c => ({
        id: c.id,
        name: c.name,
        slug: c.slug,
        country: c.country,
        activeDate: c.activeDate,
        companyType: c.companyType?.name
      })) || [],
      
      // Contenu associ√©
      remoteIds: series.remoteIds || [],
      trailers: series.trailers?.map(t => ({
        id: t.id,
        name: t.name,
        url: t.url,
        runtime: t.runtime,
        language: t.language
      })) || [],
      
      lists: series.lists?.slice(0, 10).map(l => ({
        id: l.id,
        name: l.name,
        overview: l.overview,
        url: l.url
      })) || [],
      
      contentRatings: series.contentRatings || [],
      
      url: `https://thetvdb.com/series/${series.slug}`,
      source: "tvdb"
    };
    
    console.log(`[TVDB] ‚úÖ S√©rie r√©cup√©r√©e: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un film TVDB par ID
 */
async function getTvdbMovieById(id, apiKey, lang = null) {
  const cacheKey = `tvdb_movie_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TVDB] Cache hit: movie ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TVDB] R√©cup√©ration film: ${id}`);
  metrics.sources.tvdb.requests++;
  
  try {
    const token = await getTvdbToken(apiKey);
    
    const url = `${TVDB_BASE_URL}/movies/${id}/extended`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Accept': 'application/json'
      }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Film TVDB ${id} non trouv√©`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TVDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    const movie = data.data;
    
    // R√©cup√®re les traductions si langue sp√©cifi√©e
    let translations = null;
    if (lang) {
      try {
        const transResponse = await fetch(`${TVDB_BASE_URL}/movies/${id}/translations/${lang}`, {
          headers: { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json' }
        });
        if (transResponse.ok) {
          const transData = await transResponse.json();
          translations = transData.data;
        }
      } catch (e) {
        console.log(`[TVDB] Pas de traduction ${lang} pour film ${id}`);
      }
    }
    
    const result = {
      id: movie.id,
      type: 'movie',
      name: translations?.name || movie.name,
      originalName: movie.name,
      slug: movie.slug,
      overview: translations?.overview || movie.overview,
      year: movie.year,
      runtime: movie.runtime,
      score: movie.score,
      status: movie.status?.name || null,
      originalCountry: movie.originalCountry,
      originalLanguage: movie.originalLanguage,
      lastUpdated: movie.lastUpdated,
      
      // Dates de sortie
      releases: movie.releases?.map(r => ({
        country: r.country,
        date: r.date,
        detail: r.detail
      })) || [],
      
      // Images
      image: movie.image,
      artworks: movie.artworks?.slice(0, 20).map(a => ({
        id: a.id,
        type: a.type,
        image: a.image,
        thumbnail: a.thumbnail,
        language: a.language,
        score: a.score
      })) || [],
      
      // Genres
      genres: movie.genres?.map(g => ({
        id: g.id,
        name: g.name,
        slug: g.slug
      })) || [],
      
      // Personnages
      characters: movie.characters?.slice(0, 30).map(c => ({
        id: c.id,
        name: c.name,
        peopleId: c.peopleId,
        personName: c.personName,
        image: c.image,
        type: c.type
      })) || [],
      
      // Studios/Producteurs
      companies: movie.companies?.map(c => ({
        id: c.id,
        name: c.name,
        slug: c.slug,
        country: c.country,
        companyType: c.companyType?.name
      })) || [],
      
      // Box office
      boxOffice: movie.boxOffice,
      boxOfficeUS: movie.boxOfficeUS,
      budget: movie.budget,
      
      // Trailers
      trailers: movie.trailers?.map(t => ({
        id: t.id,
        name: t.name,
        url: t.url,
        runtime: t.runtime,
        language: t.language
      })) || [],
      
      remoteIds: movie.remoteIds || [],
      contentRatings: movie.contentRatings || [],
      
      url: `https://thetvdb.com/movies/${movie.slug}`,
      source: "tvdb"
    };
    
    console.log(`[TVDB] ‚úÖ Film r√©cup√©r√©: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tvdb.errors++;
    throw err;
  }
}

// -----------------------------
// Fonctions TMDB (API TV/Films)
// -----------------------------

/**
 * Recherche multi sur TMDB (films, s√©ries, personnes)
 * @param {string} query - Terme de recherche
 * @param {string} apiKey - Cl√© API TMDB
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchTmdb(query, apiKey, options = {}) {
  const {
    max = TMDB_DEFAULT_MAX,
    type = null,      // movie, tv, person, multi (d√©faut)
    lang = 'fr-FR',   // Code langue ISO 639-1 + pays
    page = 1,
    year = null,
    includeAdult = false
  } = options;
  
  const searchType = type || 'multi';
  const cacheKey = `tmdb_search_${query}_${searchType}_${max}_${lang}_${page}_${year}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TMDB] Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TMDB] Recherche: "${query}" (type: ${searchType}, lang: ${lang}, page: ${page})`);
  metrics.sources.tmdb.requests++;
  
  try {
    const params = new URLSearchParams({
      api_key: apiKey,
      query: query,
      language: lang,
      page: page,
      include_adult: includeAdult
    });
    
    // Param√®tres sp√©cifiques selon le type
    if (year) {
      if (searchType === 'movie') {
        params.append('primary_release_year', year);
      } else if (searchType === 'tv') {
        params.append('first_air_date_year', year);
      } else if (searchType === 'multi') {
        params.append('year', year);
      }
    }
    
    const url = `${TMDB_BASE_URL}/search/${searchType}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.results || []).slice(0, max).map(item => {
      const mediaType = item.media_type || searchType;
      const isMovie = mediaType === 'movie';
      const isTv = mediaType === 'tv';
      const isPerson = mediaType === 'person';
      
      return {
        id: item.id,
        mediaType: mediaType,
        title: item.title || item.name,
        originalTitle: item.original_title || item.original_name,
        overview: item.overview || null,
        releaseDate: item.release_date || item.first_air_date || null,
        year: (item.release_date || item.first_air_date) 
          ? new Date(item.release_date || item.first_air_date).getFullYear() 
          : null,
        popularity: item.popularity,
        voteAverage: item.vote_average,
        voteCount: item.vote_count,
        originalLanguage: item.original_language,
        genreIds: item.genre_ids || [],
        adult: item.adult || false,
        
        // Images
        poster: item.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${item.poster_path}` : null,
        posterSmall: item.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${item.poster_path}` : null,
        backdrop: item.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${item.backdrop_path}` : null,
        
        // Sp√©cifique aux personnes
        profilePath: isPerson && item.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${item.profile_path}` : null,
        knownFor: isPerson ? (item.known_for || []).map(k => ({
          id: k.id,
          mediaType: k.media_type,
          title: k.title || k.name,
          poster: k.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${k.poster_path}` : null
        })) : null,
        knownForDepartment: item.known_for_department || null,
        
        // Sp√©cifique aux s√©ries
        originCountry: isTv ? item.origin_country : null,
        
        url: isMovie 
          ? `https://www.themoviedb.org/movie/${item.id}`
          : isTv 
          ? `https://www.themoviedb.org/tv/${item.id}`
          : `https://www.themoviedb.org/person/${item.id}`,
        source: "tmdb"
      };
    });
    
    const result = {
      query,
      searchType,
      page: data.page,
      totalPages: data.total_pages,
      totalResults: data.total_results,
      resultsOnPage: results.length,
      results,
      source: "tmdb"
    };
    
    console.log(`[TMDB] ‚úÖ ${results.length} r√©sultat(s) sur ${data.total_results} total`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un film TMDB par ID
 */
async function getTmdbMovieById(id, apiKey, lang = 'fr-FR') {
  const cacheKey = `tmdb_movie_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TMDB] Cache hit: movie ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TMDB] R√©cup√©ration film: ${id}`);
  metrics.sources.tmdb.requests++;
  
  try {
    // R√©cup√®re le film avec credits et videos
    const params = new URLSearchParams({
      api_key: apiKey,
      language: lang,
      append_to_response: 'credits,videos,keywords,recommendations,similar,external_ids,release_dates'
    });
    
    const url = `${TMDB_BASE_URL}/movie/${id}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Film TMDB ${id} non trouv√©`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const movie = await response.json();
    
    const result = {
      id: movie.id,
      type: 'movie',
      imdbId: movie.imdb_id,
      title: movie.title,
      originalTitle: movie.original_title,
      tagline: movie.tagline,
      overview: movie.overview,
      releaseDate: movie.release_date,
      year: movie.release_date ? new Date(movie.release_date).getFullYear() : null,
      runtime: movie.runtime,
      status: movie.status,
      adult: movie.adult,
      video: movie.video,
      
      // Scores
      popularity: movie.popularity,
      voteAverage: movie.vote_average,
      voteCount: movie.vote_count,
      
      // Langues & pays
      originalLanguage: movie.original_language,
      spokenLanguages: movie.spoken_languages?.map(l => ({
        code: l.iso_639_1,
        name: l.name,
        englishName: l.english_name
      })) || [],
      productionCountries: movie.production_countries?.map(c => ({
        code: c.iso_3166_1,
        name: c.name
      })) || [],
      
      // Finances
      budget: movie.budget,
      revenue: movie.revenue,
      
      // Images
      poster: movie.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${movie.poster_path}` : null,
      posterOriginal: movie.poster_path ? `${TMDB_IMAGE_BASE_URL}/original${movie.poster_path}` : null,
      backdrop: movie.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${movie.backdrop_path}` : null,
      backdropOriginal: movie.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/original${movie.backdrop_path}` : null,
      
      // Genres
      genres: movie.genres?.map(g => ({ id: g.id, name: g.name })) || [],
      
      // Studios
      productionCompanies: movie.production_companies?.map(c => ({
        id: c.id,
        name: c.name,
        logo: c.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.logo_path}` : null,
        country: c.origin_country
      })) || [],
      
      // Collections
      belongsToCollection: movie.belongs_to_collection ? {
        id: movie.belongs_to_collection.id,
        name: movie.belongs_to_collection.name,
        poster: movie.belongs_to_collection.poster_path 
          ? `${TMDB_IMAGE_BASE_URL}/w500${movie.belongs_to_collection.poster_path}` : null,
        backdrop: movie.belongs_to_collection.backdrop_path
          ? `${TMDB_IMAGE_BASE_URL}/w1280${movie.belongs_to_collection.backdrop_path}` : null
      } : null,
      
      // Credits
      cast: movie.credits?.cast?.slice(0, 20).map(c => ({
        id: c.id,
        name: c.name,
        character: c.character,
        order: c.order,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      crew: movie.credits?.crew?.filter(c => 
        ['Director', 'Writer', 'Screenplay', 'Producer', 'Executive Producer', 'Original Music Composer'].includes(c.job)
      ).map(c => ({
        id: c.id,
        name: c.name,
        job: c.job,
        department: c.department,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      // Videos (bandes-annonces)
      videos: movie.videos?.results?.filter(v => v.site === 'YouTube').map(v => ({
        id: v.id,
        key: v.key,
        name: v.name,
        type: v.type,
        official: v.official,
        url: `https://www.youtube.com/watch?v=${v.key}`
      })) || [],
      
      // Mots-cl√©s
      keywords: movie.keywords?.keywords?.map(k => k.name) || [],
      
      // IDs externes
      externalIds: {
        imdb: movie.external_ids?.imdb_id,
        facebook: movie.external_ids?.facebook_id,
        instagram: movie.external_ids?.instagram_id,
        twitter: movie.external_ids?.twitter_id,
        wikidata: movie.external_ids?.wikidata_id
      },
      
      // Classifications par pays
      certifications: movie.release_dates?.results?.map(r => ({
        country: r.iso_3166_1,
        certification: r.release_dates?.[0]?.certification || null,
        releaseDate: r.release_dates?.[0]?.release_date || null
      })).filter(c => c.certification) || [],
      
      // Recommandations
      recommendations: movie.recommendations?.results?.slice(0, 10).map(r => ({
        id: r.id,
        title: r.title,
        releaseDate: r.release_date,
        voteAverage: r.vote_average,
        poster: r.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${r.poster_path}` : null
      })) || [],
      
      // Films similaires
      similar: movie.similar?.results?.slice(0, 10).map(s => ({
        id: s.id,
        title: s.title,
        releaseDate: s.release_date,
        voteAverage: s.vote_average,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null
      })) || [],
      
      homepage: movie.homepage || null,
      url: `https://www.themoviedb.org/movie/${movie.id}`,
      source: "tmdb"
    };
    
    console.log(`[TMDB] ‚úÖ Film r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'une s√©rie TV TMDB par ID
 */
async function getTmdbTvById(id, apiKey, lang = 'fr-FR') {
  const cacheKey = `tmdb_tv_${id}_${lang}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[TMDB] Cache hit: tv ${id}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[TMDB] R√©cup√©ration s√©rie: ${id}`);
  metrics.sources.tmdb.requests++;
  
  try {
    const params = new URLSearchParams({
      api_key: apiKey,
      language: lang,
      append_to_response: 'credits,videos,keywords,recommendations,similar,external_ids,content_ratings'
    });
    
    const url = `${TMDB_BASE_URL}/tv/${id}?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`S√©rie TMDB ${id} non trouv√©e`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur TMDB ${response.status}: ${errorText}`);
    }
    
    const tv = await response.json();
    
    const result = {
      id: tv.id,
      type: 'tv',
      name: tv.name,
      originalName: tv.original_name,
      tagline: tv.tagline,
      overview: tv.overview,
      firstAirDate: tv.first_air_date,
      lastAirDate: tv.last_air_date,
      year: tv.first_air_date ? new Date(tv.first_air_date).getFullYear() : null,
      status: tv.status,
      tvType: tv.type,
      inProduction: tv.in_production,
      adult: tv.adult,
      
      // √âpisodes
      numberOfSeasons: tv.number_of_seasons,
      numberOfEpisodes: tv.number_of_episodes,
      episodeRunTime: tv.episode_run_time || [],
      
      // Derniers √©pisodes
      lastEpisodeToAir: tv.last_episode_to_air ? {
        id: tv.last_episode_to_air.id,
        name: tv.last_episode_to_air.name,
        overview: tv.last_episode_to_air.overview,
        airDate: tv.last_episode_to_air.air_date,
        seasonNumber: tv.last_episode_to_air.season_number,
        episodeNumber: tv.last_episode_to_air.episode_number,
        voteAverage: tv.last_episode_to_air.vote_average
      } : null,
      nextEpisodeToAir: tv.next_episode_to_air ? {
        id: tv.next_episode_to_air.id,
        name: tv.next_episode_to_air.name,
        overview: tv.next_episode_to_air.overview,
        airDate: tv.next_episode_to_air.air_date,
        seasonNumber: tv.next_episode_to_air.season_number,
        episodeNumber: tv.next_episode_to_air.episode_number
      } : null,
      
      // Scores
      popularity: tv.popularity,
      voteAverage: tv.vote_average,
      voteCount: tv.vote_count,
      
      // Langues & pays
      originalLanguage: tv.original_language,
      languages: tv.languages || [],
      originCountry: tv.origin_country || [],
      spokenLanguages: tv.spoken_languages?.map(l => ({
        code: l.iso_639_1,
        name: l.name,
        englishName: l.english_name
      })) || [],
      productionCountries: tv.production_countries?.map(c => ({
        code: c.iso_3166_1,
        name: c.name
      })) || [],
      
      // Images
      poster: tv.poster_path ? `${TMDB_IMAGE_BASE_URL}/w500${tv.poster_path}` : null,
      posterOriginal: tv.poster_path ? `${TMDB_IMAGE_BASE_URL}/original${tv.poster_path}` : null,
      backdrop: tv.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/w1280${tv.backdrop_path}` : null,
      backdropOriginal: tv.backdrop_path ? `${TMDB_IMAGE_BASE_URL}/original${tv.backdrop_path}` : null,
      
      // Genres
      genres: tv.genres?.map(g => ({ id: g.id, name: g.name })) || [],
      
      // R√©seaux de diffusion
      networks: tv.networks?.map(n => ({
        id: n.id,
        name: n.name,
        logo: n.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${n.logo_path}` : null,
        country: n.origin_country
      })) || [],
      
      // Studios
      productionCompanies: tv.production_companies?.map(c => ({
        id: c.id,
        name: c.name,
        logo: c.logo_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.logo_path}` : null,
        country: c.origin_country
      })) || [],
      
      // Cr√©ateurs
      createdBy: tv.created_by?.map(c => ({
        id: c.id,
        name: c.name,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      // Saisons
      seasons: tv.seasons?.map(s => ({
        id: s.id,
        name: s.name,
        overview: s.overview,
        seasonNumber: s.season_number,
        episodeCount: s.episode_count,
        airDate: s.air_date,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null,
        voteAverage: s.vote_average
      })) || [],
      
      // Credits
      cast: tv.credits?.cast?.slice(0, 20).map(c => ({
        id: c.id,
        name: c.name,
        character: c.character,
        order: c.order,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      crew: tv.credits?.crew?.filter(c => 
        ['Executive Producer', 'Creator', 'Original Music Composer', 'Director of Photography'].includes(c.job)
      ).map(c => ({
        id: c.id,
        name: c.name,
        job: c.job,
        department: c.department,
        profile: c.profile_path ? `${TMDB_IMAGE_BASE_URL}/w185${c.profile_path}` : null
      })) || [],
      
      // Videos
      videos: tv.videos?.results?.filter(v => v.site === 'YouTube').map(v => ({
        id: v.id,
        key: v.key,
        name: v.name,
        type: v.type,
        official: v.official,
        url: `https://www.youtube.com/watch?v=${v.key}`
      })) || [],
      
      // Mots-cl√©s
      keywords: tv.keywords?.results?.map(k => k.name) || [],
      
      // IDs externes
      externalIds: {
        imdb: tv.external_ids?.imdb_id,
        tvdb: tv.external_ids?.tvdb_id,
        facebook: tv.external_ids?.facebook_id,
        instagram: tv.external_ids?.instagram_id,
        twitter: tv.external_ids?.twitter_id,
        wikidata: tv.external_ids?.wikidata_id
      },
      
      // Classifications
      contentRatings: tv.content_ratings?.results?.map(r => ({
        country: r.iso_3166_1,
        rating: r.rating
      })) || [],
      
      // Recommandations
      recommendations: tv.recommendations?.results?.slice(0, 10).map(r => ({
        id: r.id,
        name: r.name,
        firstAirDate: r.first_air_date,
        voteAverage: r.vote_average,
        poster: r.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${r.poster_path}` : null
      })) || [],
      
      // S√©ries similaires
      similar: tv.similar?.results?.slice(0, 10).map(s => ({
        id: s.id,
        name: s.name,
        firstAirDate: s.first_air_date,
        voteAverage: s.vote_average,
        poster: s.poster_path ? `${TMDB_IMAGE_BASE_URL}/w185${s.poster_path}` : null
      })) || [],
      
      homepage: tv.homepage || null,
      url: `https://www.themoviedb.org/tv/${tv.id}`,
      source: "tmdb"
    };
    
    console.log(`[TMDB] ‚úÖ S√©rie r√©cup√©r√©e: ${result.name}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.tmdb.errors++;
    throw err;
  }
}

// ======================================================
// IMDB API Functions (via imdbapi.dev - NO API KEY NEEDED)
// ======================================================

/**
 * Recherche de titres sur IMDB via imdbapi.dev
 * @param {string} query - Terme de recherche
 * @param {object} options - Options de recherche
 * @returns {Promise<object>} - R√©sultats de recherche
 */
async function searchImdb(query, options = {}) {
  const {
    max = IMDB_DEFAULT_MAX
  } = options;
  
  // Limiter max au maximum autoris√©
  const limit = Math.min(max, IMDB_MAX_LIMIT);
  
  const cacheKey = `imdb_search_${query}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[IMDB] Cache hit: ${query}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[IMDB] Recherche: "${query}" (limit: ${limit})`);
  metrics.sources.imdb.requests++;
  
  try {
    const params = new URLSearchParams({
      query: query,
      limit: limit
    });
    
    const url = `${IMDB_BASE_URL}/search/titles?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    const results = (data.titles || []).map(item => ({
      id: item.id,
      type: item.type,
      title: item.primaryTitle,
      originalTitle: item.originalTitle,
      year: item.startYear,
      endYear: item.endYear || null,
      runtimeMinutes: item.runtimeSeconds ? Math.round(item.runtimeSeconds / 60) : null,
      genres: item.genres || [],
      rating: item.rating ? {
        average: item.rating.aggregateRating,
        votes: item.rating.voteCount
      } : null,
      poster: item.primaryImage?.url || null,
      posterWidth: item.primaryImage?.width || null,
      posterHeight: item.primaryImage?.height || null,
      isAdult: item.isAdult || false,
      url: `https://www.imdb.com/title/${item.id}/`,
      source: "imdb"
    }));
    
    const result = {
      query,
      resultsCount: results.length,
      results,
      source: "imdb"
    };
    
    console.log(`[IMDB] ‚úÖ ${results.length} r√©sultat(s) trouv√©(s)`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

/**
 * R√©cup√®re les d√©tails d'un titre IMDB par ID
 * @param {string} titleId - ID IMDB (format: tt1234567)
 * @returns {Promise<object>} - D√©tails du titre
 */
async function getImdbTitleById(titleId) {
  const cacheKey = `imdb_title_${titleId}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[IMDB] Cache hit: title ${titleId}`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[IMDB] R√©cup√©ration titre: ${titleId}`);
  metrics.sources.imdb.requests++;
  
  try {
    const url = `${IMDB_BASE_URL}/titles/${titleId}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      if (response.status === 404 || response.status === 5) {
        throw new Error(`Titre IMDB ${titleId} non trouv√©`);
      }
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const title = await response.json();
    
    // V√©rifier si erreur dans la r√©ponse
    if (title.code === 5 || title.message === 'Not Found') {
      throw new Error(`Titre IMDB ${titleId} non trouv√©`);
    }
    
    const result = {
      id: title.id,
      type: title.type,
      title: title.primaryTitle,
      originalTitle: title.originalTitle || title.primaryTitle,
      year: title.startYear,
      endYear: title.endYear || null,
      runtimeMinutes: title.runtimeSeconds ? Math.round(title.runtimeSeconds / 60) : null,
      isAdult: title.isAdult || false,
      
      // Rating
      rating: title.rating ? {
        average: title.rating.aggregateRating,
        votes: title.rating.voteCount
      } : null,
      
      // Metacritic
      metacritic: title.metacritic ? {
        score: title.metacritic.score,
        reviewCount: title.metacritic.reviewCount
      } : null,
      
      // Plot
      plot: title.plot || null,
      
      // Genres
      genres: title.genres || [],
      
      // Image
      poster: title.primaryImage?.url || null,
      posterWidth: title.primaryImage?.width || null,
      posterHeight: title.primaryImage?.height || null,
      
      // Credits
      directors: (title.directors || []).map(d => ({
        id: d.id,
        name: d.displayName,
        alternativeNames: d.alternativeNames || [],
        image: d.primaryImage?.url || null,
        professions: d.primaryProfessions || []
      })),
      
      writers: (title.writers || []).map(w => ({
        id: w.id,
        name: w.displayName,
        alternativeNames: w.alternativeNames || [],
        image: w.primaryImage?.url || null,
        professions: w.primaryProfessions || []
      })),
      
      stars: (title.stars || []).map(s => ({
        id: s.id,
        name: s.displayName,
        alternativeNames: s.alternativeNames || [],
        image: s.primaryImage?.url || null,
        professions: s.primaryProfessions || []
      })),
      
      // Origin
      originCountries: (title.originCountries || []).map(c => ({
        code: c.code,
        name: c.name
      })),
      
      spokenLanguages: (title.spokenLanguages || []).map(l => ({
        code: l.code,
        name: l.name
      })),
      
      // Interests/Tags
      interests: (title.interests || []).filter(i => !i.isSubgenre).map(i => ({
        id: i.id,
        name: i.name
      })),
      subgenres: (title.interests || []).filter(i => i.isSubgenre).map(i => ({
        id: i.id,
        name: i.name
      })),
      
      url: `https://www.imdb.com/title/${title.id}/`,
      source: "imdb"
    };
    
    console.log(`[IMDB] ‚úÖ Titre r√©cup√©r√©: ${result.title}`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}

/**
 * Liste/Browse des titres IMDB avec filtres
 * @param {object} options - Options de filtrage
 * @returns {Promise<object>} - Liste de titres
 */
async function browseImdbTitles(options = {}) {
  const {
    types = [],           // MOVIE, TV_SERIES, TV_MINI_SERIES, TV_SPECIAL, TV_MOVIE, SHORT, VIDEO, VIDEO_GAME
    genres = [],          // Action, Comedy, Drama, etc.
    startYear = null,     // Ann√©e de d√©but
    endYear = null,       // Ann√©e de fin
    minRating = null,     // Note minimum (0-10)
    maxRating = null,     // Note maximum (0-10)
    sortBy = 'SORT_BY_POPULARITY',  // SORT_BY_POPULARITY, SORT_BY_RELEASE_DATE, SORT_BY_USER_RATING, SORT_BY_USER_RATING_COUNT, SORT_BY_YEAR
    sortOrder = 'DESC',   // ASC, DESC
    pageToken = null,     // Token de pagination
    limit = IMDB_DEFAULT_MAX
  } = options;
  
  // Construire une cl√© de cache unique
  const cacheKey = `imdb_browse_${types.join(',')}_${genres.join(',')}_${startYear}_${endYear}_${minRating}_${maxRating}_${sortBy}_${sortOrder}_${pageToken}_${limit}`;
  const cached = getCached(cacheKey);
  if (cached) {
    console.log(`[IMDB] Cache hit: browse`);
    metrics.requests.cached++;
    return cached;
  }
  
  console.log(`[IMDB] Browse titles: types=${types.join(',')}, genres=${genres.join(',')}, years=${startYear}-${endYear}`);
  metrics.sources.imdb.requests++;
  
  try {
    const params = new URLSearchParams();
    
    // Types
    if (types.length > 0) {
      types.forEach(t => params.append('types', t));
    }
    
    // Genres
    if (genres.length > 0) {
      genres.forEach(g => params.append('genres', g));
    }
    
    // Ann√©es
    if (startYear) params.append('startYear', startYear);
    if (endYear) params.append('endYear', endYear);
    
    // Rating
    if (minRating !== null) params.append('minAggregateRating', minRating);
    if (maxRating !== null) params.append('maxAggregateRating', maxRating);
    
    // Tri
    params.append('sortBy', sortBy);
    params.append('sortOrder', sortOrder);
    
    // Pagination
    if (pageToken) params.append('pageToken', pageToken);
    
    const url = `${IMDB_BASE_URL}/titles?${params.toString()}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json' }
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Erreur IMDB ${response.status}: ${errorText}`);
    }
    
    const data = await response.json();
    
    // Limiter les r√©sultats
    const titles = (data.titles || []).slice(0, limit);
    
    const results = titles.map(item => ({
      id: item.id,
      type: item.type,
      title: item.primaryTitle,
      originalTitle: item.originalTitle,
      year: item.startYear,
      endYear: item.endYear || null,
      runtimeMinutes: item.runtimeSeconds ? Math.round(item.runtimeSeconds / 60) : null,
      genres: item.genres || [],
      rating: item.rating ? {
        average: item.rating.aggregateRating,
        votes: item.rating.voteCount
      } : null,
      plot: item.plot || null,
      poster: item.primaryImage?.url || null,
      isAdult: item.isAdult || false,
      url: `https://www.imdb.com/title/${item.id}/`,
      source: "imdb"
    }));
    
    const result = {
      filters: {
        types: types.length > 0 ? types : 'all',
        genres: genres.length > 0 ? genres : 'all',
        years: {
          start: startYear || 'any',
          end: endYear || 'any'
        },
        rating: {
          min: minRating || 'any',
          max: maxRating || 'any'
        },
        sortBy,
        sortOrder
      },
      totalCount: data.totalCount || null,
      resultsCount: results.length,
      nextPageToken: data.nextPageToken || null,
      results,
      source: "imdb"
    };
    
    console.log(`[IMDB] ‚úÖ ${results.length} titre(s) trouv√©(s) sur ${data.totalCount || '?'} total`);
    setCache(cacheKey, result);
    return result;
    
  } catch (err) {
    metrics.sources.imdb.errors++;
    throw err;
  }
}



/**
 * R√©cup√®re les instructions de montage pour un produit Mega par SKU
 * Scrape les pages d'instructions de Mattel par cat√©gorie (recherche parall√®le)
 * @param {string} sku - SKU du produit (ex: HMW05, HTH96)
 * @returns {Promise<object>} - Informations sur les instructions
 */
async function getMegaInstructions(sku) {
  metrics.sources.mega.requests++;
  
  const skuLower = sku.toLowerCase();
  const cacheKey = `mega_instructions_${skuLower}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[MEGA] Recherche instructions pour SKU: ${sku}`);
    
    // Liste des cat√©gories d'instructions disponibles (page principale + cat√©gories)
    const categories = [
      '', // Page principale
      'en-us-category-pokemon',
      'en-us-category-halo',
      'en-us-category-barbie',
      'en-us-category-hot-wheels',
      'en-us-category-masters-of-the-universe',
      'en-us-category-tesla',
      'en-us-category-other'
    ];
    
    const baseUrl = `${MEGA_BASE_URL_US}/blogs/mega-building-instructions`;
    
    // Fonction pour extraire le PDF d'une page HTML
    const extractPdfFromHtml = (html) => {
      // Pattern: aria-label="{Nom} - {sku}" href="https://assets.contentstack.io/.../xxx.pdf"
      const regex = new RegExp(
        `aria-label="([^"]+)\\s*-\\s*${skuLower}"[^>]*href="(https://assets\\.contentstack\\.io[^"]+\\.pdf)"`,
        'i'
      );
      const match = html.match(regex);
      if (match) {
        return { name: match[1].trim(), url: match[2] };
      }
      return null;
    };
    
    // Fonction pour scraper une cat√©gorie
    const scrapeCategory = async (category) => {
      const url = category ? `${baseUrl}/tagged/${category}` : baseUrl;
      try {
        const response = await fetch(`${FSR_BASE}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            cmd: "request.get",
            url: url,
            maxTimeout: 30000,
            session: fsrSessionId
          })
        });
        const data = await response.json();
        if (data.status === "ok" && data.solution?.response) {
          const result = extractPdfFromHtml(data.solution.response);
          if (result) {
            return { ...result, category: category || 'page principale' };
          }
        }
      } catch (e) {
        console.log(`[MEGA] Erreur scraping ${url}: ${e.message}`);
      }
      return null;
    };
    
    // Recherche PARALL√àLE dans toutes les cat√©gories (au lieu de s√©quentiel)
    const results = await Promise.all(categories.map(cat => scrapeCategory(cat)));
    
    // Trouver le premier r√©sultat non-null
    const found = results.find(r => r !== null);
    
    if (!found) {
      throw new Error(`Instructions non trouv√©es pour SKU: ${sku}`);
    }
    
    console.log(`[MEGA] ‚úÖ Instructions trouv√©es pour ${sku} dans ${found.category}`);
    
    const result = {
      sku: sku.toUpperCase(),
      productName: found.name,
      instructionsUrl: found.url,
      format: 'PDF',
      source: 'mega',
      note: 'Instructions officielles Mattel'
    };

    // Cache plus long pour les instructions (1 jour)
    setCache(cacheKey, result, 86400000);
    return result;

  } catch (err) {
    metrics.sources.mega.errors++;
    throw err;
  }
}

/**
 * Recherche toutes les instructions disponibles pour une cat√©gorie Mega
 * @param {string} category - Cat√©gorie (pokemon, halo, barbie, hot-wheels, etc.)
 * @returns {Promise<object>} - Liste des instructions
 */
async function listMegaInstructions(category = '') {
  metrics.sources.mega.requests++;
  
  const cacheKey = `mega_instructions_list_${category || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) {
    metrics.requests.cached++;
    return cached;
  }

  try {
    console.log(`[MEGA] Liste instructions pour cat√©gorie: ${category || 'toutes'}`);
    
    // Mapper les cat√©gories simples vers les tags Mattel
    const categoryMap = {
      'pokemon': 'en-us-category-pokemon',
      'halo': 'en-us-category-halo',
      'barbie': 'en-us-category-barbie',
      'hot-wheels': 'en-us-category-hot-wheels',
      'hotwheels': 'en-us-category-hot-wheels',
      'motu': 'en-us-category-masters-of-the-universe',
      'masters': 'en-us-category-masters-of-the-universe',
      'tesla': 'en-us-category-tesla',
      'other': 'en-us-category-other'
    };
    
    const mattelCategory = categoryMap[category.toLowerCase()] || category;
    const baseUrl = `${MEGA_BASE_URL_US}/blogs/mega-building-instructions`;  // Instructions uniquement sur site US
    const url = mattelCategory ? `${baseUrl}/tagged/${mattelCategory}` : baseUrl;
    
    const response = await fetch(`${FSR_BASE}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        cmd: "request.get",
        url: url,
        maxTimeout: 30000,
        session: fsrSessionId
      })
    });

    const data = await response.json();
    
    if (data.status !== "ok") {
      throw new Error(`FlareSolverr error: ${data.message || 'Unknown error'}`);
    }

    const html = data.solution?.response || "";
    
    // Extraire toutes les instructions
    const instructions = [];
    const regex = /aria-label="([^"]+)\s*-\s*([^"]+)"[^>]*href="(https:\/\/assets\.contentstack\.io[^"]+\.pdf)"/gi;
    let match;
    
    while ((match = regex.exec(html)) !== null) {
      const [, name, sku, pdfUrl] = match;
      instructions.push({
        sku: sku.trim().toUpperCase(),
        productName: name.trim(),
        instructionsUrl: pdfUrl,
        format: 'PDF'
      });
    }
    
    const result = {
      category: category || 'all',
      count: instructions.length,
      instructions,
      source: 'mega'
    };

    console.log(`[MEGA] ‚úÖ ${instructions.length} instructions trouv√©es`);
    // Cache 6h pour les listes
    setCache(cacheKey, result, 21600000);
    return result;

  } catch (err) {
    metrics.sources.mega.errors++;
    throw err;
  }
}

// -----------------------------
// Endpoints Amazon (via FlareSolverr + VPN)
// -----------------------------

// Recherche Amazon
app.get("/amazon/search", async (req, res) => {
  const q = req.query.q;
  const country = req.query.country || "fr";
  const category = req.query.category || null;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const max = req.query.max ? parseInt(req.query.max, 10) : 20;

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await searchAmazon(q, { country, category, page, limit: max });
    addCacheHeaders(res, 600); // Cache 10 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/search:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// D√©tails d'un produit Amazon par ASIN
app.get("/amazon/product/:asin", async (req, res) => {
  const { asin } = req.params;
  const country = req.query.country || "fr";

  if (!asin) return res.status(400).json({ error: "ASIN requis" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await getAmazonProduct(asin, country);
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/product:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Recherche par code-barres (EAN/UPC)
app.get("/amazon/barcode/:code", async (req, res) => {
  const { code } = req.params;
  const country = req.query.country || "fr";
  const category = req.query.category || null;

  if (!code) return res.status(400).json({ error: "Code-barres requis" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await searchAmazonByBarcode(code, { country, category });
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/barcode:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Recherche multi-pays
app.get("/amazon/multi", async (req, res) => {
  const q = req.query.q;
  const countries = req.query.countries ? req.query.countries.split(",") : ["fr", "us", "uk"];
  const category = req.query.category || null;

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await searchAmazonMultiCountry(q, countries, { category });
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/multi:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Comparaison de prix entre marketplaces
app.get("/amazon/compare/:asin", async (req, res) => {
  const { asin } = req.params;
  const countries = req.query.countries ? req.query.countries.split(",") : ["fr", "us", "uk", "de"];

  if (!asin) return res.status(400).json({ error: "ASIN requis" });

  try {
    metrics.requests.total++;
    metrics.sources.amazon.requests++;
    const result = await compareAmazonPrices(asin, countries);
    addCacheHeaders(res, 600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /amazon/compare:", err.message);
    metrics.requests.errors++;
    metrics.sources.amazon.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Statut du VPN Amazon
app.get("/amazon/vpn/status", async (req, res) => {
  try {
    const status = await checkVpnStatus();
    res.json(status);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Rotation d'IP VPN
app.post("/amazon/vpn/rotate", async (req, res) => {
  try {
    const result = await rotateVpnIp();
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Marketplaces et cat√©gories support√©s
app.get("/amazon/marketplaces", (req, res) => {
  res.json(getSupportedMarketplaces());
});

app.get("/amazon/categories", (req, res) => {
  res.json(getSupportedCategories());
});

// -----------------------------
// Endpoints LEGO
// -----------------------------
app.get("/lego/search", async (req, res) => {
  const q = req.query.q;
  const lang = (req.query.lang || DEFAULT_LOCALE);
  const limit = req.query.limit ? parseInt(req.query.limit, 10) : 24;
  const max = req.query.max ? parseInt(req.query.max, 10) : limit; // Alias pour compatibilit√©

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.sources.lego.requests++;
    const perPage = Math.max(1, Math.min(max, 100)); // Entre 1 et 100
    const result = await callLegoGraphqlLib(q, lang, MAX_RETRIES, perPage);
    
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /lego/search:", err);
    metrics.requests.errors++;
    metrics.sources.lego.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Rebrickable (n√©cessite cl√© API)
// La cl√© API doit √™tre fournie via header:
// - X-Encrypted-Key: cl√© chiffr√©e en AES-256-GCM (si API_ENCRYPTION_KEY configur√©e)
// - X-Api-Key: cl√© en clair (seulement si chiffrement d√©sactiv√©)
// -----------------------------

// Recherche de sets LEGO via Rebrickable (recherche intelligente)
// Si q est un num√©ro de set: r√©cup√®re set + minifigs + pi√®ces
// Si q est un texte: recherche avec pagination
app.get("/rebrickable/search", async (req, res) => {
  const q = req.query.q;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const pageSize = req.query.page_size ? parseInt(req.query.page_size, 10) : REBRICKABLE_DEFAULT_MAX;
  const lang = req.query.lang || DEFAULT_LOCALE;
  const enrichLego = req.query.enrich_lego !== 'false'; // Activ√© par d√©faut
  const themeId = req.query.theme_id ? parseInt(req.query.theme_id, 10) : undefined;
  const minYear = req.query.min_year ? parseInt(req.query.min_year, 10) : undefined;
  const maxYear = req.query.max_year ? parseInt(req.query.max_year, 10) : undefined;
  const minParts = req.query.min_parts ? parseInt(req.query.min_parts, 10) : undefined;
  const maxPartsFilter = req.query.max_parts ? parseInt(req.query.max_parts, 10) : undefined;
  const maxPartsLimit = req.query.parts_limit ? parseInt(req.query.parts_limit, 10) : 500;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const searchOptions = {};
    if (themeId) searchOptions.theme_id = themeId;
    if (minYear) searchOptions.min_year = minYear;
    if (maxYear) searchOptions.max_year = maxYear;
    if (minParts) searchOptions.min_parts = minParts;
    if (maxPartsFilter) searchOptions.max_parts = maxPartsFilter;
    
    const result = await smartRebrickableSearchLib(q, apiKey, {
      page,
      pageSize,
      lang,
      enrichWithLego: enrichLego,
      maxParts: maxPartsLimit,
      searchOptions
    });
    
    // Cache plus long pour recherche par ID (1h) vs recherche texte (5min)
    const cacheTime = result.type === 'set_id' ? 3600 : 300;
    addCacheHeaders(res, cacheTime);
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/search:", err);
    metrics.requests.errors++;
    metrics.sources.rebrickable.errors++;
    
    if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else if (err.message.includes("rate limit")) {
      res.status(429).json({ error: err.message });
    } else if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// D√©tails d'un set LEGO via Rebrickable (avec enrichissement LEGO optionnel)
app.get("/rebrickable/set/:setNum", async (req, res) => {
  let setNum = req.params.setNum;
  const includeParts = req.query.parts !== 'false'; // Inclure les pi√®ces par d√©faut
  const includeMinifigs = req.query.minifigs !== 'false'; // Inclure les minifigs par d√©faut
  const enrichLego = req.query.enrich_lego !== 'false'; // Enrichir avec LEGO par d√©faut
  const lang = req.query.lang || DEFAULT_LOCALE;
  const maxParts = req.query.parts_limit ? parseInt(req.query.parts_limit, 10) : 500;
  
  if (!setNum) return res.status(400).json({ error: "param√®tre 'setNum' manquant" });
  
  // Convertir ID LEGO en ID Rebrickable si n√©cessaire
  setNum = legoIdToRebrickable(setNum);
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    let result;
    
    if (includeParts || includeMinifigs) {
      // Utiliser la fonction compl√®te
      result = await getRebrickableSetFullLib(setNum, apiKey, {
        includeParts,
        includeMinifigs,
        maxParts
      });
    } else {
      // Juste les infos de base
      result = await getRebrickableSet(setNum, apiKey);
    }
    
    // Enrichir avec LEGO si demand√©
    if (enrichLego) {
      result = await enrichRebrickableWithLego(result, lang);
    }
    
    // Ajouter lego_id si pas pr√©sent
    if (result.set_num && !result.lego_id) {
      result.lego_id = rebrickableIdToLego(result.set_num);
    }
    
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/set:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Pi√®ces d'un set LEGO via Rebrickable
app.get("/rebrickable/set/:setNum/parts", async (req, res) => {
  const setNum = req.params.setNum;
  const limit = req.query.limit ? parseInt(req.query.limit, 10) : 500;
  
  if (!setNum) return res.status(400).json({ error: "param√®tre 'setNum' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableSetParts(setNum, apiKey, limit);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/set/parts:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Minifigs d'un set LEGO via Rebrickable
app.get("/rebrickable/set/:setNum/minifigs", async (req, res) => {
  const setNum = req.params.setNum;
  
  if (!setNum) return res.status(400).json({ error: "param√®tre 'setNum' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableSetMinifigs(setNum, apiKey);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/set/minifigs:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Liste des th√®mes LEGO via Rebrickable
app.get("/rebrickable/themes", async (req, res) => {
  const parentId = req.query.parent_id ? parseInt(req.query.parent_id, 10) : null;
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableThemes(apiKey, parentId);
    addCacheHeaders(res, 86400); // Cache 24h pour les th√®mes (stable)
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/themes:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Liste des couleurs LEGO via Rebrickable
app.get("/rebrickable/colors", async (req, res) => {
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Rebrickable requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getRebrickableColors(apiKey);
    addCacheHeaders(res, 86400); // Cache 24h
    res.json(result);
  } catch (err) {
    console.error("Erreur /rebrickable/colors:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("invalide")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Google Books (n√©cessite cl√© API)
// La cl√© API doit √™tre fournie via header:
// - X-Encrypted-Key: cl√© chiffr√©e en AES-256-GCM (si API_ENCRYPTION_KEY configur√©e)
// - X-Api-Key: cl√© en clair (seulement si chiffrement d√©sactiv√©)
// -----------------------------

// Recherche de livres sur Google Books
// Supporte recherche par texte ou par ISBN
app.get("/googlebooks/search", async (req, res) => {
  const q = req.query.q;
  const lang = req.query.lang || null; // Code langue ISO 639-1 (fr, en, es, etc.)
  const maxResults = req.query.max ? parseInt(req.query.max, 10) : GOOGLE_BOOKS_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Google Books requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await searchGoogleBooksLib(q, apiKey, { lang, maxResults });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /googlebooks/search:", err);
    metrics.requests.errors++;
    metrics.sources.googlebooks.errors++;
    
    if (err.message.includes("invalide") || err.message.includes("quota")) {
      res.status(401).json({ error: err.message });
    } else if (err.message.includes("rate limit")) {
      res.status(429).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// D√©tails d'un livre par son ID Google Books
app.get("/googlebooks/book/:volumeId", async (req, res) => {
  let volumeId = req.params.volumeId;
  
  if (!volumeId) return res.status(400).json({ error: "param√®tre 'volumeId' manquant" });
  
  // Nettoyer les pr√©fixes courants
  volumeId = cleanSourceId(volumeId, 'googlebooks');
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Google Books requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await getGoogleBookByIdLib(volumeId, apiKey);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /googlebooks/book:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("invalide") || err.message.includes("quota")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Recherche par ISBN sur Google Books (raccourci)
app.get("/googlebooks/isbn/:isbn", async (req, res) => {
  const isbn = req.params.isbn;
  const lang = req.query.lang || null;
  
  if (!isbn) return res.status(400).json({ error: "param√®tre 'isbn' manquant" });
  
  // Valider l'ISBN
  if (!isIsbn(isbn)) {
    return res.status(400).json({ error: "ISBN invalide. Format attendu: 10 ou 13 chiffres" });
  }
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API Google Books requise",
      hint: API_ENCRYPTION_KEY 
        ? "Utilisez le header X-Encrypted-Key avec la cl√© chiffr√©e"
        : "Utilisez le header X-Api-Key ou le param√®tre api_key"
    });
  }
  
  try {
    const result = await searchGoogleBooksLib(isbn, apiKey, { lang, maxResults: 1 });
    
    // Si trouv√©, retourner le premier r√©sultat directement
    if (result.books && result.books.length > 0) {
      addCacheHeaders(res, 3600);
      res.json({
        ...result.books[0],
        query: isbn,
        source: "google_books"
      });
    } else {
      res.status(404).json({ error: `Aucun livre trouv√© pour ISBN: ${isbn}` });
    }
  } catch (err) {
    console.error("Erreur /googlebooks/isbn:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("invalide") || err.message.includes("quota")) {
      res.status(401).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints OpenLibrary (pas de cl√© API requise)
// -----------------------------

// Recherche de livres sur OpenLibrary
// Supporte recherche par texte ou par ISBN
app.get("/openlibrary/search", async (req, res) => {
  const q = req.query.q;
  const lang = req.query.lang || null; // Code langue ISO 639-1 (fr, en, es, etc.)
  const maxResults = req.query.max ? parseInt(req.query.max, 10) : OPENLIBRARY_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchOpenLibraryLib(q, { lang, maxResults });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /openlibrary/search:", err);
    metrics.requests.errors++;
    metrics.sources.openlibrary.errors++;
    res.status(500).json({ error: err.message });
  }
});

// D√©tails d'un livre par son ID OpenLibrary (work ou edition)
app.get("/openlibrary/book/:olId", async (req, res) => {
  let olId = req.params.olId;
  
  if (!olId) return res.status(400).json({ error: "param√®tre 'olId' manquant" });
  
  // Nettoyer les pr√©fixes courants (olib_, openlibrary_, ol_)
  olId = cleanSourceId(olId, 'openlibrary');
  
  try {
    const result = await getOpenLibraryByIdLib(olId);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /openlibrary/book:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Recherche par ISBN sur OpenLibrary (raccourci)
app.get("/openlibrary/isbn/:isbn", async (req, res) => {
  const isbn = req.params.isbn;
  const lang = req.query.lang || null;
  
  if (!isbn) return res.status(400).json({ error: "param√®tre 'isbn' manquant" });
  
  // Valider l'ISBN
  if (!isIsbn(isbn)) {
    return res.status(400).json({ error: "ISBN invalide. Format attendu: 10 ou 13 chiffres" });
  }
  
  try {
    const result = await searchOpenLibraryLib(isbn, { lang, maxResults: 1 });
    
    // Si trouv√©, retourner le premier r√©sultat directement
    if (result.books && result.books.length > 0) {
      addCacheHeaders(res, 3600);
      res.json({
        ...result.books[0],
        query: isbn,
        source: "openlibrary"
      });
    } else {
      res.status(404).json({ error: `Aucun livre trouv√© pour ISBN: ${isbn}` });
    }
  } catch (err) {
    console.error("Erreur /openlibrary/isbn:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints RAWG (jeux vid√©o)
// -----------------------------

/**
 * Recherche de jeux sur RAWG
 * GET /rawg/search?q=zelda&max=10&page=1&platforms=4,18,1&genres=action&ordering=-rating
 * 
 * Param√®tres:
 * - q: terme de recherche (requis)
 * - max: nombre de r√©sultats par page (d√©faut: 20, max: 40)
 * - page: num√©ro de page (d√©faut: 1)
 * - platforms: IDs de plateformes s√©par√©s par virgule (ex: 4=PC, 18=PS4, 1=Xbox One)
 * - genres: genres s√©par√©s par virgule (ex: action,adventure,rpg)
 * - ordering: tri (-rating, -released, -added, -created, -updated, -metacritic)
 * - dates: plage de dates (ex: 2020-01-01,2023-12-31)
 * - metacritic: plage de score metacritic (ex: 80,100)
 * 
 * Requiert: cl√© API RAWG via X-Api-Key ou X-Encrypted-Key
 */
app.get("/rawg/search", async (req, res) => {
  const query = req.query.q;
  const max = Math.min(parseInt(req.query.max, 10) || RAWG_DEFAULT_MAX, RAWG_MAX_LIMIT);
  const page = parseInt(req.query.page, 10) || 1;
  const platforms = req.query.platforms || null;
  const genres = req.query.genres || null;
  const ordering = req.query.ordering || null;
  const dates = req.query.dates || null;
  const metacritic = req.query.metacritic || null;
  
  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API RAWG requise",
      hint: "Obtenez une cl√© gratuite sur https://rawg.io/apidocs"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await searchRawgLib(query, apiKey, {
      max, page, platforms, genres, ordering, dates, metacritic
    });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /rawg/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("401") || err.message.includes("403")) {
      res.status(401).json({ error: "Cl√© API RAWG invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un jeu sur RAWG
 * GET /rawg/game/:id
 * 
 * :id peut √™tre l'ID num√©rique ou le slug du jeu
 * Ex: /rawg/game/3498 ou /rawg/game/grand-theft-auto-v
 */
app.get("/rawg/game/:id", async (req, res) => {
  const gameId = req.params.id;
  
  if (!gameId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API RAWG requise",
      hint: "Obtenez une cl√© gratuite sur https://rawg.io/apidocs"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getRawgGameDetailsLib(gameId, apiKey);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /rawg/game:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("403")) {
      res.status(401).json({ error: "Cl√© API RAWG invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints IGDB (jeux vid√©o Twitch)
// -----------------------------

/**
 * Recherche de jeux sur IGDB
 * GET /igdb/search?q=zelda&max=10&platforms=48,167&genres=12
 * 
 * Param√®tres:
 * - q: terme de recherche (requis)
 * - max: nombre de r√©sultats (d√©faut: 20, max: 500)
 * - platforms: IDs de plateformes s√©par√©s par virgule
 * - genres: IDs de genres s√©par√©s par virgule
 * 
 * Requiert: cl√© API IGDB au format "clientId:clientSecret" via X-Api-Key ou X-Encrypted-Key
 */
app.get("/igdb/search", async (req, res) => {
  const query = req.query.q;
  const max = Math.min(parseInt(req.query.max, 10) || IGDB_DEFAULT_MAX, IGDB_MAX_LIMIT);
  const platforms = req.query.platforms || null;
  const genres = req.query.genres || null;
  
  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Extraire la cl√© API (format: clientId:clientSecret)
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API IGDB requise (format: clientId:clientSecret)",
      hint: "Cr√©ez une application sur https://dev.twitch.tv/console/apps"
    });
  }
  
  try {
    // Parser les credentials IGDB
    const { clientId, clientSecret } = parseIgdbCredentials(apiKey);
    
    // Obtenir un token OAuth2
    const accessToken = await getIgdbToken(clientId, clientSecret);
    
    metrics.requests.total++;
    const result = await searchIgdbLib(query, clientId, accessToken, { max, platforms, genres });
    addCacheHeaders(res, 300); // Cache 5 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /igdb/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("Format de cl√©") || err.message.includes("clientId")) {
      res.status(400).json({ 
        error: err.message,
        hint: "Format attendu: clientId:clientSecret"
      });
    } else if (err.message.includes("401") || err.message.includes("403") || err.message.includes("OAuth2")) {
      res.status(401).json({ error: "Credentials IGDB invalides" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un jeu sur IGDB
 * GET /igdb/game/:id
 * 
 * :id peut √™tre l'ID num√©rique ou le slug du jeu
 * Ex: /igdb/game/1942 ou /igdb/game/the-witcher-3-wild-hunt
 */
app.get("/igdb/game/:id", async (req, res) => {
  const gameId = req.params.id;
  
  if (!gameId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API IGDB requise (format: clientId:clientSecret)",
      hint: "Cr√©ez une application sur https://dev.twitch.tv/console/apps"
    });
  }
  
  try {
    // Parser les credentials IGDB
    const { clientId, clientSecret } = parseIgdbCredentials(apiKey);
    
    // Obtenir un token OAuth2
    const accessToken = await getIgdbToken(clientId, clientSecret);
    
    metrics.requests.total++;
    const result = await getIgdbGameDetailsLib(gameId, clientId, accessToken);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /igdb/game:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("Format de cl√©") || err.message.includes("clientId")) {
      res.status(400).json({ 
        error: err.message,
        hint: "Format attendu: clientId:clientSecret"
      });
    } else if (err.message.includes("401") || err.message.includes("403") || err.message.includes("OAuth2")) {
      res.status(401).json({ error: "Credentials IGDB invalides" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints TVDB
// -----------------------------

/**
 * Recherche sur TVDB (s√©ries, films, personnes, compagnies)
 * GET /tvdb/search?q=breaking+bad&type=series&max=10&lang=fra&year=2008
 * 
 * Param√®tres:
 *   q (obligatoire) - Terme de recherche
 *   type (optionnel) - Type de recherche: series, movie, person, company
 *   max (optionnel) - Nombre max de r√©sultats (d√©faut: 20, max: 100)
 *   lang (optionnel) - Code langue (fra, eng, deu, spa, etc.)
 *   year (optionnel) - Ann√©e de sortie
 * 
 * Requiert une cl√© API TVDB via X-Api-Key ou X-Encrypted-Key
 */
app.get("/tvdb/search", async (req, res) => {
  const query = req.query.q;
  const type = req.query.type || null;
  const max = req.query.max ? parseInt(req.query.max, 10) : TVDB_DEFAULT_MAX;
  const lang = req.query.lang || null;
  const year = req.query.year ? parseInt(req.query.year, 10) : null;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  // Extraire la cl√© API
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TVDB requise",
      hint: "Obtenez une cl√© gratuite sur https://thetvdb.com/api-information"
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchTvdbLib(query, apiKey, { max, type, lang, year });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tvdb/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("401") || err.message.includes("Unauthorized")) {
      res.status(401).json({ error: "Cl√© API TVDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'une s√©rie sur TVDB
 * GET /tvdb/series/:id?lang=fra
 * 
 * :id - ID TVDB de la s√©rie (ex: 81189 pour Breaking Bad)
 * lang (optionnel) - Code langue pour la traduction (fra, eng, deu, etc.)
 */
app.get("/tvdb/series/:id", async (req, res) => {
  const seriesId = req.params.id;
  const lang = req.query.lang || null;
  
  if (!seriesId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TVDB requise",
      hint: "Obtenez une cl√© gratuite sur https://thetvdb.com/api-information"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTvdbSeriesByIdLib(seriesId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tvdb/series:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©e")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Unauthorized")) {
      res.status(401).json({ error: "Cl√© API TVDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un film sur TVDB
 * GET /tvdb/movie/:id?lang=fra
 * 
 * :id - ID TVDB du film
 * lang (optionnel) - Code langue pour la traduction (fra, eng, deu, etc.)
 */
app.get("/tvdb/movie/:id", async (req, res) => {
  const movieId = req.params.id;
  const lang = req.query.lang || null;
  
  if (!movieId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TVDB requise",
      hint: "Obtenez une cl√© gratuite sur https://thetvdb.com/api-information"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTvdbMovieByIdLib(movieId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tvdb/movie:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Unauthorized")) {
      res.status(401).json({ error: "Cl√© API TVDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints TMDB
// -----------------------------

/**
 * Recherche sur TMDB (films, s√©ries TV, personnes)
 * GET /tmdb/search?q=inception&type=movie&max=10&lang=fr-FR&page=1&year=2010
 * 
 * Param√®tres:
 *   q (obligatoire) - Terme de recherche
 *   type (optionnel) - Type de recherche: movie, tv, person, multi (d√©faut)
 *   max (optionnel) - Nombre max de r√©sultats (d√©faut: 20, max: 20 par page)
 *   lang (optionnel) - Langue au format ISO 639-1-ISO 3166-1 (ex: fr-FR, en-US)
 *   page (optionnel) - Num√©ro de page pour la pagination
 *   year (optionnel) - Ann√©e de sortie/diffusion
 *   adult (optionnel) - Inclure le contenu adulte (true/false)
 * 
 * Requiert une cl√© API TMDB via X-Api-Key ou X-Encrypted-Key
 */
app.get("/tmdb/search", async (req, res) => {
  const query = req.query.q;
  const type = req.query.type || null;
  const max = req.query.max ? parseInt(req.query.max, 10) : TMDB_DEFAULT_MAX;
  const lang = req.query.lang || 'fr-FR';
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const year = req.query.year ? parseInt(req.query.year, 10) : null;
  const includeAdult = req.query.adult === 'true';

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TMDB requise",
      hint: "Obtenez une cl√© gratuite sur https://www.themoviedb.org/settings/api"
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchTmdbLib(query, apiKey, { max, type, lang, page, year, includeAdult });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tmdb/search:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("401") || err.message.includes("Invalid API key")) {
      res.status(401).json({ error: "Cl√© API TMDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un film sur TMDB
 * GET /tmdb/movie/:id?lang=fr-FR
 * 
 * :id - ID TMDB du film (ex: 27205 pour Inception)
 * lang (optionnel) - Langue au format ISO 639-1-ISO 3166-1 (d√©faut: fr-FR)
 * 
 * Inclut: cr√©dits, vid√©os, mots-cl√©s, recommandations, films similaires, IDs externes
 */
app.get("/tmdb/movie/:id", async (req, res) => {
  const movieId = req.params.id;
  const lang = req.query.lang || 'fr-FR';
  
  if (!movieId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TMDB requise",
      hint: "Obtenez une cl√© gratuite sur https://www.themoviedb.org/settings/api"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTmdbMovieByIdLib(movieId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tmdb/movie:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Invalid API key")) {
      res.status(401).json({ error: "Cl√© API TMDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'une s√©rie TV sur TMDB
 * GET /tmdb/tv/:id?lang=fr-FR
 * 
 * :id - ID TMDB de la s√©rie (ex: 1396 pour Breaking Bad)
 * lang (optionnel) - Langue au format ISO 639-1-ISO 3166-1 (d√©faut: fr-FR)
 * 
 * Inclut: cr√©dits, vid√©os, mots-cl√©s, recommandations, s√©ries similaires, IDs externes
 */
app.get("/tmdb/tv/:id", async (req, res) => {
  const tvId = req.params.id;
  const lang = req.query.lang || 'fr-FR';
  
  if (!tvId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  const apiKey = extractApiKey(req);
  if (!apiKey) {
    return res.status(401).json({ 
      error: "Cl√© API TMDB requise",
      hint: "Obtenez une cl√© gratuite sur https://www.themoviedb.org/settings/api"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getTmdbTvByIdLib(tvId, apiKey, lang);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /tmdb/tv:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©e")) {
      res.status(404).json({ error: err.message });
    } else if (err.message.includes("401") || err.message.includes("Invalid API key")) {
      res.status(401).json({ error: "Cl√© API TMDB invalide" });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints IMDB (via imdbapi.dev - NO API KEY NEEDED)
// -----------------------------

/**
 * Recherche de titres sur IMDB
 * GET /imdb/search?q=inception&max=10
 * 
 * q (requis) - Terme de recherche
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 20, max: 50)
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/imdb/search", async (req, res) => {
  const query = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : IMDB_DEFAULT_MAX;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.requests.total++;
    const result = await searchImdbLib(query, { max });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /imdb/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * D√©tails d'un titre sur IMDB
 * GET /imdb/title/:id
 * 
 * :id - ID IMDB du titre (format: tt1234567, ex: tt1375666 pour Inception)
 * 
 * Retourne les d√©tails complets incluant: synopsis, casting, r√©alisateurs, genres, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/imdb/title/:id", async (req, res) => {
  const titleId = req.params.id;
  
  if (!titleId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Valider le format de l'ID IMDB
  if (!/^tt\d{7,}$/.test(titleId)) {
    return res.status(400).json({ 
      error: "Format d'ID IMDB invalide",
      hint: "L'ID doit √™tre au format 'tt' suivi d'au moins 7 chiffres (ex: tt1375666)"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getImdbTitleByIdLib(titleId);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /imdb/title:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * Browse/Liste des titres IMDB avec filtres avanc√©s
 * GET /imdb/browse?types=MOVIE&genres=Action&startYear=2020&endYear=2024&minRating=8&sortBy=SORT_BY_USER_RATING&sortOrder=DESC&max=20
 * 
 * types (optionnel) - Types de titres: MOVIE, TV_SERIES, TV_MINI_SERIES, TV_SPECIAL, TV_MOVIE, SHORT, VIDEO, VIDEO_GAME (plusieurs possibles s√©par√©s par virgule)
 * genres (optionnel) - Genres: Action, Comedy, Drama, Horror, Sci-Fi, etc. (plusieurs possibles s√©par√©s par virgule)
 * startYear (optionnel) - Ann√©e de d√©but pour filtrer
 * endYear (optionnel) - Ann√©e de fin pour filtrer
 * minRating (optionnel) - Note minimum (0-10)
 * maxRating (optionnel) - Note maximum (0-10)
 * sortBy (optionnel) - Tri: SORT_BY_POPULARITY (d√©faut), SORT_BY_RELEASE_DATE, SORT_BY_USER_RATING, SORT_BY_USER_RATING_COUNT, SORT_BY_YEAR
 * sortOrder (optionnel) - Ordre: ASC, DESC (d√©faut)
 * pageToken (optionnel) - Token pour la pagination (retourn√© dans nextPageToken)
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 20, max: 50)
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/imdb/browse", async (req, res) => {
  const types = req.query.types ? req.query.types.split(',').map(t => t.trim().toUpperCase()) : [];
  const genres = req.query.genres ? req.query.genres.split(',').map(g => g.trim()) : [];
  const startYear = req.query.startYear ? parseInt(req.query.startYear, 10) : null;
  const endYear = req.query.endYear ? parseInt(req.query.endYear, 10) : null;
  const minRating = req.query.minRating ? parseFloat(req.query.minRating) : null;
  const maxRating = req.query.maxRating ? parseFloat(req.query.maxRating) : null;
  const sortBy = req.query.sortBy || 'SORT_BY_POPULARITY';
  const sortOrder = req.query.sortOrder || 'DESC';
  const pageToken = req.query.pageToken || null;
  const limit = req.query.max ? parseInt(req.query.max, 10) : IMDB_DEFAULT_MAX;

  // Valider les param√®tres
  const validTypes = ['MOVIE', 'TV_SERIES', 'TV_MINI_SERIES', 'TV_SPECIAL', 'TV_MOVIE', 'SHORT', 'VIDEO', 'VIDEO_GAME'];
  const invalidTypes = types.filter(t => !validTypes.includes(t));
  if (invalidTypes.length > 0) {
    return res.status(400).json({ 
      error: `Types invalides: ${invalidTypes.join(', ')}`,
      validTypes
    });
  }
  
  const validSortBy = ['SORT_BY_POPULARITY', 'SORT_BY_RELEASE_DATE', 'SORT_BY_USER_RATING', 'SORT_BY_USER_RATING_COUNT', 'SORT_BY_YEAR'];
  if (!validSortBy.includes(sortBy)) {
    return res.status(400).json({ 
      error: `sortBy invalide: ${sortBy}`,
      validValues: validSortBy
    });
  }
  
  if (sortOrder !== 'ASC' && sortOrder !== 'DESC') {
    return res.status(400).json({ 
      error: `sortOrder invalide: ${sortOrder}`,
      validValues: ['ASC', 'DESC']
    });
  }

  try {
    metrics.requests.total++;
    const result = await browseImdbTitlesLib({
      types,
      genres,
      startYear,
      endYear,
      minRating,
      maxRating,
      sortBy,
      sortOrder,
      pageToken,
      limit
    });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /imdb/browse:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Jikan (MyAnimeList - NO API KEY NEEDED)
// -----------------------------

/**
 * Recherche d'anime sur Jikan (MyAnimeList)
 * GET /jikan/anime?q=naruto&max=25&page=1
 * 
 * q (requis) - Terme de recherche
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 25, max: 25 par page)
 * page (optionnel) - Num√©ro de page pour la pagination (d√©faut: 1)
 * type (optionnel) - Type d'anime: tv, movie, ova, special, ona, music
 * status (optionnel) - Statut: airing, complete, upcoming
 * rating (optionnel) - Classification: g, pg, pg13, r17, r, rx
 * orderBy (optionnel) - Tri par: mal_id, title, start_date, end_date, episodes, score, scored_by, rank, popularity, members, favorites
 * sort (optionnel) - Ordre: asc, desc
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/anime", async (req, res) => {
  const query = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : JIKAN_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const type = req.query.type || null;
  const status = req.query.status || null;
  const rating = req.query.rating || null;
  const orderBy = req.query.orderBy || null;
  const sort = req.query.sort || null;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  // Valider le type si fourni
  const validTypes = ['tv', 'movie', 'ova', 'special', 'ona', 'music'];
  if (type && !validTypes.includes(type.toLowerCase())) {
    return res.status(400).json({ 
      error: `Type invalide: ${type}`,
      validTypes
    });
  }

  // Valider le statut si fourni
  const validStatuses = ['airing', 'complete', 'upcoming'];
  if (status && !validStatuses.includes(status.toLowerCase())) {
    return res.status(400).json({ 
      error: `Statut invalide: ${status}`,
      validStatuses
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchJikanAnimeLib(query, { max, page, type, status, rating, orderBy, sort });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/anime:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * Recherche de manga sur Jikan (MyAnimeList)
 * GET /jikan/manga?q=one+piece&max=25&page=1
 * 
 * q (requis) - Terme de recherche
 * max (optionnel) - Nombre maximum de r√©sultats (d√©faut: 25, max: 25 par page)
 * page (optionnel) - Num√©ro de page pour la pagination (d√©faut: 1)
 * type (optionnel) - Type de manga: manga, novel, lightnovel, oneshot, doujin, manhwa, manhua
 * status (optionnel) - Statut: publishing, complete, hiatus, discontinued, upcoming
 * orderBy (optionnel) - Tri par: mal_id, title, start_date, end_date, chapters, volumes, score, scored_by, rank, popularity, members, favorites
 * sort (optionnel) - Ordre: asc, desc
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/manga", async (req, res) => {
  const query = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : JIKAN_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const type = req.query.type || null;
  const status = req.query.status || null;
  const orderBy = req.query.orderBy || null;
  const sort = req.query.sort || null;

  if (!query) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  // Valider le type si fourni
  const validTypes = ['manga', 'novel', 'lightnovel', 'oneshot', 'doujin', 'manhwa', 'manhua'];
  if (type && !validTypes.includes(type.toLowerCase())) {
    return res.status(400).json({ 
      error: `Type invalide: ${type}`,
      validTypes
    });
  }

  // Valider le statut si fourni
  const validStatuses = ['publishing', 'complete', 'hiatus', 'discontinued', 'upcoming'];
  if (status && !validStatuses.includes(status.toLowerCase())) {
    return res.status(400).json({ 
      error: `Statut invalide: ${status}`,
      validStatuses
    });
  }

  try {
    metrics.requests.total++;
    const result = await searchJikanMangaLib(query, { max, page, type, status, orderBy, sort });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/manga:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * D√©tails d'un anime sur Jikan (MyAnimeList)
 * GET /jikan/anime/:id
 * 
 * :id - ID MyAnimeList de l'anime (ex: 20 pour Naruto)
 * 
 * Retourne les d√©tails complets incluant: synopsis, studios, genres, relations, streaming, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/anime/:id", async (req, res) => {
  let animeId = req.params.id;
  
  if (!animeId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  animeId = cleanSourceId(animeId, 'jikan');
  
  // Valider que l'ID est un nombre
  if (!/^\d+$/.test(animeId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 20 pour Naruto)"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getJikanAnimeByIdLib(parseInt(animeId, 10));
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/anime/:id:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un manga sur Jikan (MyAnimeList)
 * GET /jikan/manga/:id
 * 
 * :id - ID MyAnimeList du manga (ex: 11 pour Naruto)
 * 
 * Retourne les d√©tails complets incluant: synopsis, auteurs, genres, relations, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/jikan/manga/:id", async (req, res) => {
  let mangaId = req.params.id;
  
  if (!mangaId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  mangaId = cleanSourceId(mangaId, 'jikan');
  
  // Valider que l'ID est un nombre
  if (!/^\d+$/.test(mangaId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 11 pour Naruto)"
    });
  }
  
  try {
    metrics.requests.total++;
    const result = await getJikanMangaByIdLib(parseInt(mangaId, 10));
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jikan/manga/:id:", err);
    metrics.requests.errors++;
    
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Comic Vine (Comics US)
// -----------------------------

/**
 * GET /comicvine/search
 * Recherche de comics/volumes sur Comic Vine
 * 
 * Param√®tres:
 * - q: terme de recherche (obligatoire)
 * - type: type de ressource (volume, issue, character, person) - d√©faut: volume
 * - max: nombre maximum de r√©sultats (1-100, d√©faut: 20)
 * 
 * N√©cessite une cl√© API Comic Vine (configur√©e c√¥t√© serveur)
 */
app.get("/comicvine/search", async (req, res) => {
  const q = req.query.q;
  const type = req.query.type || 'volume';
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), COMICVINE_MAX_LIMIT) : COMICVINE_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  // Valider le type de ressource
  const validTypes = ['volume', 'issue', 'character', 'person'];
  if (!validTypes.includes(type)) {
    return res.status(400).json({ 
      error: "Type de ressource invalide",
      validTypes,
      hint: "Utilisez 'volume' pour les s√©ries de comics, 'issue' pour les num√©ros individuels"
    });
  }
  
  try {
    const result = await searchComicVineLib(q, { type, max });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /comicvine/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /comicvine/volume/:id
 * R√©cup√®re les d√©tails d'un volume (s√©rie) Comic Vine
 * 
 * :id - ID Comic Vine du volume (ex: 796 pour Batman)
 * 
 * Retourne les d√©tails complets incluant: issues, personnages, cr√©ateurs, etc.
 */
app.get("/comicvine/volume/:id", async (req, res) => {
  let volumeId = req.params.id;
  
  if (!volumeId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  volumeId = cleanSourceId(volumeId, 'comicvine');
  
  if (!/^\d+$/.test(volumeId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 796 pour Batman)"
    });
  }
  
  try {
    const result = await getComicVineVolumeLib(parseInt(volumeId, 10));
    if (!result) {
      return res.status(404).json({ error: `Volume ${volumeId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /comicvine/volume/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /comicvine/issue/:id
 * R√©cup√®re les d√©tails d'un issue (num√©ro) Comic Vine
 * 
 * :id - ID Comic Vine de l'issue
 * 
 * Retourne les d√©tails complets incluant: personnages, √©quipes, cr√©ateurs, etc.
 */
app.get("/comicvine/issue/:id", async (req, res) => {
  let issueId = req.params.id;
  
  if (!issueId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  issueId = cleanSourceId(issueId, 'comicvine');
  
  if (!/^\d+$/.test(issueId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier"
    });
  }
  
  try {
    const result = await getComicVineIssueLib(parseInt(issueId, 10));
    if (!result) {
      return res.status(404).json({ error: `Issue ${issueId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /comicvine/issue/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints MangaDex (Manga)
// -----------------------------

/**
 * GET /mangadex/search
 * Recherche de manga sur MangaDex
 * 
 * Param√®tres:
 * - q: terme de recherche (obligatoire)
 * - lang: filtrer par langue disponible (ex: fr, en, ja)
 * - max: nombre maximum de r√©sultats (1-100, d√©faut: 20)
 * 
 * PAS DE CL√â API REQUISE !
 */
app.get("/mangadex/search", async (req, res) => {
  const q = req.query.q;
  const lang = req.query.lang || null;
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), MANGADEX_MAX_LIMIT) : MANGADEX_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchMangaDexLib(q, { lang, max });
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /mangadex/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /mangadex/manga/:id
 * R√©cup√®re les d√©tails d'un manga MangaDex par UUID
 * 
 * :id - UUID MangaDex du manga (ex: a1c7c817-4e59-43b7-9365-09675a149a6f pour One Piece)
 * 
 * Retourne les d√©tails complets incluant: description multilangue, auteurs, tags, etc.
 * PAS DE CL√â API REQUISE !
 */
app.get("/mangadex/manga/:id", async (req, res) => {
  let mangaId = req.params.id;
  
  if (!mangaId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  mangaId = cleanSourceId(mangaId, 'mangadex');
  
  // Valider le format UUID
  if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(mangaId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un UUID (ex: a1c7c817-4e59-43b7-9365-09675a149a6f)"
    });
  }
  
  try {
    const result = await getMangaDexByIdLib(mangaId);
    if (!result) {
      return res.status(404).json({ error: `Manga ${mangaId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /mangadex/manga/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Bedetheque (BD Franco-Belge)
// -----------------------------

/**
 * GET /bedetheque/search
 * Recherche de s√©ries BD sur Bedetheque (scraping via FlareSolverr)
 * 
 * Param√®tres:
 * - q: terme de recherche (obligatoire)
 * - max: nombre maximum de r√©sultats (1-50, d√©faut: 20)
 * 
 * Note: Cette API utilise du scraping, les r√©sultats peuvent varier.
 * PAS DE CL√â API REQUISE !
 */
app.get("/bedetheque/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), 50) : BEDETHEQUE_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchBedethequeLib(q, { max });
    addCacheHeaders(res, 600); // Cache 10 min car scraping
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /bedetheque/search/albums
 * Recherche d'albums BD sur Bedetheque
 * 
 * Param√®tres:
 * - q: terme de recherche (recherche dans les s√©ries puis liste leurs albums)
 * - serieId: ID de s√©rie Bedetheque pour lister directement ses albums (optionnel)
 * - max: nombre maximum de r√©sultats (1-50, d√©faut: 20)
 * 
 * Note: Cette API recherche d'abord les s√©ries correspondantes, puis r√©cup√®re leurs albums.
 * Pour cibler une s√©rie sp√©cifique, utilisez le param√®tre serieId.
 */
app.get("/bedetheque/search/albums", async (req, res) => {
  const q = req.query.q || '';
  const serieId = req.query.serieId || req.query.serie_id || '';
  const serieName = req.query.serieName || req.query.serie_name || '';
  const max = req.query.max ? Math.min(Math.max(1, parseInt(req.query.max, 10)), 50) : BEDETHEQUE_DEFAULT_MAX;
  
  // Au moins un crit√®re de recherche requis
  if (!q && !serieId) {
    return res.status(400).json({ 
      error: "Au moins un param√®tre de recherche requis",
      hint: "Utilisez q (recherche) ou serieId + serieName. Utilisez /bedetheque/search pour trouver l'ID d'une s√©rie."
    });
  }
  
  try {
    const result = await searchBedethequeAlbumsLib(q, { max, serieId: serieId || null, serieName: serieName || null });
    addCacheHeaders(res, 600); // Cache 10 min car scraping
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/search/albums:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /bedetheque/serie/:id
 * R√©cup√®re les d√©tails d'une s√©rie Bedetheque par ID
 * 
 * :id - ID Bedetheque de la s√©rie (ex: 91 pour Ast√©rix)
 * 
 * Retourne les d√©tails incluant: synopsis, albums, auteurs, etc.
 * Note: Cette API utilise du scraping, certaines donn√©es peuvent √™tre incompl√®tes.
 */
app.get("/bedetheque/serie/:id", async (req, res) => {
  const serieId = req.params.id;
  
  if (!serieId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  if (!/^\d+$/.test(serieId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 91 pour Ast√©rix)"
    });
  }
  
  try {
    const result = await getBedethequeSerieByIdLib(parseInt(serieId, 10));
    if (!result || !result.name) {
      return res.status(404).json({ error: `S√©rie ${serieId} non trouv√©e` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/serie/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * GET /bedetheque/album/:id
 * R√©cup√®re les d√©tails d'un album Bedetheque par ID
 * 
 * :id - ID Bedetheque de l'album
 * 
 * Retourne les d√©tails incluant: synopsis, ISBN, auteurs, √©diteur, etc.
 * Note: Cette API utilise du scraping, certaines donn√©es peuvent √™tre incompl√®tes.
 */
app.get("/bedetheque/album/:id", async (req, res) => {
  let albumId = req.params.id;
  
  if (!albumId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  // Nettoyer les pr√©fixes courants
  albumId = cleanSourceId(albumId, 'bedetheque');
  
  if (!/^\d+$/.test(albumId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier"
    });
  }
  
  try {
    const result = await getBedethequeAlbumByIdLib(parseInt(albumId, 10));
    if (!result || !result.title) {
      return res.status(404).json({ error: `Album ${albumId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /bedetheque/album/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints JeuxVideo.com (JVC)
// -----------------------------

/**
 * @route GET /jvc/search
 * @description Recherche de jeux sur JeuxVideo.com (fran√ßais)
 * @param {string} q - Terme de recherche (obligatoire)
 * @param {number} max - Nombre max de r√©sultats (optionnel, d√©faut 20)
 */
app.get("/jvc/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : JVC_DEFAULT_MAX;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });
  
  try {
    const result = await searchJVCLib(q, { max });
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jvc/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * @route GET /jvc/game/:id
 * @description D√©tails d'un jeu sur JeuxVideo.com
 * @param {string} id - ID du jeu JVC (obligatoire)
 */
app.get("/jvc/game/:id", async (req, res) => {
  const gameId = req.params.id;
  
  if (!gameId) return res.status(400).json({ error: "param√®tre 'id' manquant" });
  
  if (!/^\d+$/.test(gameId)) {
    return res.status(400).json({ 
      error: "Format d'ID invalide",
      hint: "L'ID doit √™tre un nombre entier (ex: 77113)"
    });
  }
  
  try {
    const result = await getJVCGameByIdLib(parseInt(gameId, 10));
    if (!result || !result.title) {
      return res.status(404).json({ error: `Jeu ${gameId} non trouv√©` });
    }
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /jvc/game/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// -----------------------------
// Endpoints Mega Construx
// -----------------------------

/**
 * Recherche de produits Mega Construx
 * @route GET /mega/search
 * @queryparam q - Terme de recherche (requis)
 * @queryparam max - Nombre max de r√©sultats (d√©faut: 20, max: 100)
 * @queryparam page - Page de r√©sultats (d√©faut: 1)
 * @queryparam lang - Langue (fr-FR, en-US, de-DE, es-ES, it-IT, nl-NL, en-GB, etc.)
 */
app.get("/mega/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : MEGA_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const lang = req.query.lang || MEGA_DEFAULT_LANG;
  
  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    const result = await searchMegaLib(q, { max, page, lang });
    addCacheHeaders(res, 1800); // Cache 30 min
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * R√©cup√®re les d√©tails d'un produit Mega Construx par ID ou SKU
 * @route GET /mega/product/:id
 * @param id - ID Shopify ou SKU du produit
 * @queryparam lang - Langue (fr-FR, en-US, de-DE, es-ES, it-IT, nl-NL, en-GB, etc.)
 */
app.get("/mega/product/:id", async (req, res) => {
  const productId = req.params.id;
  const lang = req.query.lang || MEGA_DEFAULT_LANG;
  
  if (!productId) return res.status(400).json({ error: "ID ou SKU manquant" });
  
  try {
    const result = await getMegaProductByIdLib(productId, { lang });
    if (!result || !result.title) {
      return res.status(404).json({ error: `Produit ${productId} non trouv√©` });
    }
    
    // R√©cup√©rer automatiquement les manuels de construction
    // Utiliser le SKU du produit s'il existe, sinon le productId original
    // Les instructions sont uniquement sur le site US, donc on ignore la langue
    const skuForInstructions = result.sku || productId;
    if (skuForInstructions) {
      try {
        const instructionsResult = await getMegaInstructions(skuForInstructions);
        // getMegaInstructions retourne un objet unique avec instructionsUrl, on le convertit en tableau
        if (instructionsResult && instructionsResult.instructionsUrl) {
          result.instructions = [{
            url: instructionsResult.instructionsUrl,
            format: instructionsResult.format || 'PDF',
            productName: instructionsResult.productName
          }];
        } else {
          result.instructions = [];
        }
      } catch (instrErr) {
        // Si √©chec avec le SKU du produit, essayer avec le productId original si diff√©rent
        if (result.sku && result.sku.toUpperCase() !== productId.toUpperCase()) {
          try {
            const instructionsResult2 = await getMegaInstructions(productId);
            if (instructionsResult2 && instructionsResult2.instructionsUrl) {
              result.instructions = [{
                url: instructionsResult2.instructionsUrl,
                format: instructionsResult2.format || 'PDF',
                productName: instructionsResult2.productName
              }];
            } else {
              result.instructions = [];
            }
          } catch (instrErr2) {
            console.log(`Manuels non trouv√©s pour Mega ${productId}:`, instrErr2.message);
            result.instructions = [];
          }
        } else {
          console.log(`Manuels non trouv√©s pour Mega ${skuForInstructions}:`, instrErr.message);
          result.instructions = [];
        }
      }
    } else {
      result.instructions = [];
    }
    
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/product/:id:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * Liste les produits Mega par franchise/th√®me
 * @route GET /mega/franchise/:franchise
 * @param franchise - Nom de la franchise (pokemon, halo, barbie, hotwheels)
 * @queryparam max - Nombre max de r√©sultats (d√©faut: 20)
 * @queryparam page - Page de r√©sultats (d√©faut: 1)
 * @queryparam lang - Langue (fr-FR, en-US, de-DE, es-ES, it-IT, nl-NL, en-GB, etc.)
 */
app.get("/mega/franchise/:franchise", async (req, res) => {
  const franchise = req.params.franchise;
  const max = req.query.max ? parseInt(req.query.max, 10) : MEGA_DEFAULT_MAX;
  const page = req.query.page ? parseInt(req.query.page, 10) : 1;
  const lang = req.query.lang || MEGA_DEFAULT_LANG;
  
  // Mapping des franchises populaires
  const franchiseMap = {
    'pokemon': 'mega pokemon',
    'halo': 'mega halo',
    'barbie': 'mega barbie',
    'hotwheels': 'mega hot wheels',
    'hot-wheels': 'mega hot wheels',
    'bloks': 'mega bloks',
    'construx': 'mega construx'
  };
  
  const searchQuery = franchiseMap[franchise.toLowerCase()] || `mega ${franchise}`;
  
  try {
    const result = await searchMegaLib(searchQuery, { max, page, lang });
    result.franchise = franchise;
    addCacheHeaders(res, 1800);
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/franchise/:franchise:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * Liste les langues support√©es pour Mega Construx
 * @route GET /mega/languages
 */
app.get("/mega/languages", (req, res) => {
  const languages = {
    US: {
      region: 'Am√©rique',
      baseUrl: MEGA_BASE_URL_US,
      currency: 'USD',
      languages: ['en-US', 'es-MX', 'fr-CA', 'pt-BR', 'en-CA']
    },
    EU: {
      region: 'Europe',
      baseUrl: MEGA_BASE_URL_EU,
      currency: 'EUR',
      languages: ['fr-FR', 'de-DE', 'es-ES', 'it-IT', 'nl-NL', 'en-GB', 'pl-PL', 'tr-TR', 'el-GR', 'ru-RU']
    }
  };
  
  addCacheHeaders(res, 86400); // Cache 24h
  res.json({
    default: MEGA_DEFAULT_LANG,
    regions: languages,
    source: 'mega'
  });
});

/**
 * R√©cup√®re les instructions de montage pour un produit Mega par SKU
 * @route GET /mega/instructions/:sku
 * @param sku - SKU du produit (ex: HMW05, HTH96)
 */
app.get("/mega/instructions/:sku", async (req, res) => {
  const sku = req.params.sku;
  
  if (!sku) return res.status(400).json({ error: "SKU manquant" });
  
  try {
    const result = await getMegaInstructions(sku);
    addCacheHeaders(res, 86400); // Cache 24h
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/instructions/:sku:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©es')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * Liste toutes les instructions disponibles pour une cat√©gorie
 * @route GET /mega/instructions
 * @queryparam category - Cat√©gorie (pokemon, halo, barbie, hot-wheels, tesla, etc.)
 */
app.get("/mega/instructions", async (req, res) => {
  const category = req.query.category || '';
  
  try {
    const result = await listMegaInstructions(category);
    addCacheHeaders(res, 21600); // Cache 6h
    res.json(result);
  } catch (err) {
    console.error("Erreur /mega/instructions:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// ============================================================================
// BARCODE - Identification par code-barres (UPC, EAN, ISBN)
// ============================================================================

/**
 * D√©tecte le type de code-barres
 * @param {string} code - Code-barres
 * @returns {object} - Type et informations
 */
function detectBarcodeType(code) {
  // Nettoyer le code (retirer espaces et tirets)
  const cleanCode = code.replace(/[-\s]/g, '');
  
  // ISBN-10: 10 chiffres (ou 9 + X)
  if (/^(\d{9}[\dX])$/.test(cleanCode)) {
    return { type: 'ISBN-10', code: cleanCode, category: 'book' };
  }
  
  // ISBN-13: 13 chiffres commen√ßant par 978 ou 979
  if (/^(978|979)\d{10}$/.test(cleanCode)) {
    return { type: 'ISBN-13', code: cleanCode, category: 'book' };
  }
  
  // EAN-13: 13 chiffres
  if (/^\d{13}$/.test(cleanCode)) {
    // Pr√©fixes connus pour jeux vid√©o
    const prefix = cleanCode.substring(0, 3);
    // 500 = UK, 300-379 = France, 400-440 = Allemagne, 840-849 = Espagne, 800-839 = Italie
    // Certains pr√©fixes sont souvent utilis√©s pour les jeux vid√©o
    return { type: 'EAN-13', code: cleanCode, category: 'general' };
  }
  
  // UPC-A: 12 chiffres
  if (/^\d{12}$/.test(cleanCode)) {
    return { type: 'UPC-A', code: cleanCode, category: 'general' };
  }
  
  // EAN-8: 8 chiffres
  if (/^\d{8}$/.test(cleanCode)) {
    return { type: 'EAN-8', code: cleanCode, category: 'general' };
  }
  
  // Code inconnu
  return { type: 'unknown', code: cleanCode, category: 'unknown' };
}

/**
 * Convertit ISBN-10 en ISBN-13
 * @param {string} isbn10 - ISBN-10
 * @returns {string} - ISBN-13
 */
function isbn10ToIsbn13(isbn10) {
  const cleanIsbn = isbn10.replace(/[-\s]/g, '');
  if (cleanIsbn.length !== 10) return null;
  
  const isbn13Base = '978' + cleanIsbn.substring(0, 9);
  
  // Calculer le chiffre de contr√¥le ISBN-13
  let sum = 0;
  for (let i = 0; i < 12; i++) {
    sum += parseInt(isbn13Base[i]) * (i % 2 === 0 ? 1 : 3);
  }
  const checkDigit = (10 - (sum % 10)) % 10;
  
  return isbn13Base + checkDigit;
}

/**
 * Recherche un produit par UPC/EAN sur UPC Item DB
 * @param {string} code - Code UPC ou EAN
 * @returns {Promise<object>} - Informations produit
 */
async function searchUpcItemDb(code) {
  const url = `${UPCITEMDB_BASE_URL}?upc=${encodeURIComponent(code)}`;
  
  console.log(`[Barcode] UPC Item DB: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('Limite quotidienne UPC Item DB atteinte (100 req/jour)');
    }
    throw new Error(`Erreur UPC Item DB: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (data.code === 'OK' && data.items && data.items.length > 0) {
    const item = data.items[0];
    return {
      found: true,
      source: 'upcitemdb',
      barcode: code,
      title: item.title || null,
      description: item.description || null,
      brand: item.brand || null,
      category: item.category || null,
      images: item.images || [],
      offers: (item.offers || []).map(o => ({
        merchant: o.merchant,
        price: o.price,
        currency: o.currency || 'USD',
        link: o.link
      })),
      raw: item
    };
  }
  
  return { found: false, source: 'upcitemdb', barcode: code };
}

/**
 * Recherche un produit par UPC/EAN sur Open Food Facts
 * @param {string} code - Code UPC ou EAN
 * @returns {Promise<object>} - Informations produit
 */
async function searchOpenFoodFacts(code) {
  const url = `${OPENFOODFACTS_BASE_URL}/${encodeURIComponent(code)}.json`;
  
  console.log(`[Barcode] Open Food Facts: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': `ToysAPI/1.0 - Educational Project`
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Open Food Facts: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (data.status === 1 && data.product) {
    const p = data.product;
    return {
      found: true,
      source: 'openfoodfacts',
      barcode: code,
      title: p.product_name || p.product_name_fr || null,
      brand: p.brands || null,
      category: p.categories || null,
      image: p.image_url || p.image_front_url || null,
      quantity: p.quantity || null,
      ingredients: p.ingredients_text_fr || p.ingredients_text || null,
      nutriscore: p.nutriscore_grade || null,
      raw: p
    };
  }
  
  return { found: false, source: 'openfoodfacts', barcode: code };
}

/**
 * Recherche un livre par ISBN
 * @param {string} isbn - ISBN-10 ou ISBN-13
 * @param {string} googleBooksApiKey - Cl√© API Google Books (optionnelle)
 * @returns {Promise<object>} - Informations livre
 */
async function searchBookByIsbn(isbn, googleBooksApiKey = null, lang = null) {
  const results = {
    isbn: isbn,
    found: false,
    sources: [],
    lang: lang
  };
  
  // 1. OpenLibrary (gratuit, priorit√©)
  try {
    const olResult = await searchOpenLibraryByIsbn(isbn);
    if (olResult.books && olResult.books.length > 0) {
      const book = olResult.books[0];
      results.found = true;
      results.title = book.title;
      results.authors = book.authors;
      results.publisher = book.publisher;
      results.publishedDate = book.publishedDate;
      results.pageCount = book.pageCount;
      results.cover = book.thumbnail || book.cover;
      results.description = book.description;
      results.subjects = book.subjects;
      results.sources.push({
        name: 'openlibrary',
        data: book
      });
    }
  } catch (err) {
    console.error('[Barcode] OpenLibrary error:', err.message);
  }
  
  // 2. Google Books (si cl√© fournie)
  if (googleBooksApiKey) {
    try {
      let gbUrl = `${GOOGLE_BOOKS_BASE_URL}/volumes?q=isbn:${isbn}&key=${googleBooksApiKey}`;
      // Ajouter restriction de langue si sp√©cifi√©e (fr, en, de, etc.)
      if (lang) {
        const langCode = lang.substring(0, 2).toLowerCase();
        gbUrl += `&langRestrict=${langCode}`;
      }
      const gbResponse = await fetch(gbUrl);
      
      if (gbResponse.ok) {
        const gbData = await gbResponse.json();
        if (gbData.items && gbData.items.length > 0) {
          const vol = gbData.items[0].volumeInfo;
          results.found = true;
          if (!results.title) results.title = vol.title;
          if (!results.authors) results.authors = vol.authors;
          if (!results.publisher) results.publisher = vol.publisher;
          if (!results.publishedDate) results.publishedDate = vol.publishedDate;
          if (!results.pageCount) results.pageCount = vol.pageCount;
          if (!results.cover && vol.imageLinks) {
            results.cover = vol.imageLinks.thumbnail || vol.imageLinks.smallThumbnail;
          }
          if (!results.description) results.description = vol.description;
          
          results.sources.push({
            name: 'googlebooks',
            data: {
              id: gbData.items[0].id,
              title: vol.title,
              subtitle: vol.subtitle,
              authors: vol.authors,
              publisher: vol.publisher,
              publishedDate: vol.publishedDate,
              description: vol.description,
              pageCount: vol.pageCount,
              categories: vol.categories,
              averageRating: vol.averageRating,
              ratingsCount: vol.ratingsCount,
              imageLinks: vol.imageLinks,
              language: vol.language,
              previewLink: vol.previewLink,
              infoLink: vol.infoLink
            }
          });
        }
      }
    } catch (err) {
      console.error('[Barcode] Google Books error:', err.message);
    }
  }
  
  // 3. BNF (Biblioth√®que Nationale de France) pour livres fran√ßais
  try {
    const bnfResult = await searchBnfByIsbn(isbn);
    if (bnfResult.found) {
      results.found = true;
      if (!results.title) results.title = bnfResult.title;
      if (!results.authors) results.authors = bnfResult.authors;
      if (!results.publisher) results.publisher = bnfResult.publisher;
      if (!results.publishedDate) results.publishedDate = bnfResult.date;
      
      results.sources.push({
        name: 'bnf',
        data: bnfResult
      });
    }
  } catch (err) {
    console.error('[Barcode] BNF error:', err.message);
  }
  
  return results;
}

/**
 * Recherche un livre sur la BNF par ISBN
 * @param {string} isbn - ISBN
 * @returns {Promise<object>} - R√©sultat BNF
 */
async function searchBnfByIsbn(isbn) {
  // API SRU de la BNF
  const cleanIsbn = isbn.replace(/[-\s]/g, '');
  const url = `https://catalogue.bnf.fr/api/SRU?version=1.2&operation=searchRetrieve&query=bib.isbn%20adj%20%22${encodeURIComponent(cleanIsbn)}%22&recordSchema=dublincore&maximumRecords=1`;
  
  console.log(`[Barcode] BNF: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/xml',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur BNF: ${response.status}`);
  }
  
  const xml = await response.text();
  
  // Parser le XML simple (Dublin Core)
  const titleMatch = xml.match(/<dc:title>([^<]+)<\/dc:title>/);
  const creatorMatch = xml.match(/<dc:creator>([^<]+)<\/dc:creator>/g);
  const publisherMatch = xml.match(/<dc:publisher>([^<]+)<\/dc:publisher>/);
  const dateMatch = xml.match(/<dc:date>([^<]+)<\/dc:date>/);
  const descMatch = xml.match(/<dc:description>([^<]+)<\/dc:description>/);
  const subjectMatch = xml.match(/<dc:subject>([^<]+)<\/dc:subject>/g);
  
  if (titleMatch) {
    return {
      found: true,
      source: 'bnf',
      isbn: cleanIsbn,
      title: decodeHtmlEntities(titleMatch[1]),
      authors: creatorMatch ? creatorMatch.map(m => {
        const match = m.match(/<dc:creator>([^<]+)<\/dc:creator>/);
        return match ? decodeHtmlEntities(match[1]) : null;
      }).filter(Boolean) : [],
      publisher: publisherMatch ? decodeHtmlEntities(publisherMatch[1]) : null,
      date: dateMatch ? dateMatch[1] : null,
      description: descMatch ? decodeHtmlEntities(descMatch[1]) : null,
      subjects: subjectMatch ? subjectMatch.map(m => {
        const match = m.match(/<dc:subject>([^<]+)<\/dc:subject>/);
        return match ? decodeHtmlEntities(match[1]) : null;
      }).filter(Boolean) : []
    };
  }
  
  return { found: false, source: 'bnf', isbn: cleanIsbn };
}

/**
 * Tente d'identifier un jeu vid√©o √† partir des infos produit
 * @param {object} productInfo - Infos du produit (title, category, brand)
 * @param {object} apiKeys - Cl√©s API optionnelles
 * @returns {Promise<object|null>} - Infos jeu vid√©o ou null
 */
async function tryIdentifyVideoGame(productInfo, apiKeys = {}) {
  if (!productInfo.title) return null;
  
  const title = productInfo.title;
  const category = (productInfo.category || '').toLowerCase();
  const brand = (productInfo.brand || '').toLowerCase();
  
  // Mots-cl√©s sugg√©rant un jeu vid√©o
  const gameKeywords = ['game', 'jeu', 'video', 'nintendo', 'playstation', 'xbox', 'ps4', 'ps5', 'switch', 'steam', 'pc game', 'console'];
  const isLikelyGame = gameKeywords.some(kw => 
    title.toLowerCase().includes(kw) || category.includes(kw) || brand.includes(kw)
  );
  
  if (!isLikelyGame) return null;
  
  // Extraire le nom du jeu (retirer plateforme, √©dition, etc.)
  let gameName = title
    .replace(/\b(ps[345]|xbox|switch|nintendo|pc|steam|playstation|edition|day one|collector|goty|game of the year)\b/gi, '')
    .replace(/\s{2,}/g, ' ')
    .trim();
  
  // Essayer RAWG si cl√© disponible
  if (apiKeys.rawg) {
    try {
      const rawgUrl = `${RAWG_BASE_URL}/games?key=${apiKeys.rawg}&search=${encodeURIComponent(gameName)}&page_size=1`;
      const response = await fetch(rawgUrl);
      if (response.ok) {
        const data = await response.json();
        if (data.results && data.results.length > 0) {
          const game = data.results[0];
          return {
            identified: true,
            source: 'rawg',
            game: {
              id: game.id,
              name: game.name,
              slug: game.slug,
              released: game.released,
              rating: game.rating,
              platforms: game.platforms?.map(p => p.platform.name) || [],
              genres: game.genres?.map(g => g.name) || [],
              background_image: game.background_image
            }
          };
        }
      }
    } catch (err) {
      console.error('[Barcode] RAWG identification error:', err.message);
    }
  }
  
  // Essayer JVC (scraping) pour les jeux fran√ßais
  try {
    const jvcResult = await searchJVC(gameName, { maxResults: 1 });
    if (jvcResult.results && jvcResult.results.length > 0) {
      const game = jvcResult.results[0];
      return {
        identified: true,
        source: 'jvc',
        game: {
          id: game.id,
          name: game.title,
          url: game.url,
          platforms: game.platforms || [],
          releaseDate: game.releaseDate,
          image: game.image
        }
      };
    }
  } catch (err) {
    console.error('[Barcode] JVC identification error:', err.message);
  }
  
  return null;
}

/**
 * Recherche compl√®te par code-barres
 * @param {string} code - Code-barres (UPC, EAN, ISBN)
 * @param {object} options - Options (apiKeys, enrichGameData)
 * @returns {Promise<object>} - R√©sultat complet
 */
async function searchByBarcode(code, options = {}) {
  const { apiKeys = {}, enrichGameData = true, enrichMusicData = true } = options;
  
  const barcodeInfo = detectBarcodeType(code);
  
  const result = {
    barcode: barcodeInfo.code,
    barcodeType: barcodeInfo.type,
    category: barcodeInfo.category,
    product: null,
    book: null,
    videoGame: null,
    music: null,
    sources: [],
    searchedAt: new Date().toISOString()
  };
  
  // === Traitement ISBN (Livres) ===
  if (barcodeInfo.category === 'book' || barcodeInfo.type === 'ISBN-10' || barcodeInfo.type === 'ISBN-13') {
    let isbn = barcodeInfo.code;
    if (barcodeInfo.type === 'ISBN-10') {
      // Convertir en ISBN-13 pour plus de compatibilit√©
      const isbn13 = isbn10ToIsbn13(isbn);
      result.isbn10 = isbn;
      result.isbn13 = isbn13;
      isbn = isbn13 || isbn;
    } else {
      result.isbn13 = isbn;
    }
    
    const bookResult = await searchBookByIsbn(isbn, apiKeys.googleBooks);
    
    if (bookResult.found) {
      result.category = 'book';
      result.book = {
        title: bookResult.title,
        authors: bookResult.authors,
        publisher: bookResult.publisher,
        publishedDate: bookResult.publishedDate,
        pageCount: bookResult.pageCount,
        cover: bookResult.cover,
        description: bookResult.description,
        subjects: bookResult.subjects
      };
      result.sources = bookResult.sources.map(s => s.name);
    }
    
    return result;
  }
  
  // === Traitement UPC/EAN (Produits g√©n√©raux) ===
  
  // 1. UPC Item DB (base g√©n√©raliste)
  try {
    const upcResult = await searchUpcItemDb(barcodeInfo.code);
    if (upcResult.found) {
      result.product = {
        title: upcResult.title,
        description: upcResult.description,
        brand: upcResult.brand,
        category: upcResult.category,
        images: upcResult.images,
        offers: upcResult.offers
      };
      result.sources.push('upcitemdb');
      
      // Tenter d'identifier comme jeu vid√©o
      if (enrichGameData) {
        const gameInfo = await tryIdentifyVideoGame(upcResult, apiKeys);
        if (gameInfo) {
          result.category = 'videogame';
          result.videoGame = gameInfo;
        }
      }
      
      // Tenter d'identifier comme musique (CD, vinyle)
      if (enrichMusicData && !result.videoGame) {
        const musicInfo = await tryIdentifyMusic(upcResult, barcodeInfo.code);
        if (musicInfo) {
          result.category = 'music';
          result.music = musicInfo;
        }
      }
    }
  } catch (err) {
    console.error('[Barcode] UPC Item DB error:', err.message);
    // Continue avec d'autres sources
  }
  
  // 2. Open Food Facts (pour produits alimentaires)
  if (!result.product) {
    try {
      const offResult = await searchOpenFoodFacts(barcodeInfo.code);
      if (offResult.found) {
        result.product = {
          title: offResult.title,
          brand: offResult.brand,
          category: offResult.category,
          images: offResult.image ? [offResult.image] : [],
          quantity: offResult.quantity,
          nutriscore: offResult.nutriscore
        };
        result.category = 'food';
        result.sources.push('openfoodfacts');
      }
    } catch (err) {
      console.error('[Barcode] Open Food Facts error:', err.message);
    }
  }
  
  // 3. Fallback Musique: Si rien trouv√©, tenter directement sur MusicBrainz/Discogs
  if (!result.product && !result.book && enrichMusicData) {
    try {
      const musicResult = await searchMusicByBarcode(barcodeInfo.code, apiKeys.discogs);
      if (musicResult.found) {
        result.category = 'music';
        result.music = musicResult;
        result.sources.push(...musicResult.sources);
      }
    } catch (err) {
      console.error('[Barcode] Music fallback error:', err.message);
    }
  }
  
  // D√©terminer si produit trouv√©
  result.found = !!(result.product || result.book || result.videoGame || result.music);
  
  return result;
}

/**
 * Tente d'identifier un album de musique √† partir des infos produit
 * @param {object} productInfo - Infos du produit (title, category, brand)
 * @param {string} barcode - Code-barres original
 * @returns {Promise<object|null>} - Infos musique ou null
 */
async function tryIdentifyMusic(productInfo, barcode) {
  if (!productInfo.title) return null;
  
  const title = productInfo.title.toLowerCase();
  const category = (productInfo.category || '').toLowerCase();
  const brand = (productInfo.brand || '').toLowerCase();
  
  // Mots-cl√©s sugg√©rant un CD/vinyle/musique
  const musicKeywords = [
    'cd', 'vinyl', 'vinyle', 'album', 'lp', 'ep', 'record', 'disque',
    'music', 'musique', 'audio', 'soundtrack', 'ost', 'compilation',
    'sony music', 'universal music', 'warner music', 'emi', 'bmg',
    'atlantic', 'columbia', 'rca', 'decca', 'polydor', 'virgin',
    'parlophone', 'capitol', 'interscope', 'def jam', 'island'
  ];
  
  const isLikelyMusic = musicKeywords.some(kw => 
    title.includes(kw) || category.includes(kw) || brand.includes(kw)
  );
  
  if (!isLikelyMusic) return null;
  
  // Rechercher sur MusicBrainz par code-barres
  try {
    const mbResult = await searchMusicBrainzByBarcode(barcode);
    if (mbResult.found) {
      return {
        identified: true,
        source: 'musicbrainz',
        title: mbResult.title,
        artist: mbResult.artist,
        releaseDate: mbResult.date,
        label: mbResult.label,
        coverUrl: mbResult.coverUrl,
        mbId: mbResult.id,
        releaseGroupId: mbResult.releaseGroupId,
        mbUrl: mbResult.mbUrl,
        sources: ['musicbrainz']
      };
    }
  } catch (err) {
    console.error('[Barcode] MusicBrainz identification error:', err.message);
  }
  
  return null;
}

/**
 * Recherche directe de musique par code-barres (MusicBrainz + Discogs)
 * @param {string} barcode - Code-barres
 * @param {string} discogsToken - Token Discogs (optionnel)
 * @returns {Promise<object>} - R√©sultat musique
 */
async function searchMusicByBarcode(barcode, discogsToken = null) {
  const result = {
    found: false,
    barcode,
    sources: []
  };
  
  // 1. MusicBrainz
  try {
    metrics.sources.musicbrainz.requests++;
    const mbResult = await searchMusicBrainzByBarcode(barcode);
    if (mbResult.found) {
      result.found = true;
      result.title = mbResult.title;
      result.artist = mbResult.artist;
      result.releaseDate = mbResult.date;
      result.country = mbResult.country;
      result.label = mbResult.label;
      result.catalogNumber = mbResult.catalogNumber;
      result.coverUrl = mbResult.coverUrl;
      result.mbId = mbResult.id;
      result.releaseGroupId = mbResult.releaseGroupId;
      result.mbUrl = mbResult.mbUrl;
      result.sources.push('musicbrainz');
    }
  } catch (err) {
    console.error('[Barcode] MusicBrainz error:', err.message);
  }
  
  // 2. Discogs (compl√©ment ou fallback)
  try {
    metrics.sources.discogs.requests++;
    const discogsResult = await searchDiscogsByBarcode(barcode, discogsToken);
    if (discogsResult.found) {
      result.found = true;
      result.sources.push('discogs');
      
      // Compl√©ter les donn√©es manquantes
      if (!result.title) result.title = discogsResult.albumTitle;
      if (!result.artist) result.artist = discogsResult.artist;
      if (!result.coverUrl) result.coverUrl = discogsResult.coverUrl;
      if (!result.releaseDate && discogsResult.year) result.releaseDate = discogsResult.year.toString();
      
      // Donn√©es sp√©cifiques Discogs
      result.discogs = {
        id: discogsResult.id,
        format: discogsResult.format,
        label: discogsResult.label,
        genre: discogsResult.genre,
        country: discogsResult.country,
        url: discogsResult.discogsUrl
      };
    }
  } catch (err) {
    console.error('[Barcode] Discogs error:', err.message);
  }
  
  return result;
}

// === Endpoint principal code-barres ===
/**
 * Recherche par code-barres (livres, jeux vid√©o, musique, produits)
 * @route GET /barcode/:code
 * @param code - Code-barres (UPC, EAN, ISBN)
 * @queryparam googleBooksKey - Cl√© API Google Books (optionnel, header: X-GoogleBooks-Key)
 * @queryparam rawgKey - Cl√© API RAWG (optionnel, header: X-RAWG-Key)
 * @queryparam discogsToken - Token Discogs (optionnel, header: X-Discogs-Token)
 * @queryparam enrichGames - Enrichir avec donn√©es jeux vid√©o (true/false, d√©faut: true)
 * @queryparam enrichMusic - Enrichir avec donn√©es musique (true/false, d√©faut: true)
 */
app.get("/barcode/:code", async (req, res) => {
  const { code } = req.params;
  const googleBooksKey = req.query.googleBooksKey || req.headers['x-googlebooks-key'];
  const rawgKey = req.query.rawgKey || req.headers['x-rawg-key'];
  const discogsToken = req.query.discogsToken || req.headers['x-discogs-token'];
  // Support ancien param√®tre 'enrich' + nouveaux param√®tres sp√©cifiques
  const enrichGames = req.query.enrichGames !== 'false' && req.query.enrich !== 'false';
  const enrichMusic = req.query.enrichMusic !== 'false' && req.query.enrich !== 'false';
  
  if (!code || code.length < 8) {
    return res.status(400).json({ error: "Code-barres invalide (minimum 8 caract√®res)" });
  }
  
  // Cache key
  const cacheKey = `barcode:${code}:g${enrichGames}:m${enrichMusic}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.barcode.requests++;
    
    const result = await searchByBarcode(code, {
      apiKeys: {
        googleBooks: googleBooksKey,
        rawg: rawgKey,
        discogs: discogsToken
      },
      enrichGameData: enrichGames,
      enrichMusicData: enrichMusic
    });
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /barcode:", err);
    metrics.requests.errors++;
    metrics.sources.barcode.errors++;
    res.status(500).json({ error: err.message });
  }
});

// === Endpoint d√©tection type code-barres ===
/**
 * D√©tecte le type d'un code-barres
 * @route GET /barcode/detect/:code
 */
app.get("/barcode/detect/:code", (req, res) => {
  const { code } = req.params;
  
  if (!code || code.length < 8) {
    return res.status(400).json({ error: "Code-barres invalide" });
  }
  
  const info = detectBarcodeType(code);
  res.json(info);
});

// === Endpoint ISBN sp√©cifique (BNF + OpenLibrary + Google Books) ===
/**
 * Recherche un livre par ISBN
 * @route GET /barcode/isbn/:isbn
 * @param isbn - ISBN-10 ou ISBN-13
 * @queryparam googleBooksKey - Cl√© API Google Books (optionnel)
 * @queryparam lang - Langue pr√©f√©r√©e pour les r√©sultats (fr, en, de, etc.)
 */
app.get("/barcode/isbn/:isbn", async (req, res) => {
  const { isbn } = req.params;
  const googleBooksKey = req.query.googleBooksKey || req.headers['x-googlebooks-key'];
  const lang = req.query.lang || null;
  
  if (!isbn || isbn.replace(/[-\s]/g, '').length < 10) {
    return res.status(400).json({ error: "ISBN invalide" });
  }
  
  const cacheKey = `barcode:isbn:${isbn}:${lang || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.barcode.requests++;
    const result = await searchBookByIsbn(isbn, googleBooksKey, lang);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /barcode/isbn:", err);
    metrics.requests.errors++;
    metrics.sources.barcode.errors++;
    res.status(500).json({ error: err.message });
  }
});

// === Endpoint BNF (Biblioth√®que Nationale de France) ===
/**
 * Recherche un livre sur la BNF
 * @route GET /barcode/bnf/:isbn
 * @param isbn - ISBN du livre
 */
app.get("/barcode/bnf/:isbn", async (req, res) => {
  const { isbn } = req.params;
  
  if (!isbn || isbn.replace(/[-\s]/g, '').length < 10) {
    return res.status(400).json({ error: "ISBN invalide" });
  }
  
  const cacheKey = `barcode:bnf:${isbn}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.barcode.requests++;
    const result = await searchBnfByIsbn(isbn);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 86400); // Cache 24h (donn√©es BNF stables)
    res.json(result);
  } catch (err) {
    console.error("Erreur /barcode/bnf:", err);
    metrics.requests.errors++;
    metrics.sources.barcode.errors++;
    res.status(500).json({ error: err.message });
  }
});

// ============================================================================
// MUSIC - APIs pour albums de musique (MusicBrainz, Discogs, Deezer)
// ============================================================================

/**
 * Recherche sur MusicBrainz (release-group = album)
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, artist, type)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchMusicBrainz(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, artist = null, type = 'release-group' } = options;
  
  // Construire la requ√™te Lucene
  let luceneQuery = query;
  if (artist) {
    luceneQuery = `"${query}" AND artist:"${artist}"`;
  }
  
  const url = `${MUSICBRAINZ_BASE_URL}/${type}?query=${encodeURIComponent(luceneQuery)}&limit=${limit}&fmt=json`;
  
  console.log(`[MusicBrainz] Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)' // MusicBrainz exige un User-Agent identifiable
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const data = await response.json();
  const groups = data['release-groups'] || [];
  
  const results = groups.map(rg => ({
    id: rg.id,
    type: 'album',
    title: rg.title,
    artist: rg['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    artistId: rg['artist-credit']?.[0]?.artist?.id || null,
    releaseDate: rg['first-release-date'] || null,
    year: rg['first-release-date']?.substring(0, 4) || null,
    primaryType: rg['primary-type'] || null,
    secondaryTypes: rg['secondary-types'] || [],
    score: rg.score || null,
    // Cover art sera r√©cup√©r√© s√©par√©ment si besoin
    coverUrl: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-250`,
    coverUrlLarge: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-500`,
    mbUrl: `https://musicbrainz.org/release-group/${rg.id}`,
    source: 'musicbrainz'
  }));
  
  return {
    query,
    totalResults: data.count || results.length,
    count: results.length,
    results,
    source: 'musicbrainz'
  };
}

/**
 * R√©cup√®re les d√©tails d'un album MusicBrainz
 * @param {string} mbid - MusicBrainz ID (release-group)
 * @returns {Promise<object>} - D√©tails album
 */
async function getMusicBrainzAlbum(mbid) {
  const url = `${MUSICBRAINZ_BASE_URL}/release-group/${mbid}?inc=artists+releases+tags+ratings&fmt=json`;
  
  console.log(`[MusicBrainz] Album: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Album non trouv√©: ${mbid}`);
    }
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const rg = await response.json();
  
  // R√©cup√©rer la liste des pistes du premier release
  let tracks = [];
  if (rg.releases && rg.releases.length > 0) {
    try {
      const releaseId = rg.releases[0].id;
      const releaseUrl = `${MUSICBRAINZ_BASE_URL}/release/${releaseId}?inc=recordings&fmt=json`;
      const releaseResp = await fetch(releaseUrl, {
        headers: {
          'Accept': 'application/json',
          'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
        }
      });
      if (releaseResp.ok) {
        const releaseData = await releaseResp.json();
        if (releaseData.media) {
          tracks = releaseData.media.flatMap((medium, mediumIdx) =>
            (medium.tracks || []).map((track, trackIdx) => ({
              position: track.position || trackIdx + 1,
              disc: mediumIdx + 1,
              title: track.title,
              duration: track.length ? Math.round(track.length / 1000) : null, // ms -> sec
              durationFormatted: track.length ? formatDuration(track.length) : null
            }))
          );
        }
      }
    } catch (err) {
      console.error('[MusicBrainz] Error fetching tracks:', err.message);
    }
  }
  
  return {
    id: rg.id,
    type: 'album',
    title: rg.title,
    artist: rg['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    artists: rg['artist-credit']?.map(ac => ({
      id: ac.artist?.id,
      name: ac.name || ac.artist?.name,
      joinPhrase: ac.joinphrase
    })) || [],
    releaseDate: rg['first-release-date'] || null,
    year: rg['first-release-date']?.substring(0, 4) || null,
    primaryType: rg['primary-type'] || null,
    secondaryTypes: rg['secondary-types'] || [],
    tags: (rg.tags || []).map(t => ({ name: t.name, count: t.count })).sort((a, b) => b.count - a.count),
    rating: rg.rating ? { value: rg.rating.value, votes: rg.rating['votes-count'] } : null,
    releases: (rg.releases || []).slice(0, 10).map(r => ({
      id: r.id,
      title: r.title,
      status: r.status,
      date: r.date,
      country: r.country,
      barcode: r.barcode
    })),
    tracks,
    trackCount: tracks.length,
    coverUrl: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-250`,
    coverUrlLarge: `${MUSICBRAINZ_COVER_URL}/release-group/${rg.id}/front-500`,
    mbUrl: `https://musicbrainz.org/release-group/${rg.id}`,
    source: 'musicbrainz'
  };
}

/**
 * Recherche un album par code-barres sur MusicBrainz
 * @param {string} barcode - Code-barres (UPC/EAN)
 * @returns {Promise<object>} - Album trouv√©
 */
async function searchMusicBrainzByBarcode(barcode) {
  const url = `${MUSICBRAINZ_BASE_URL}/release?query=barcode:${encodeURIComponent(barcode)}&fmt=json`;
  
  console.log(`[MusicBrainz] Barcode: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0 (contact@example.com)'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur MusicBrainz: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.releases || data.releases.length === 0) {
    return { found: false, barcode, source: 'musicbrainz' };
  }
  
  const release = data.releases[0];
  
  return {
    found: true,
    barcode,
    id: release.id,
    releaseGroupId: release['release-group']?.id,
    title: release.title,
    artist: release['artist-credit']?.map(ac => ac.name || ac.artist?.name).join(', ') || null,
    date: release.date,
    country: release.country,
    status: release.status,
    label: release['label-info']?.[0]?.label?.name || null,
    catalogNumber: release['label-info']?.[0]?.['catalog-number'] || null,
    coverUrl: release['release-group']?.id 
      ? `${MUSICBRAINZ_COVER_URL}/release-group/${release['release-group'].id}/front-250` 
      : null,
    mbUrl: `https://musicbrainz.org/release/${release.id}`,
    source: 'musicbrainz'
  };
}

/**
 * Formate une dur√©e en ms vers "mm:ss"
 */
function formatDuration(ms) {
  const totalSeconds = Math.round(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
}

/**
 * Recherche sur Deezer
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, type: album|artist|track)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchDeezer(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, type = 'album' } = options;
  
  const url = `${DEEZER_BASE_URL}/search/${type}?q=${encodeURIComponent(query)}&limit=${limit}`;
  
  console.log(`[Deezer] Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Deezer: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (data.error) {
    throw new Error(`Deezer: ${data.error.message}`);
  }
  
  const results = (data.data || []).map(item => {
    if (type === 'album') {
      return {
        id: item.id,
        type: 'album',
        title: item.title,
        artist: item.artist?.name || null,
        artistId: item.artist?.id || null,
        coverUrl: item.cover_medium || item.cover,
        coverUrlLarge: item.cover_xl || item.cover_big,
        releaseDate: null, // Non disponible dans la recherche
        trackCount: item.nb_tracks || null,
        explicit: item.explicit_lyrics || false,
        genre: item.genre_id || null,
        deezerUrl: item.link,
        source: 'deezer'
      };
    } else if (type === 'artist') {
      return {
        id: item.id,
        type: 'artist',
        name: item.name,
        picture: item.picture_medium,
        pictureXl: item.picture_xl,
        nbAlbums: item.nb_album,
        nbFans: item.nb_fan,
        deezerUrl: item.link,
        source: 'deezer'
      };
    } else {
      // track
      return {
        id: item.id,
        type: 'track',
        title: item.title,
        artist: item.artist?.name,
        album: item.album?.title,
        albumId: item.album?.id,
        duration: item.duration,
        durationFormatted: formatDuration(item.duration * 1000),
        preview: item.preview, // URL MP3 30sec
        explicit: item.explicit_lyrics,
        deezerUrl: item.link,
        source: 'deezer'
      };
    }
  });
  
  return {
    query,
    type,
    totalResults: data.total || results.length,
    count: results.length,
    results,
    source: 'deezer'
  };
}

/**
 * R√©cup√®re les d√©tails d'un album Deezer
 * @param {number|string} albumId - ID album Deezer
 * @returns {Promise<object>} - D√©tails album
 */
async function getDeezerAlbum(albumId) {
  // Nettoyer l'ID (supprimer pr√©fixe music_ si pr√©sent)
  const cleanId = String(albumId).replace(/^music_/i, '');
  const url = `${DEEZER_BASE_URL}/album/${cleanId}`;
  
  console.log(`[Deezer] Album: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Album non trouv√©: ${albumId}`);
    }
    throw new Error(`Erreur Deezer: ${response.status}`);
  }
  
  const album = await response.json();
  
  if (album.error) {
    throw new Error(`Deezer: ${album.error.message || album.error.type || 'no data'}`);
  }
  
  if (!album.id) {
    throw new Error(`Deezer: Album non trouv√© (ID: ${cleanId})`);
  }
  
  return {
    id: album.id,
    type: 'album',
    title: album.title,
    upc: album.upc || null,
    artist: album.artist?.name || null,
    artistId: album.artist?.id || null,
    artistPicture: album.artist?.picture_medium || null,
    coverUrl: album.cover_medium || album.cover,
    coverUrlLarge: album.cover_xl || album.cover_big,
    releaseDate: album.release_date || null,
    year: album.release_date?.substring(0, 4) || null,
    duration: album.duration || null,
    durationFormatted: album.duration ? formatDuration(album.duration * 1000) : null,
    trackCount: album.nb_tracks || 0,
    fans: album.fans || 0,
    explicit: album.explicit_lyrics || false,
    genres: (album.genres?.data || []).map(g => g.name),
    label: album.label || null,
    tracks: (album.tracks?.data || []).map((t, idx) => ({
      position: idx + 1,
      id: t.id,
      title: t.title,
      duration: t.duration,
      durationFormatted: formatDuration(t.duration * 1000),
      preview: t.preview,
      explicit: t.explicit_lyrics
    })),
    contributors: (album.contributors || []).map(c => ({
      id: c.id,
      name: c.name,
      role: c.role,
      picture: c.picture_medium
    })),
    deezerUrl: album.link,
    source: 'deezer'
  };
}

/**
 * R√©cup√®re les d√©tails d'un artiste Deezer
 * @param {number|string} artistId - ID artiste Deezer
 * @returns {Promise<object>} - D√©tails artiste
 */
async function getDeezerArtist(artistId) {
  // Nettoyer l'ID (supprimer pr√©fixe music_ si pr√©sent)
  const cleanId = String(artistId).replace(/^music_/i, '');
  
  // R√©cup√©rer info artiste + top tracks + albums
  const [artistResp, topResp, albumsResp] = await Promise.all([
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}`),
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}/top?limit=10`),
    fetch(`${DEEZER_BASE_URL}/artist/${cleanId}/albums?limit=50`)
  ]);
  
  if (!artistResp.ok) {
    if (artistResp.status === 404) {
      throw new Error(`Artiste non trouv√©: ${artistId}`);
    }
    throw new Error(`Erreur Deezer: ${artistResp.status}`);
  }
  
  const artist = await artistResp.json();
  const topTracks = topResp.ok ? await topResp.json() : { data: [] };
  const albums = albumsResp.ok ? await albumsResp.json() : { data: [] };
  
  return {
    id: artist.id,
    type: 'artist',
    name: artist.name,
    picture: artist.picture_medium,
    pictureXl: artist.picture_xl,
    nbAlbums: artist.nb_album,
    nbFans: artist.nb_fan,
    topTracks: (topTracks.data || []).map(t => ({
      id: t.id,
      title: t.title,
      duration: t.duration,
      durationFormatted: formatDuration(t.duration * 1000),
      album: t.album?.title,
      albumCover: t.album?.cover_medium,
      preview: t.preview,
      rank: t.rank
    })),
    albums: (albums.data || []).map(a => ({
      id: a.id,
      title: a.title,
      coverUrl: a.cover_medium,
      releaseDate: a.release_date,
      type: a.record_type // album, single, ep, etc.
    })),
    deezerUrl: artist.link,
    source: 'deezer'
  };
}

/**
 * Recherche sur Discogs
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, type, token)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchDiscogs(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, type = 'release', token = null } = options;
  
  let url = `${DISCOGS_BASE_URL}/database/search?q=${encodeURIComponent(query)}&type=${type}&per_page=${limit}`;
  
  // Ajouter token si fourni (augmente la limite de requ√™tes)
  if (token) {
    url += `&token=${token}`;
  }
  
  console.log(`[Discogs] Search: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    if (response.status === 429) {
      throw new Error('Limite Discogs atteinte (60 req/min avec token, 25 sans)');
    }
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const data = await response.json();
  
  const results = (data.results || []).map(item => ({
    id: item.id,
    type: item.type,
    title: item.title,
    artist: item.title?.split(' - ')[0] || null,
    albumTitle: item.title?.split(' - ')[1] || item.title,
    year: item.year || null,
    country: item.country || null,
    format: item.format || [],
    label: item.label || [],
    genre: item.genre || [],
    style: item.style || [],
    coverUrl: item.cover_image || item.thumb,
    masterId: item.master_id || null,
    resourceUrl: item.resource_url,
    discogsUrl: item.uri ? `https://www.discogs.com${item.uri}` : null,
    source: 'discogs'
  }));
  
  return {
    query,
    type,
    totalResults: data.pagination?.items || results.length,
    count: results.length,
    page: data.pagination?.page || 1,
    totalPages: data.pagination?.pages || 1,
    results,
    source: 'discogs'
  };
}

/**
 * R√©cup√®re les d√©tails d'un release Discogs
 * @param {number|string} releaseId - ID release Discogs
 * @param {string} token - Token Discogs (optionnel)
 * @returns {Promise<object>} - D√©tails release
 */
async function getDiscogsRelease(releaseId, token = null) {
  let url = `${DISCOGS_BASE_URL}/releases/${releaseId}`;
  if (token) {
    url += `?token=${token}`;
  }
  
  console.log(`[Discogs] Release: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Release non trouv√©e: ${releaseId}`);
    }
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const release = await response.json();
  
  return {
    id: release.id,
    type: 'release',
    title: release.title,
    artists: (release.artists || []).map(a => ({
      id: a.id,
      name: a.name,
      role: a.role
    })),
    artist: (release.artists || []).map(a => a.name).join(', '),
    year: release.year || null,
    releaseDate: release.released || null,
    country: release.country || null,
    genres: release.genres || [],
    styles: release.styles || [],
    formats: (release.formats || []).map(f => ({
      name: f.name,
      qty: f.qty,
      descriptions: f.descriptions
    })),
    labels: (release.labels || []).map(l => ({
      id: l.id,
      name: l.name,
      catno: l.catno
    })),
    tracklist: (release.tracklist || []).map(t => ({
      position: t.position,
      title: t.title,
      duration: t.duration,
      artists: t.artists?.map(a => a.name)
    })),
    trackCount: release.tracklist?.length || 0,
    notes: release.notes || null,
    images: (release.images || []).map(img => ({
      type: img.type,
      uri: img.uri,
      uri150: img.uri150
    })),
    coverUrl: release.images?.[0]?.uri150 || release.thumb,
    coverUrlLarge: release.images?.[0]?.uri || null,
    masterId: release.master_id || null,
    masterUrl: release.master_url || null,
    // Prix du march√© (si disponible)
    lowestPrice: release.lowest_price || null,
    numForSale: release.num_for_sale || 0,
    community: release.community ? {
      have: release.community.have,
      want: release.community.want,
      rating: release.community.rating?.average,
      ratingCount: release.community.rating?.count
    } : null,
    discogsUrl: release.uri,
    source: 'discogs'
  };
}

/**
 * Recherche par code-barres sur Discogs
 * @param {string} barcode - Code-barres
 * @param {string} token - Token Discogs (optionnel)
 * @returns {Promise<object>} - Release trouv√©e
 */
async function searchDiscogsByBarcode(barcode, token = null) {
  let url = `${DISCOGS_BASE_URL}/database/search?barcode=${encodeURIComponent(barcode)}&type=release`;
  if (token) {
    url += `&token=${token}`;
  }
  
  console.log(`[Discogs] Barcode: ${url.replace(/token=[^&]+/, 'token=***')}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': 'ToysAPI/1.0'
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur Discogs: ${response.status}`);
  }
  
  const data = await response.json();
  
  if (!data.results || data.results.length === 0) {
    return { found: false, barcode, source: 'discogs' };
  }
  
  const item = data.results[0];
  
  return {
    found: true,
    barcode,
    id: item.id,
    title: item.title,
    artist: item.title?.split(' - ')[0] || null,
    albumTitle: item.title?.split(' - ')[1] || item.title,
    year: item.year,
    country: item.country,
    format: item.format,
    label: item.label,
    genre: item.genre,
    coverUrl: item.cover_image || item.thumb,
    discogsUrl: item.uri ? `https://www.discogs.com${item.uri}` : null,
    source: 'discogs'
  };
}

/**
 * Recherche sur iTunes
 * @param {string} query - Recherche
 * @param {object} options - Options (limit, entity, country)
 * @returns {Promise<object>} - R√©sultats
 */
async function searchItunes(query, options = {}) {
  const { limit = MUSIC_DEFAULT_MAX, entity = 'album', country = 'FR' } = options;
  
  const url = `${ITUNES_BASE_URL}/search?term=${encodeURIComponent(query)}&entity=${entity}&country=${country}&limit=${limit}`;
  
  console.log(`[iTunes] Search: ${url}`);
  
  const response = await fetch(url, {
    headers: {
      'Accept': 'application/json',
      'User-Agent': USER_AGENT
    }
  });
  
  if (!response.ok) {
    throw new Error(`Erreur iTunes: ${response.status}`);
  }
  
  const data = await response.json();
  
  const results = (data.results || []).map(item => {
    if (entity === 'album') {
      return {
        id: item.collectionId,
        type: 'album',
        title: item.collectionName,
        artist: item.artistName,
        artistId: item.artistId,
        coverUrl: item.artworkUrl100,
        coverUrlLarge: item.artworkUrl100?.replace('100x100', '600x600'),
        releaseDate: item.releaseDate,
        year: item.releaseDate?.substring(0, 4),
        trackCount: item.trackCount,
        genre: item.primaryGenreName,
        price: item.collectionPrice,
        currency: item.currency,
        explicit: item.collectionExplicitness === 'explicit',
        itunesUrl: item.collectionViewUrl,
        source: 'itunes'
      };
    } else if (entity === 'musicArtist') {
      return {
        id: item.artistId,
        type: 'artist',
        name: item.artistName,
        genre: item.primaryGenreName,
        itunesUrl: item.artistLinkUrl,
        source: 'itunes'
      };
    } else {
      // song
      return {
        id: item.trackId,
        type: 'track',
        title: item.trackName,
        artist: item.artistName,
        album: item.collectionName,
        albumId: item.collectionId,
        duration: item.trackTimeMillis ? Math.round(item.trackTimeMillis / 1000) : null,
        durationFormatted: item.trackTimeMillis ? formatDuration(item.trackTimeMillis) : null,
        preview: item.previewUrl,
        coverUrl: item.artworkUrl100,
        explicit: item.trackExplicitness === 'explicit',
        price: item.trackPrice,
        itunesUrl: item.trackViewUrl,
        source: 'itunes'
      };
    }
  });
  
  return {
    query,
    entity,
    country,
    totalResults: data.resultCount || results.length,
    count: results.length,
    results,
    source: 'itunes'
  };
}

// === ENDPOINTS MUSIQUE ===

/**
 * Recherche d'albums de musique (multi-sources)
 * @route GET /music/search
 * @queryparam q - Recherche (requis)
 * @queryparam source - Source: musicbrainz, deezer, discogs, itunes, all (d√©faut: deezer)
 * @queryparam type - Type: album, artist, track (d√©faut: album)
 * @queryparam limit - Nombre de r√©sultats (d√©faut: 20, max: 100)
 * @queryparam lang - Langue/Pays (fr, en, de, us, gb, etc.) - utilis√© pour iTunes
 * @queryparam country - Alias pour lang (r√©trocompatibilit√©)
 * @queryparam discogsToken - Token Discogs (optionnel, via header X-Discogs-Token)
 */
app.get("/music/search", async (req, res) => {
  const { q, source = 'deezer', type = 'album' } = req.query;
  // Limite: valeur par d√©faut 20, max 100
  const limit = Math.min(Math.max(parseInt(req.query.limit) || MUSIC_DEFAULT_MAX, 1), 100);
  // Lang/Country: accepter les deux param√®tres, lang a priorit√©
  const langParam = req.query.lang || req.query.country || 'FR';
  // Normaliser: "fr-FR" -> "FR", "fr" -> "FR"
  const country = langParam.includes('-') ? langParam.split('-')[1].toUpperCase() : langParam.toUpperCase();
  const discogsToken = req.query.discogsToken || req.headers['x-discogs-token'];
  
  if (!q) {
    return res.status(400).json({ error: "param√®tre 'q' manquant" });
  }
  
  const cacheKey = `music:search:${source}:${type}:${q}:${limit}:${country}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    let result;
    
    switch (source.toLowerCase()) {
      case 'musicbrainz':
      case 'mb':
        metrics.sources.musicbrainz.requests++;
        result = await searchMusicBrainz(q, { limit, type: type === 'album' ? 'release-group' : type });
        break;
        
      case 'discogs':
        metrics.sources.discogs.requests++;
        const discogsType = type === 'album' ? 'release' : type;
        result = await searchDiscogs(q, { limit, type: discogsType, token: discogsToken });
        break;
        
      case 'itunes':
        const itunesEntity = type === 'album' ? 'album' : type === 'artist' ? 'musicArtist' : 'song';
        result = await searchItunes(q, { limit, entity: itunesEntity, country });
        break;
        
      case 'all':
        // Recherche sur toutes les sources en parall√®le (limite √† 10 par source pour perf)
        const limitPerSource = Math.min(limit, 10);
        const [deezerRes, mbRes, itunesRes] = await Promise.allSettled([
          searchDeezer(q, { limit: limitPerSource, type }),
          searchMusicBrainz(q, { limit: limitPerSource }),
          searchItunes(q, { limit: limitPerSource, entity: type === 'album' ? 'album' : 'song', country })
        ]);
        
        metrics.sources.deezer.requests++;
        metrics.sources.musicbrainz.requests++;
        
        result = {
          query: q,
          type,
          lang: country,
          sources: {
            deezer: deezerRes.status === 'fulfilled' ? deezerRes.value : { error: deezerRes.reason?.message },
            musicbrainz: mbRes.status === 'fulfilled' ? mbRes.value : { error: mbRes.reason?.message },
            itunes: itunesRes.status === 'fulfilled' ? itunesRes.value : { error: itunesRes.reason?.message }
          }
        };
        break;
        
      case 'deezer':
      default:
        metrics.sources.deezer.requests++;
        result = await searchDeezer(q, { limit, type });
        break;
    }
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/search:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

/**
 * D√©tails d'un album (Deezer)
 * @route GET /music/album/:id
 * @param id - ID album Deezer
 */
app.get("/music/album/:id", async (req, res) => {
  const { id } = req.params;
  const source = req.query.source || 'deezer';
  
  const cacheKey = `music:album:${source}:${id}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    let result;
    
    if (source === 'musicbrainz' || source === 'mb') {
      metrics.sources.musicbrainz.requests++;
      result = await getMusicBrainzAlbum(id);
    } else {
      metrics.sources.deezer.requests++;
      result = await getDeezerAlbum(id);
    }
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/album:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un artiste (Deezer)
 * @route GET /music/artist/:id
 * @param id - ID artiste Deezer
 */
app.get("/music/artist/:id", async (req, res) => {
  const { id } = req.params;
  
  const cacheKey = `music:artist:${id}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.deezer.requests++;
    const result = await getDeezerArtist(id);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/artist:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * D√©tails d'un release Discogs
 * @route GET /music/discogs/:id
 * @param id - ID release Discogs
 * @queryparam token - Token Discogs (optionnel, via header X-Discogs-Token)
 */
app.get("/music/discogs/:id", async (req, res) => {
  const { id } = req.params;
  const token = req.query.token || req.headers['x-discogs-token'];
  
  const cacheKey = `music:discogs:${id}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    metrics.sources.discogs.requests++;
    const result = await getDiscogsRelease(id, token);
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600); // Cache 1h
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/discogs:", err);
    metrics.requests.errors++;
    if (err.message.includes('non trouv√©')) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

/**
 * Recherche d'album par code-barres
 * @route GET /music/barcode/:code
 * @param code - Code-barres UPC/EAN
 * @queryparam source - Source: musicbrainz, discogs, all (d√©faut: all)
 * @queryparam discogsToken - Token Discogs (optionnel)
 */
app.get("/music/barcode/:code", async (req, res) => {
  const { code } = req.params;
  const source = req.query.source || 'all';
  const discogsToken = req.query.discogsToken || req.headers['x-discogs-token'];
  
  if (!code || code.length < 8) {
    return res.status(400).json({ error: "Code-barres invalide" });
  }
  
  const cacheKey = `music:barcode:${code}:${source}`;
  const cached = getCached(cacheKey);
  if (cached) {
    return res.json(cached);
  }
  
  try {
    let result = { barcode: code, found: false, sources: [] };
    
    if (source === 'all' || source === 'musicbrainz' || source === 'mb') {
      try {
        metrics.sources.musicbrainz.requests++;
        const mbResult = await searchMusicBrainzByBarcode(code);
        if (mbResult.found) {
          result.found = true;
          result.musicbrainz = mbResult;
          result.sources.push('musicbrainz');
          // Utiliser les donn√©es MB comme principales
          result.title = mbResult.title;
          result.artist = mbResult.artist;
          result.date = mbResult.date;
          result.coverUrl = mbResult.coverUrl;
        }
      } catch (err) {
        console.error('[Music] MusicBrainz barcode error:', err.message);
      }
    }
    
    if (source === 'all' || source === 'discogs') {
      try {
        metrics.sources.discogs.requests++;
        const discogsResult = await searchDiscogsByBarcode(code, discogsToken);
        if (discogsResult.found) {
          result.found = true;
          result.discogs = discogsResult;
          result.sources.push('discogs');
          // Remplir les donn√©es manquantes
          if (!result.title) result.title = discogsResult.albumTitle;
          if (!result.artist) result.artist = discogsResult.artist;
          if (!result.coverUrl) result.coverUrl = discogsResult.coverUrl;
        }
      } catch (err) {
        console.error('[Music] Discogs barcode error:', err.message);
      }
    }
    
    setCache(cacheKey, result);
    addCacheHeaders(res, 3600);
    res.json(result);
  } catch (err) {
    console.error("Erreur /music/barcode:", err);
    metrics.requests.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Endpoint utilitaire pour chiffrer une cl√© API (aide au d√©veloppement)
// Accessible uniquement si API_ENCRYPTION_KEY est configur√©e
app.post("/crypto/encrypt", express.json(), (req, res) => {
  if (!API_ENCRYPTION_KEY) {
    return res.status(400).json({ 
      error: "Chiffrement non activ√©",
      hint: "D√©finissez la variable d'environnement API_ENCRYPTION_KEY"
    });
  }
  
  const { key } = req.body;
  if (!key) {
    return res.status(400).json({ error: "param√®tre 'key' manquant dans le body JSON" });
  }
  
  const encrypted = encryptApiKey(key);
  if (!encrypted) {
    return res.status(500).json({ error: "√âchec du chiffrement" });
  }
  
  res.json({
    encrypted: encrypted,
    usage: "Utilisez cette valeur dans le header X-Encrypted-Key"
  });
});

// Endpoint de sant√© avec m√©triques avanc√©es
app.get("/health", (req, res) => {
  const uptime = Math.floor((Date.now() - metrics.startTime) / 1000);
  const avgResponseTime = metrics.responseTimeCount > 0 
    ? Math.round(metrics.responseTimeSum / metrics.responseTimeCount) 
    : 0;
  const cacheHitRate = metrics.requests.total > 0 
    ? Math.round((metrics.requests.cached / metrics.requests.total) * 100) 
    : 0;
  
  res.json({ 
    status: "ok", 
    fsr: FSR_BASE,
    uptime: `${uptime}s`,
    cache: {
      size: cache.size,
      maxSize: CACHE_MAX_SIZE,
      ttl: CACHE_TTL / 1000,
      hitRate: `${cacheHitRate}%`
    },
    metrics: {
      requests: {
        total: metrics.requests.total,
        cached: metrics.requests.cached,
        errors: metrics.requests.errors
      },
      avgResponseTime: `${avgResponseTime}ms`,
      sources: metrics.sources
    },
    compression: "gzip enabled"
  });
});

// Endpoint version de l'API
app.get("/version", (req, res) => {
  res.json({
    name: "Toys API",
    version: API_VERSION,
    features: [
      "LEGO search & product details",
      "Rebrickable API integration (sets, parts, minifigs, themes, colors)",
      "LEGO ‚Üî Rebrickable cross-enrichment",
      "Google Books search & details (ISBN/text)",
      "OpenLibrary search & details (ISBN/text)",
      "RAWG video games database (search/details)",
      "IGDB video games database (search/details via Twitch)",
      "TVDB TV series & movies database (search/details)",
      "TMDB movies & TV shows database (search/details)",
      "IMDB movies & TV database (search/details/browse - NO API KEY)",
      "Jikan anime & manga database (search/details - NO API KEY)",
      "Comic Vine comics database (search/volumes/issues)",
      "MangaDex manga database (search/details - NO API KEY)",
      "Bedetheque BD franco-belge (search/series/albums - scraping)",
      "JeuxVideo.com jeux vid√©o FR (search/details - scraping)",
      "ConsoleVariations consoles & accessories database (search/browse/details - scraping)",
      "Smart search (ID vs text detection)",
      "Coleka collectibles database",
      "Lulu-Berlu vintage toys",
      "Transformerland vintage Transformers",
      "Paninimania sticker albums (FR)",
      "Mega Construx search (multi-language: fr-FR, en-US, de-DE, etc.)",
      "Barcode identification (UPC, EAN, ISBN detection)",
      "Music search (MusicBrainz, Deezer, iTunes, Discogs)",
      "Encrypted API key support (AES-256-GCM)",
      "In-memory caching with TTL",
      "Gzip compression",
      "CORS enabled",
      "Metrics & monitoring"
    ],
    endpoints: {
      lego: ["/lego/search", "/lego/product/:id", "/lego/instructions/:id"],
      rebrickable: [
        "/rebrickable/search",
        "/rebrickable/set/:setNum",
        "/rebrickable/set/:setNum/parts",
        "/rebrickable/set/:setNum/minifigs",
        "/rebrickable/themes",
        "/rebrickable/colors"
      ],
      googlebooks: [
        "/googlebooks/search",
        "/googlebooks/book/:volumeId",
        "/googlebooks/isbn/:isbn"
      ],
      openlibrary: [
        "/openlibrary/search",
        "/openlibrary/book/:olId",
        "/openlibrary/isbn/:isbn"
      ],
      rawg: [
        "/rawg/search",
        "/rawg/game/:id"
      ],
      igdb: [
        "/igdb/search",
        "/igdb/game/:id"
      ],
      tvdb: [
        "/tvdb/search",
        "/tvdb/series/:id",
        "/tvdb/movie/:id"
      ],
      tmdb: [
        "/tmdb/search",
        "/tmdb/movie/:id",
        "/tmdb/tv/:id"
      ],
      imdb: [
        "/imdb/search (NO API KEY)",
        "/imdb/title/:id (NO API KEY)",
        "/imdb/browse (NO API KEY)"
      ],
      jikan: [
        "/jikan/anime (NO API KEY)",
        "/jikan/anime/:id (NO API KEY)",
        "/jikan/manga (NO API KEY)",
        "/jikan/manga/:id (NO API KEY)"
      ],
      comicvine: [
        "/comicvine/search",
        "/comicvine/volume/:id",
        "/comicvine/issue/:id"
      ],
      mangadex: [
        "/mangadex/search (NO API KEY)",
        "/mangadex/manga/:id (NO API KEY)"
      ],
      bedetheque: [
        "/bedetheque/search (scraping)",
        "/bedetheque/serie/:id (scraping)",
        "/bedetheque/album/:id (scraping)"
      ],
      jvc: [
        "/jvc/search (scraping)",
        "/jvc/game/:id (scraping)"
      ],
      consolevariations: [
        "/consolevariations/search?type=all|consoles|controllers|accessories (scraping)",
        "/consolevariations/item/:slug (scraping)",
        "/consolevariations/platforms (scraping)",
        "/consolevariations/browse/:platform (scraping)"
      ],
      coleka: ["/coleka/search", "/coleka/item"],
      luluberlu: ["/luluberlu/search", "/luluberlu/item/:id"],
      transformerland: ["/transformerland/search", "/transformerland/item"],
      paninimania: ["/paninimania/search", "/paninimania/album/:id", "/paninimania/album"],
      mega: [
        "/mega/search",
        "/mega/product/:id",
        "/mega/franchise/:franchise",
        "/mega/instructions",
        "/mega/instructions/:sku",
        "/mega/languages"
      ],
      barcode: [
        "/barcode/:code (auto-detect UPC/EAN/ISBN)",
        "/barcode/detect/:code",
        "/barcode/isbn/:isbn",
        "/barcode/bnf/:isbn"
      ],
      music: [
        "/music/search",
        "/music/album/:id",
        "/music/artist/:id",
        "/music/discogs/:id",
        "/music/barcode/:code"
      ],
      crypto: ["/crypto/encrypt (POST)", "/crypto/verify (POST)"],
      system: ["/health", "/version", "/cache (DELETE)", "/metrics (DELETE)"]
    },
    security: {
      encryption: API_ENCRYPTION_KEY ? "enabled" : "disabled",
      algorithm: "AES-256-GCM",
      headers: {
        encrypted: "X-Encrypted-Key",
        plain: "X-Api-Key (only if encryption disabled)"
      }
    }
  });
});

// Endpoint pour vider le cache
app.delete("/cache", (req, res) => {
  const size = cache.size;
  cache.clear();
  console.log(`[Cache] Vid√© (${size} entr√©es supprim√©es)`);
  res.json({ status: "ok", cleared: size });
});

// Endpoint pour r√©initialiser les m√©triques
app.delete("/metrics", (req, res) => {
  metrics.requests = { total: 0, cached: 0, errors: 0 };
  metrics.responseTimeSum = 0;
  metrics.responseTimeCount = 0;
  Object.keys(metrics.sources).forEach(key => {
    metrics.sources[key] = { requests: 0, errors: 0 };
  });
  console.log("[Metrics] R√©initialis√©es");
  res.json({ status: "ok", message: "Metrics reset" });
});

// Endpoint pour r√©cup√©rer les d√©tails d'un produit par son ID
// Avec option d'enrichissement Rebrickable (minifigs, pi√®ces)
// Les manuels d'instructions LEGO sont toujours inclus
app.get("/lego/product/:id", async (req, res) => {
  const productId = req.params.id;
  const lang = (req.query.lang || DEFAULT_LOCALE);
  const enrichRebrickable = req.query.enrich_rebrickable === 'true'; // D√©sactiv√© par d√©faut (requiert cl√© API)
  const maxParts = req.query.parts_limit ? parseInt(req.query.parts_limit, 10) : 500;

  if (!productId) return res.status(400).json({ error: "ID produit manquant" });

  try {
    metrics.sources.lego.requests++;
    let result = await getProductDetails(productId, lang);
    
    // Toujours r√©cup√©rer les manuels d'instructions LEGO
    try {
      const instructions = await getBuildingInstructions(productId, lang);
      if (instructions && instructions.manuals && instructions.manuals.length > 0) {
        result.instructions = {
          count: instructions.manuals.length,
          manuals: instructions.manuals
        };
        console.log(`[LEGO] ${instructions.manuals.length} manuels trouv√©s pour ${productId}`);
      } else {
        result.instructions = { count: 0, manuals: [] };
      }
    } catch (instructionsErr) {
      console.warn(`[LEGO] Impossible de r√©cup√©rer les instructions pour ${productId}: ${instructionsErr.message}`);
      result.instructions = { count: 0, manuals: [], error: instructionsErr.message };
    }
    
    // Enrichir avec Rebrickable si demand√© et si une cl√© API est fournie
    if (enrichRebrickable) {
      const apiKey = extractApiKey(req);
      if (apiKey) {
        try {
          result = await enrichLegoWithRebrickable(result, apiKey, { maxParts });
          console.log(`[LEGO] Produit ${productId} enrichi avec Rebrickable`);
        } catch (enrichErr) {
          console.warn(`[LEGO] √âchec enrichissement Rebrickable pour ${productId}: ${enrichErr.message}`);
          // On continue sans enrichissement en cas d'erreur
          result.rebrickable_error = enrichErr.message;
        }
      } else {
        result.rebrickable_hint = "Fournissez une cl√© API Rebrickable via X-Api-Key ou X-Encrypted-Key pour enrichir avec minifigs/pi√®ces";
      }
    }
    
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /lego/product:", err);
    metrics.requests.errors++;
    metrics.sources.lego.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Endpoint pour r√©cup√©rer les manuels d'instructions d'un produit
app.get("/lego/instructions/:id", async (req, res) => {
  const productId = req.params.id;
  const lang = (req.query.lang || DEFAULT_LOCALE);

  if (!productId) return res.status(400).json({ error: "ID produit manquant" });

  try {
    metrics.sources.lego.requests++;
    const result = await getBuildingInstructions(productId, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /lego/instructions:", err);
    metrics.requests.errors++;
    metrics.sources.lego.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Coleka
// -----------------------------

// Endpoint de recherche Coleka
app.get("/coleka/search", async (req, res) => {
  const q = req.query.q;
  const nbpp = req.query.nbpp ? parseInt(req.query.nbpp, 10) : COLEKA_DEFAULT_NBPP;
  const lang = req.query.lang || "fr";

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.sources.coleka.requests++;
    const result = await searchColekaLib(q, nbpp, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /coleka/search:", err);
    metrics.requests.errors++;
    metrics.sources.coleka.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Endpoint pour r√©cup√©rer les d√©tails d'un item Coleka
// Usage: /coleka/item/fr/lego/star-wars/millennium-falcon
// Ou: /coleka/item?path=/fr/lego/star-wars/millennium-falcon
app.get("/coleka/item", async (req, res) => {
  const itemPath = req.query.path;
  const lang = req.query.lang || "fr";

  if (!itemPath) return res.status(400).json({ error: "param√®tre 'path' manquant" });

  try {
    metrics.sources.coleka.requests++;
    const result = await getColekaItemDetails(itemPath, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /coleka/item:", err);
    metrics.requests.errors++;
    metrics.sources.coleka.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Endpoint alternatif avec path dans l'URL
app.get("/coleka/item/*", async (req, res) => {
  // R√©cup√©rer le chemin complet apr√®s /coleka/item/
  const itemPath = '/' + req.params[0];
  const lang = req.query.lang || "fr";

  try {
    metrics.sources.coleka.requests++;
    const result = await getColekaItemDetails(itemPath, lang);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /coleka/item/*:", err);
    metrics.requests.errors++;
    metrics.sources.coleka.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// -----------------------------
// Endpoints Lulu-Berlu
// -----------------------------

// Endpoint de recherche Lulu-Berlu
app.get("/luluberlu/search", async (req, res) => {
  const q = req.query.q;
  const max = req.query.max ? parseInt(req.query.max, 10) : LULUBERLU_DEFAULT_MAX;
  // Le param√®tre lang est ignor√© mais accept√© pour compatibilit√©
  // const lang = req.query.lang; // ignor√©

  if (!q) return res.status(400).json({ error: "param√®tre 'q' manquant" });

  try {
    metrics.sources.luluberlu.requests++;
    const result = await searchLuluBerluLib(q, max);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /luluberlu/search:", err);
    metrics.requests.errors++;
    metrics.sources.luluberlu.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Endpoint pour r√©cup√©rer les d√©tails d'un item Lulu-Berlu par son ID
app.get("/luluberlu/item/:id", async (req, res) => {
  const itemId = req.params.id;
  // Le param√®tre lang est ignor√© mais accept√© pour compatibilit√©
  // const lang = req.query.lang; // ignor√©

  if (!itemId) return res.status(400).json({ error: "ID item manquant" });

  try {
    metrics.sources.luluberlu.requests++;
    const result = await getLuluBerluItemDetails(itemId);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /luluberlu/item:", err);
    metrics.requests.errors++;
    metrics.sources.luluberlu.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Endpoint alternatif pour Lulu-Berlu avec URL compl√®te en query param
app.get("/luluberlu/item", async (req, res) => {
  const url = req.query.url;
  // Le param√®tre lang est ignor√© mais accept√© pour compatibilit√©

  if (!url) return res.status(400).json({ error: "param√®tre 'url' manquant" });

  try {
    metrics.sources.luluberlu.requests++;
    const result = await getLuluBerluItemDetails(url);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /luluberlu/item?url=:", err);
    metrics.requests.errors++;
    metrics.sources.luluberlu.errors++;
    if (err.message.includes("non trouv√©")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// ============================================================================
// PANINIMANIA - Fonctions et Endpoints
// ============================================================================

/**
 * Formate un terme de recherche pour Paninimania
 * - lowercase
 * - espaces remplac√©s par _
 * - caract√®res sp√©ciaux normalis√©s
 */
function formatPaninimaniaTerm(term) {
  return term
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Supprimer les accents
    .replace(/[^a-z0-9\s]/g, '') // Garder uniquement lettres, chiffres, espaces
    .trim()
    .replace(/\s+/g, '_'); // Espaces -> underscores
}

/**
 * Parse une cha√Æne de checklist en tableau de num√©ros
 * Supporte les formats: "1 √† 128", "1-128", "A1 √† A50", "H1 √† H6", "1, 2, 3", "1 √† 128 et H1 √† H6"
 * @param {string} checklistStr - Cha√Æne de checklist brute
 * @returns {Array<string>} - Tableau de num√©ros/codes
 */
function parseChecklistToArray(checklistStr) {
  if (!checklistStr) return [];
  
  const result = [];
  
  // S√©parer par "et" ou "," pour les groupes multiples
  const groups = checklistStr.split(/\s+et\s+|,\s*/i);
  
  for (const group of groups) {
    const trimmed = group.trim();
    if (!trimmed) continue;
    
    // V√©rifier si c'est une plage ("X √† Y" ou "X-Y")
    const rangeMatch = trimmed.match(/^([A-Za-z]*)?(\d+)\s*(?:√†|-|to)\s*([A-Za-z]*)?(\d+)$/i);
    
    if (rangeMatch) {
      const prefix1 = (rangeMatch[1] || '').toUpperCase();
      const start = parseInt(rangeMatch[2]);
      const prefix2 = (rangeMatch[3] || '').toUpperCase();
      const end = parseInt(rangeMatch[4]);
      
      // Utiliser le pr√©fixe s'il y en a un
      const prefix = prefix1 || prefix2 || '';
      
      if (start <= end && (end - start) <= 1000) { // Limite de s√©curit√©
        for (let i = start; i <= end; i++) {
          result.push(prefix + i.toString());
        }
      } else {
        // Si la plage est invalide, garder la cha√Æne originale
        result.push(trimmed);
      }
    } else {
      // C'est un num√©ro unique ou un code sp√©cial
      result.push(trimmed);
    }
  }
  
  return result;
}


// ============================================================================
// TRANSFORMERLAND - Fonctions et Endpoints
// ============================================================================

/**
 * R√©cup√®re les d√©tails d'un item ConsoleVariations par son slug
 * @param {string} slug - Slug de l'item (ex: "nes-mattel-super-mario-bros-bundle-uk")
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<object>} - D√©tails de l'item
 */
async function getConsoleVariationsItem(slug, retries = MAX_RETRIES) {
  const cacheKey = `consolevariations:item:${slug}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    console.log(`[ConsoleVariations] D√©tails item "${slug}" (tentative ${attempt}/${retries})`);
    
    try {
      if (!fsrSessionId) {
        await createFsrSession();
      }
      
      const itemUrl = `${CONSOLEVARIATIONS_BASE_URL}/collectibles/${slug}`;
      console.log(`[ConsoleVariations] Acc√®s √† ${itemUrl}`);
      
      const response = await fsrRequest("request.get", itemUrl, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      if (!response || !response.response) {
        throw new Error("Pas de r√©ponse FlareSolverr");
      }
      
      const html = response.response;
      
      // V√©rifier si c'est une page 404 (title sp√©cifique ou structure de page erreur)
      if (/<title>Not Found<\/title>/i.test(html) || /<h1[^>]*>Not Found<\/h1>/i.test(html)) {
        throw new Error(`Item non trouv√©: ${slug}`);
      }
      
      // Extraire le titre
      const titleMatch = html.match(/<h1[^>]*class="[^"]*text-2xl[^"]*"[^>]*>\s*([^<]+)\s*<\/h1>/i);
      const name = titleMatch ? decodeHtmlEntities(titleMatch[1].trim()) : slug.replace(/-/g, ' ');
      
      // Extraire les images depuis le JSON Alpine.js (x-data)
      // Format: images: JSON.parse('[{...}]')
      const images = [];
      const imagesMatch = html.match(/images:\s*JSON\.parse\('(\[[\s\S]*?\])'\)/);
      
      if (imagesMatch) {
        try {
          // D√©coder les unicode escapes
          const jsonStr = imagesMatch[1]
            .replace(/\\u0022/g, '"')
            .replace(/\\\//g, '/')
            .replace(/\\\\"/g, '\\"');
          
          const imagesData = JSON.parse(jsonStr);
          
          for (const img of imagesData) {
            images.push({
              id: img.id,
              url: img.original_url || img.preview_url,
              thumbnail: img.preview_url,
              alt: img.alt_text || '',
              mimeType: img.mime_type,
              size: img.size,
              contributor: img.user ? {
                id: img.user.id,
                username: img.user.username,
                avatar: img.user.profile_photo_url
              } : null
            });
          }
        } catch (e) {
          console.log(`[ConsoleVariations] Erreur parsing images JSON:`, e.message);
          
          // Fallback: extraire les URLs d'images directement
          const imgRegex = /src="(https:\/\/cdn\.consolevariations\.com\/[^"]+)"/gi;
          let imgMatch;
          const seenUrls = new Set();
          while ((imgMatch = imgRegex.exec(html)) !== null) {
            if (!seenUrls.has(imgMatch[1]) && !imgMatch[1].includes('profile-photos') && !imgMatch[1].includes('avatar')) {
              seenUrls.add(imgMatch[1]);
              images.push({
                url: imgMatch[1],
                thumbnail: imgMatch[1]
              });
            }
          }
        }
      }
      
      // Extraire les informations du tableau de d√©tails
      const details = {};
      
      // Pattern pour les lignes du tableau
      const tableRowRegex = /<tr>\s*<td[^>]*>\s*([^<]+)\s*<\/td>\s*<td[^>]*>\s*([\s\S]*?)\s*<\/td>\s*<\/tr>/gi;
      let rowMatch;
      
      while ((rowMatch = tableRowRegex.exec(html)) !== null) {
        const label = decodeHtmlEntities(rowMatch[1].trim().replace(/\s+/g, ' '));
        let value = rowMatch[2].trim();
        
        // Nettoyer le HTML de la valeur
        value = value.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
        value = decodeHtmlEntities(value);
        
        // Parser les valeurs sp√©cifiques
        switch (label.toLowerCase()) {
          case 'releases':
            // Extraire pays et ann√©e
            const releaseMatch = value.match(/([A-Za-z\s]+)\s*-?\s*(\d{4})?/);
            if (releaseMatch) {
              details.releaseCountry = releaseMatch[1].trim();
              details.releaseYear = releaseMatch[2] ? parseInt(releaseMatch[2]) : null;
            }
            break;
          case 'release type':
            details.releaseType = value;
            break;
          case 'amount produced estimate':
            details.amountProduced = value;
            break;
          case 'region code':
            details.regionCode = value;
            break;
          case 'limited edition':
            details.limitedEdition = value === 'Yes' ? true : (value === 'No' ? false : null);
            break;
          case 'color':
            details.color = value || null;
            break;
          case 'is bundle':
            details.isBundle = value === 'Yes';
            break;
          default:
            // Stocker les autres valeurs telles quelles
            const key = label.toLowerCase().replace(/\s+/g, '_');
            details[key] = value;
        }
      }
      
      // Extraire le score de raret√©
      const rarityMatch = html.match(/(\d+)\s*Rarity\s*Score/i);
      const rarityScore = rarityMatch ? parseInt(rarityMatch[1]) : null;
      
      // Extraire le score utilisateur
      const userScoreMatch = html.match(/(\w+)\s*(\d+)?\s*User\s*Score/i);
      const userScore = userScoreMatch ? userScoreMatch[1] : null;
      
      // Extraire le nombre de personnes qui veulent/poss√®dent
      const wantMatch = html.match(/(\d+)\s*people\s*want\s*this/i);
      const ownMatch = html.match(/(\d+)\s*people\s*own\s*this/i);
      const wantCount = wantMatch ? parseInt(wantMatch[1]) : 0;
      const ownCount = ownMatch ? parseInt(ownMatch[1]) : 0;
      
      // Extraire la description/info additionnelle
      const additionalInfoMatch = html.match(/Additional\s*Info[\s\S]*?<[^>]+>\s*([\s\S]*?)\s*<\/[^>]+>\s*Read\s*More/i);
      const additionalInfo = additionalInfoMatch ? decodeHtmlEntities(additionalInfoMatch[1].replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim()) : null;
      
      // Extraire la plateforme/console parente
      const platformMatch = html.match(/href="\/database\/([^"]+)"[^>]*>[\s\S]*?<span[^>]*>([^<]+)<\/span>/i);
      const platform = platformMatch ? {
        slug: platformMatch[1],
        name: decodeHtmlEntities(platformMatch[2].trim())
      } : null;
      
      // Extraire la marque
      const brandMatch = html.match(/href="\/browse\/brand\/([^"\/]+)"/i);
      const brand = brandMatch ? brandMatch[1].charAt(0).toUpperCase() + brandMatch[1].slice(1) : null;
      
      // Extraire le barcode si pr√©sent
      const barcodeMatch = html.match(/Barcode:\s*(\d+)/i);
      const barcode = barcodeMatch ? barcodeMatch[1] : null;
      
      const result = {
        source: "consolevariations",
        slug,
        name,
        url: itemUrl,
        brand,
        platform,
        images,
        details: {
          releaseCountry: details.releaseCountry || null,
          releaseYear: details.releaseYear || null,
          releaseType: details.releaseType || null,
          regionCode: details.regionCode || null,
          amountProduced: details.amountProduced || null,
          limitedEdition: details.limitedEdition,
          isBundle: details.isBundle || false,
          color: details.color || null,
          barcode
        },
        stats: {
          rarityScore,
          userScore,
          wantCount,
          ownCount
        },
        additionalInfo
      };
      
      setCache(cacheKey, result);
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[ConsoleVariations] Erreur tentative ${attempt}:`, err.message);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

/**
 * Liste les plateformes disponibles sur ConsoleVariations
 * @param {string} brand - Marque optionnelle (nintendo, sony, microsoft, sega...)
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<object>} - Liste des plateformes
 */
async function listConsoleVariationsPlatforms(brand = null, retries = MAX_RETRIES) {
  const cacheKey = `consolevariations:platforms:${brand || 'all'}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    console.log(`[ConsoleVariations] Liste plateformes${brand ? ` (${brand})` : ''} (tentative ${attempt}/${retries})`);
    
    try {
      if (!fsrSessionId) {
        await createFsrSession();
      }
      
      const url = brand 
        ? `${CONSOLEVARIATIONS_BASE_URL}/browse/brand/${brand.toLowerCase()}/platforms`
        : `${CONSOLEVARIATIONS_BASE_URL}/browse/brand`;
      
      console.log(`[ConsoleVariations] Acc√®s √† ${url}`);
      
      const response = await fsrRequest("request.get", url, fsrSessionId, {
        waitInSeconds: 2
      }, 60000);
      
      if (!response || !response.response) {
        throw new Error("Pas de r√©ponse FlareSolverr");
      }
      
      const html = response.response;
      const platforms = [];
      
      if (brand) {
        // Extraire les plateformes de la marque
        // Pattern: href="/database/slug" avec nom
        const platformRegex = /href="\/database\/([^"]+)"[^>]*>[\s\S]*?(?:<img[^>]*src="([^"]*)")?[\s\S]*?([A-Za-z0-9\s]+(?:PSP|PlayStation|Xbox|Switch|Game\s*Boy|NES|SNES|Genesis|Saturn|Dreamcast|Wii|DS|3DS)[A-Za-z0-9\s]*)/gi;
        
        // Plus simple: chercher tous les liens /database/
        const simpleRegex = /href="\/database\/([^"]+)"[^>]*>[^<]*<[^>]*>[^<]*([^<]+)/gi;
        let match;
        const seen = new Set();
        
        while ((match = simpleRegex.exec(html)) !== null) {
          const slug = match[1];
          if (!seen.has(slug) && !slug.includes('?')) {
            seen.add(slug);
            const name = decodeHtmlEntities(match[2].trim());
            if (name && name.length > 1) {
              platforms.push({
                slug,
                name,
                url: `${CONSOLEVARIATIONS_BASE_URL}/database/${slug}`
              });
            }
          }
        }
      } else {
        // Extraire les marques
        const brandRegex = /href="\/browse\/brand\/([^"\/]+)(?:\/platforms)?"[^>]*>[\s\S]*?(?:<img[^>]*>)?[\s\S]*?([A-Za-z0-9\s]+)<\/a>/gi;
        let match;
        const seen = new Set();
        
        while ((match = brandRegex.exec(html)) !== null) {
          const slug = match[1];
          if (!seen.has(slug)) {
            seen.add(slug);
            platforms.push({
              slug,
              name: decodeHtmlEntities(match[2].trim()) || slug.charAt(0).toUpperCase() + slug.slice(1),
              url: `${CONSOLEVARIATIONS_BASE_URL}/browse/brand/${slug}/platforms`
            });
          }
        }
      }
      
      const result = {
        source: "consolevariations",
        type: brand ? "platforms" : "brands",
        brand: brand || null,
        total: platforms.length,
        items: platforms
      };
      
      setCache(cacheKey, result, 3600000); // Cache 1 heure pour les listes statiques
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[ConsoleVariations] Erreur tentative ${attempt}:`, err.message);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

/**
 * Browse les items d'une plateforme sp√©cifique
 * @param {string} platformSlug - Slug de la plateforme (ex: "nes", "sony-playstation")
 * @param {number} maxResults - Nombre max de r√©sultats
 * @param {number} retries - Nombre de tentatives
 * @returns {Promise<object>} - Items de la plateforme
 */
async function browseConsoleVariationsPlatform(platformSlug, maxResults = CONSOLEVARIATIONS_DEFAULT_MAX, retries = MAX_RETRIES) {
  const cacheKey = `consolevariations:browse:${platformSlug}:${maxResults}`;
  const cached = getCached(cacheKey);
  if (cached) return cached;
  
  let attempt = 0;
  let lastError = null;
  
  while (attempt < retries) {
    attempt++;
    console.log(`[ConsoleVariations] Browse plateforme "${platformSlug}" (tentative ${attempt}/${retries})`);
    
    try {
      if (!fsrSessionId) {
        await createFsrSession();
      }
      
      const url = `${CONSOLEVARIATIONS_BASE_URL}/database/${platformSlug}`;
      console.log(`[ConsoleVariations] Acc√®s √† ${url}`);
      
      const response = await fsrRequest("request.get", url, fsrSessionId, {
        waitInSeconds: 3
      }, 60000);
      
      if (!response || !response.response) {
        throw new Error("Pas de r√©ponse FlareSolverr");
      }
      
      const html = response.response;
      
      // V√©rifier si c'est une page 404 (title sp√©cifique ou structure de page erreur)
      if (/<title>Not Found<\/title>/i.test(html) || /<h1[^>]*>Not Found<\/h1>/i.test(html)) {
        throw new Error(`Plateforme non trouv√©e: ${platformSlug}`);
      }
      
      const items = [];
      const seen = new Set();
      
      // Approche 1: Extraire les liens complets vers collectibles avec leur contexte
      // Les URLs compl√®tes (avec domaine) sont dans le corps principal
      const fullLinkRegex = /href="https?:\/\/consolevariations\.com\/collectibles\/([^"]+)"[^>]*>\s*([^<]*)</gi;
      let match;
      
      while ((match = fullLinkRegex.exec(html)) !== null && items.length < maxResults) {
        const slug = match[1];
        let name = match[2] ? match[2].trim() : null;
        
        // Ignorer les noms vides ou tr√®s courts
        if (slug && !seen.has(slug) && name && name.length > 2) {
          seen.add(slug);
          
          // Chercher l'image CDN la plus proche pour ce slug (avec ID num√©rique dans l'URL)
          const imgPattern = new RegExp(`src="(https://cdn\\.consolevariations\\.com/\\d+/[^"]+)"[^>]*alt="[^"]*${slug.replace(/-/g, '.*?')}`, 'i');
          let imgMatch = html.match(imgPattern);
          
          // Si pas trouv√©, chercher une image CDN avec num√©ro dans les 2000 caract√®res avant ce match
          if (!imgMatch) {
            const startIdx = Math.max(0, match.index - 2000);
            const context = html.substring(startIdx, match.index);
            const imgInContext = context.match(/src="(https:\/\/cdn\.consolevariations\.com\/\d+\/[^"]+)"/gi);
            if (imgInContext && imgInContext.length > 0) {
              // Prendre la derni√®re image (la plus proche du lien)
              const lastImg = imgInContext[imgInContext.length - 1];
              imgMatch = [null, lastImg.match(/src="([^"]+)"/)[1]];
            }
          }
          
          items.push({
            slug,
            name: decodeHtmlEntities(name),
            url: `${CONSOLEVARIATIONS_BASE_URL}/collectibles/${slug}`,
            thumbnail: imgMatch ? imgMatch[1] : null
          });
        }
      }
      
      // Si pas assez de r√©sultats, essayer un pattern alternatif avec URLs relatives
      if (items.length < maxResults) {
        const altRegex = /href="\/collectibles\/([^"]+)"/gi;
        while ((match = altRegex.exec(html)) !== null && items.length < maxResults) {
          const slug = match[1];
          if (!seen.has(slug)) {
            seen.add(slug);
            items.push({
              slug,
              name: slug.replace(/-/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
              url: `${CONSOLEVARIATIONS_BASE_URL}/collectibles/${slug}`,
              thumbnail: null
            });
          }
        }
      }
      
      const result = {
        source: "consolevariations",
        platform: platformSlug,
        total: items.length,
        items: items.slice(0, maxResults)
      };
      
      setCache(cacheKey, result);
      return result;
      
    } catch (err) {
      lastError = err;
      console.error(`[ConsoleVariations] Erreur tentative ${attempt}:`, err.message);
      
      if (fsrSessionId) {
        await destroyFsrSession(fsrSessionId);
        fsrSessionId = null;
      }
      
      if (attempt >= retries) break;
      await new Promise(r => setTimeout(r, 2000 * attempt));
    }
  }
  
  throw lastError || new Error("√âchec apr√®s toutes les tentatives");
}

// === Endpoints ConsoleVariations ===

// Recherche de consoles/accessoires/controllers
// type: 'all' (d√©faut), 'consoles', 'controllers', 'accessories'
app.get("/consolevariations/search", async (req, res) => {
  const { q, query, max, type } = req.query;
  const searchTerm = q || query;
  const maxResults = max ? parseInt(max) : CONSOLEVARIATIONS_DEFAULT_MAX;
  const searchType = type || 'all'; // all, consoles, controllers, accessories
  
  if (!searchTerm) {
    return res.status(400).json({ error: "Param√®tre 'q' ou 'query' manquant" });
  }
  
  // Valider le type
  if (!['all', 'consoles', 'controllers', 'accessories'].includes(searchType)) {
    return res.status(400).json({ 
      error: "Param√®tre 'type' invalide", 
      validValues: ['all', 'consoles', 'controllers', 'accessories'] 
    });
  }
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await searchConsoleVariationsLib(searchTerm, maxResults, searchType);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/search:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    res.status(500).json({ error: err.message });
  }
});

// D√©tails d'un item par slug
app.get("/consolevariations/item/:slug", async (req, res) => {
  const { slug } = req.params;
  
  if (!slug) {
    return res.status(400).json({ error: "Param√®tre 'slug' manquant" });
  }
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await getConsoleVariationsItem(slug);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/item:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// Liste des marques ou plateformes d'une marque
app.get("/consolevariations/platforms", async (req, res) => {
  const { brand } = req.query;
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await listConsoleVariationsPlatforms(brand);
    addCacheHeaders(res, 3600); // Cache 1 heure
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/platforms:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    res.status(500).json({ error: err.message });
  }
});

// Browse une plateforme sp√©cifique
app.get("/consolevariations/browse/:platform", async (req, res) => {
  const { platform } = req.params;
  const { max } = req.query;
  const maxResults = max ? parseInt(max) : CONSOLEVARIATIONS_DEFAULT_MAX;
  
  if (!platform) {
    return res.status(400).json({ error: "Param√®tre 'platform' manquant" });
  }
  
  try {
    metrics.sources.consolevariations.requests++;
    const result = await browseConsoleVariationsPlatform(platform, maxResults);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /consolevariations/browse:", err);
    metrics.requests.errors++;
    metrics.sources.consolevariations.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// === Endpoint recherche Transformerland ===
app.get("/transformerland/search", async (req, res) => {
  const { q, term, max } = req.query;
  const searchTerm = q || term;
  const maxResults = max ? parseInt(max) : TRANSFORMERLAND_DEFAULT_MAX;
  
  if (!searchTerm) {
    return res.status(400).json({ error: "param√®tre 'q' ou 'term' manquant" });
  }
  
  try {
    metrics.sources.transformerland.requests++;
    const result = await searchTransformerlandLib(searchTerm, maxResults);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /transformerland/search:", err);
    metrics.requests.errors++;
    metrics.sources.transformerland.errors++;
    res.status(500).json({ error: err.message });
  }
});

// === Endpoint d√©tails article Transformerland par URL ===
app.get("/transformerland/item", async (req, res) => {
  const { url } = req.query;
  
  if (!url) {
    return res.status(400).json({ error: "param√®tre 'url' manquant" });
  }
  
  try {
    metrics.sources.transformerland.requests++;
    const result = await getTransformerlandItemDetails(url);
    addCacheHeaders(res, 300);
    res.json(result);
  } catch (err) {
    console.error("Erreur /transformerland/item:", err);
    metrics.requests.errors++;
    metrics.sources.transformerland.errors++;
    if (err.message.includes("non trouv√©") || err.message.includes("not found")) {
      res.status(404).json({ error: err.message });
    } else {
      res.status(500).json({ error: err.message });
    }
  }
});

// D√©marrer le serveur
const server = app.listen(PORT, "0.0.0.0", () => {
  console.log(`üöÄ Toys API running at http://0.0.0.0:${PORT}`);
  console.log(`   - LEGO: /lego/search, /lego/product/:id, /lego/instructions/:id`);
  console.log(`   - Coleka: /coleka/search, /coleka/item`);
  console.log(`   - Lulu-Berlu: /luluberlu/search, /luluberlu/item/:id`);
  console.log(`   - ConsoleVariations: /consolevariations/search, /consolevariations/item/:slug, /consolevariations/platforms, /consolevariations/browse/:platform`);
  console.log(`   - Transformerland: /transformerland/search, /transformerland/item`);
  console.log(`   - Paninimania: /paninimania/search, /paninimania/album/:id`);
  console.log(`   - Compression: gzip enabled`);
  console.log(`   - CORS: enabled`);
  console.log(`   - Metrics: /health, DELETE /metrics`);
});

// Graceful shutdown - fermeture propre lors de l'arr√™t
const gracefulShutdown = async (signal) => {
  console.log(`\n‚ö†Ô∏è  ${signal} re√ßu. Arr√™t gracieux en cours...`);
  
  // D√©truire la session FlareSolverr si elle existe
  if (fsrSessionId) {
    try {
      console.log("[FSR] Destruction de la session...");
      await destroyFsrSession(fsrSessionId);
      console.log("[FSR] Session d√©truite");
    } catch (err) {
      console.error("[FSR] Erreur destruction session:", err.message);
    }
  }
  
  // Fermer le serveur HTTP
  server.close(() => {
    console.log("‚úÖ Serveur HTTP ferm√©");
    console.log(`üìä Stats finales: ${metrics.requests.total} requ√™tes, ${metrics.requests.cached} en cache, ${metrics.requests.errors} erreurs`);
    process.exit(0);
  });
  
  // Forcer la fermeture apr√®s 10 secondes
  setTimeout(() => {
    console.error("‚ö†Ô∏è  For√ßage de l'arr√™t apr√®s timeout");
    process.exit(1);
  }, 10000);
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));
